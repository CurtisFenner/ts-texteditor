{"version":3,"file":"shiru-amd.js","sourceRoot":"","sources":["../src/shiru/ir.ts","../src/shiru/lexer.ts","../src/shiru/diagnostics.ts","../src/shiru/parser.ts","../src/shiru/grammar.ts","../src/shiru/interpreter.ts","../src/shiru/data.ts","../src/shiru/semantics.ts","../src/shiru/egraph.ts","../src/shiru/sat.ts","../src/shiru/smt.ts","../src/shiru/uf.ts","../src/shiru/verify.ts","../src/shiru/library.ts"],"names":[],"mappings":"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","sourcesContent":["/// `SourceLocation` represents a span of a file.\nexport interface SourceLocation {\n\tfileID: string,\n\n\t// The offset from the first character, measured in UTF-16 code-units\n\t// (JavaScript \"characters\").\n\toffset: number,\n\n\t// The length of the span, measured in UTF-16 code-units (JavaScript\n\t// \"characters\")\n\tlength: number,\n}\n\nexport const NONE: SourceLocation = {\n\tfileID: \"unknown\",\n\toffset: 0,\n\tlength: 0,\n}\n\nexport function locationSpan(from: SourceLocation, to: SourceLocation) {\n\treturn {\n\t\tfileID: from.fileID,\n\t\toffset: from.offset,\n\t\tlength: to.offset + to.length - from.offset,\n\t};\n}\n\nexport function locationsSpan(set: { location: SourceLocation }[]): SourceLocation {\n\tconst smallest = Math.min(...set.map(x => x.location.offset));\n\tconst largest = Math.max(...set.map(x => x.location.offset + x.location.length));\n\treturn {\n\t\tfileID: set[0].location.fileID,\n\t\toffset: smallest,\n\t\tlength: largest - smallest,\n\t};\n}\n\n/// `TypePrimitive` represents one of the \"built-in\" primitive types:\n/// `\"Bytes\"` is the type of immutable finite sequences of octets.\n/// `\"Unit\"` is the type of a single value: \"unit\".\n/// `\"Boolean\"` is the type of two values: \"true\" and \"false\".\n/// `\"Int\"` is the type of unbounded integers: ..., -3, -2, -1, 0, 1, 2, 3, ...\nexport interface TypePrimitive {\n\ttag: \"type-primitive\",\n\tprimitive: \"Bytes\" | \"Unit\" | \"Boolean\" | \"Int\",\n};\n\nexport const T_INT: TypePrimitive = { tag: \"type-primitive\", primitive: \"Int\" };\nexport const T_BOOLEAN: TypePrimitive = { tag: \"type-primitive\", primitive: \"Boolean\" };\nexport const T_BYTES: TypePrimitive = { tag: \"type-primitive\", primitive: \"Bytes\" };\nexport const T_UNIT: TypePrimitive = { tag: \"type-primitive\", primitive: \"Unit\" };\nexport const T_ANY: TypeAny = { tag: \"type-any\" };\n\n/// `TypeCompound` represents the type which is an instance of a given entity\n/// type.\nexport interface TypeCompound {\n\ttag: \"type-compound\",\n\n\t/// `base` references a `RecordDefinition` in a `Program`.\n\tbase: RecordID | EnumID,\n\n\ttype_arguments: Type[],\n};\n\n/// `TypeVariable` represents the type which is a parameter of a function or\n/// compound type.\nexport interface TypeVariable {\n\ttag: \"type-variable\",\n\tid: TypeVariableID,\n};\n\nexport interface TypeAny {\n\ttag: \"type-any\",\n};\n\nexport type Type = TypePrimitive | TypeCompound | TypeVariable | TypeAny;\n\nexport type FunctionID = string & { __brand: \"function-id\" };\nexport type VariableID = string & { __brand: \"variable-id\" };\nexport type RecordID = string & { __brand: \"record-id\" };\nexport type EnumID = string & { __brand: \"enum-id\" };\nexport type InterfaceID = string & { __brand: \"interface-id\" };\nexport type TypeVariableID = string & { __brand: \"type-variable-id\" };\n\nexport interface VariableDefinition {\n\tvariable: VariableID,\n\ttype: Type,\n\t// The location of this variable, for basic IDE support.\n\tlocation: SourceLocation,\n}\n\n/// `OpConst` defines a primitive-typed destination variable with a constant.\nexport type OpConst = {\n\ttag: \"op-const\",\n\tdestination: VariableDefinition,\n} & (OpConstInt | OpConstBytes | OpConstBoolean);\n\nexport interface OpConstInt {\n\ttype: \"Int\",\n\n\t// `int` is encoded as ASCII digits.\n\tint: string,\n}\n\nexport interface OpConstBytes {\n\ttype: \"Bytes\",\n\t// TODO: Encoding\n\tbytes: string,\n}\n\nexport interface OpConstBoolean {\n\ttype: \"Boolean\",\n\tboolean: boolean,\n}\n\nexport interface Copy {\n\tsource: VariableID,\n\tdestination: VariableDefinition,\n}\n\n/// `OpCopy` copies a value from one variable to a new variable.\nexport interface OpCopy {\n\ttag: \"op-copy\",\n\n\tcopies: Copy[],\n}\n\n/// `OpProofEq` determines whether or not two objects are the same. This\n/// operation is only valid in proof contexts.\nexport interface OpProofEq {\n\ttag: \"op-proof-eq\",\n\n\tleft: VariableID,\n\tright: VariableID,\n\n\tdestination: VariableDefinition,\n}\n\n/// `OpBranch` chooses which branch to execute depending on the current value of\n/// a `condition` variable.\n/// It defines a set of variables, with values selected by the branches.\nexport interface OpBranch {\n\ttag: \"op-branch\",\n\n\t/// The condition must have type boolean.\n\tcondition: VariableID,\n\n\ttrueBranch: OpBlock,\n\tfalseBranch: OpBlock,\n\n\tdestinations: BranchPhi[],\n};\n\nexport interface BranchPhi {\n\tdestination: VariableDefinition,\n\n\t/// `trueSource` is the local variable within the `trueBranch` block which\n\t/// contains this value of this variable if the `true` branch was taken.\n\ttrueSource: { tag: \"variable\", variable: VariableID } | \"undef\",\n\n\t/// `falseSource` is the local variable within the `falseBranch` block which\n\t/// contains the vlaue of this variable if the `false` branch was taken.\n\tfalseSource: { tag: \"variable\", variable: VariableID } | \"undef\",\n}\n\n/// `OpNewRecord` defines a new variable with a newly created instance of a\n/// specified record.\nexport interface OpNewRecord {\n\ttag: \"op-new-record\",\n\trecord: RecordID,\n\n\t/// The types of the fields must be the same as the types of the\n\t/// `destination` variable's fields (with appropriate instantiation of any\n\t/// `parameter`s in the record type).\n\tfields: { [fieldName: string]: VariableID },\n\n\t/// The destination must have a type of the specified record.\n\tdestination: VariableDefinition,\n};\n\n/// `OpNewEnum` defines a new variable with a newly created instance of a\n/// specified enum.\nexport interface OpNewEnum {\n\ttag: \"op-new-enum\",\n\tenum: EnumID,\n\n\t/// The type of the variant value must be the same as the type of the enum's\n\t/// variant (with appropriate instantiation of any `parameter`s in the enum\n\t/// type)\n\tvariant: string,\n\tvariantValue: VariableID,\n\n\t/// The destination must have a type of the specified enum.\n\tdestination: VariableDefinition,\n};\n\nexport interface OpIsVariant {\n\ttag: \"op-is-variant\",\n\n\t/// The base must have enum type.\n\tbase: VariableID,\n\n\t/// The variant must be a variant of the base's type.\n\tvariant: string,\n\n\t/// The test result must have Boolean type.\n\tdestination: VariableDefinition,\n};\n\n/// `OpField` defines a new `destination` variable with the field extracted from\n/// an indicated record variable.\nexport interface OpField {\n\ttag: \"op-field\",\n\n\t/// The `object` variable must be a record type.\n\tobject: VariableID,\n\n\t/// The `field` must be one of the keys in the `fields` map of the\n\t/// `RecordDefinition` corresponding to the record type of this `object`.\n\tfield: string,\n\n\t/// The type of the `destination` variable must be the same as the type of\n\t/// the `field` within the `object` variable (with appropriate instantiation\n\t/// of any `parameter`s in the record type).\n\tdestination: VariableDefinition,\n};\n\n/// `OpVariant` defines a new `destination` variable with the variant extracted\n/// from an indicated enum variable.\nexport interface OpVariant {\n\ttag: \"op-variant\",\n\n\t/// The `object` variable must be a enum type.\n\tobject: VariableID,\n\n\t/// The `variant` must be one of the keys in the `fields` map of the\n\t/// `EnumDefinition` corresponding to the enum\n\t/// type of this `object`.\n\tvariant: string,\n\n\t/// The type of the `destination` variable must be the same as the type of\n\t/// the `variant` within the `object` variable (with appropriate\n\t/// instantiation of any `parameter`s in the enum type).\n\tdestination: VariableDefinition,\n\n\t/// The location of the access.\n\tdiagnostic_location: SourceLocation,\n};\n\nexport interface OpStaticCall {\n\ttag: \"op-static-call\",\n\tfunction: FunctionID,\n\n\t/// The types of arguments must be equal to the types of the `parameters` in\n\t/// the corresponding `parameters` of the `FunctionSignature` for this\n\t/// function call (with appropriate instantiation of any `type_arguments`).\n\targuments: VariableID[],\n\ttype_arguments: Type[],\n\n\t/// The types of destinations must be equal to the types of the\n\t/// `return_types` of the `FunctionSignature` for this function call (with\n\t/// appropriate instantiation of any `type_arguments`).\n\tdestinations: VariableDefinition[],\n\n\tdiagnostic_callsite: SourceLocation,\n};\n\nexport interface OpDynamicCall {\n\ttag: \"op-dynamic-call\",\n\tconstraint: ConstraintParameter,\n\n\t// The index of the function to call within the interface's signature list.\n\tsignature_id: string,\n\n\t/// The type arguments to pass, corresponding to the `type_parameters` array\n\t/// of the corresponding constraint signature.\n\t/// Note that the v-table closure may use only some of these, in addition to\n\t/// others stored in the closure context.\n\tsignature_type_arguments: Type[],\n\n\targuments: VariableID[],\n\tdestinations: VariableDefinition[],\n\n\tdiagnostic_callsite: SourceLocation;\n};\n\nexport interface OpReturn {\n\ttag: \"op-return\",\n\tsources: VariableID[],\n\n\tdiagnostic_return_site: SourceLocation,\n};\n\nexport interface OpBlock {\n\tops: Op[],\n};\n\n/// `OpProof` represents a \"proof\" -- code that isn't run. All statements (i.e.,\n/// function calls) in the body of an OpProof must be total (terminate).\nexport interface OpProof {\n\ttag: \"op-proof\",\n\tbody: OpBlock,\n};\n\n/// `OpUnreachable` indicates a point in the program which is unreachable\n/// assuming static analysis was properly performed. If reached at runtime (this\n/// should only be possible when verification is skipped), the interpreter will\n/// crash. However, a \"fast\" backend may instead choose to invoke undefined\n/// behavior.\nexport interface OpUnreachable {\n\ttag: \"op-unreachable\",\n\n\tdiagnostic_kind: \"contract\" | \"return\" | \"match\" | \"unreachable\";\n\tdiagnostic_location: SourceLocation,\n};\n\n/// `OpForeign` represents a call to a pure function provided by the host of the\n/// interpreter. This includes the operations on primitive types, like\n/// arithmetic and byte-slicing.\nexport interface OpForeign {\n\ttag: \"op-foreign\",\n\toperation: string,\n\targuments: VariableID[],\n\tdestinations: VariableDefinition[],\n};\n\nexport type LeafOp = OpConst\n\t| OpCopy\n\t| OpProofEq\n\t| OpNewRecord | OpNewEnum | OpField | OpVariant | OpIsVariant\n\t| OpStaticCall | OpDynamicCall\n\t| OpForeign\n\t| OpReturn\n\t| OpUnreachable;\n\nexport type Op = OpBranch | OpProof | LeafOp;\n\nexport interface IRInterface {\n\t/// The type-parameters of this interface.\n\t/// All interfaces have at least one type-parameter (the \"this\" parameter).\n\ttype_parameters: TypeVariableID[],\n\n\t/// N.B.: The `type_parameters` array of each member does not include the\n\t/// `type_parameters` of the interface.\n\tsignatures: Record<string, FunctionSignature>,\n};\n\nexport interface ConstraintParameter {\n\tinterface: InterfaceID,\n\tsubjects: Type[],\n};\n\nexport interface Precondition {\n\tblock: OpBlock,\n\n\t// Executing `block` results in a assignment to the boolean `precondition`\n\t// variable, which is defined by an op-var and visible within this block.\n\tprecondition: VariableID,\n\n\tlocation: SourceLocation,\n}\n\nexport interface Postcondition {\n\tblock: OpBlock,\n\n\t// Bindings for the returned values. (The parameters of the containing\n\t// `FunctionSignature` are also in scope for a `Postcondition`)\n\treturnedValues: VariableDefinition[],\n\n\t// Executing `block` results in an assignment to the boolean `postcondition`\n\t// variable, which is defined by an op-var and visible within this block.\n\t// Callsites may assume that the result is true.\n\t// Implementations must verify that the result is true.\n\tpostcondition: VariableID,\n\n\tlocation: SourceLocation,\n}\n\nexport interface FunctionSignature {\n\t/// The type-parameters bound by this signature.\n\t/// For a IRInterface signature, this does NOT include the type-parameters\n\t/// of the interface.\n\t/// For an impl function, these correspond to\n\t/// <`for_any` of containing impl>.concat(<type_parameters of interface signature>)\n\t/// but the names may be different.\n\ttype_parameters: TypeVariableID[],\n\n\t/// A v-table is passed at runtime for each constraint in\n\t/// `constraint_parameters`.\n\tconstraint_parameters: ConstraintParameter[],\n\n\t/// `parameters` is the sequence of types for each function parameter.\n\tparameters: VariableDefinition[],\n\n\t/// `returns` is the sequence of types for each function return.\n\treturn_types: Type[],\n\n\t// TODO: Add termination-measure function.\n\n\tpreconditions: Precondition[],\n\tpostconditions: Postcondition[],\n\n\tsemantics?: {\n\t\t/// Indicates that this is a congruence relation, which is an\n\t\t/// equivalence relation that respects extensionality.\n\t\t/// That is, a == b implies f(a) == f(b).\n\t\teq?: true,\n\t},\n};\n\nexport interface IRFunction {\n\tsignature: FunctionSignature,\n\tbody: OpBlock,\n};\n\nexport interface RecordDefinition {\n\t/// N.B.: Records are NOT existential types; while they have type\n\t/// parameters, they do NOT hold constraint implementations. Instead, those\n\t/// are passed by callers of methods.\n\ttype_parameters: TypeVariableID[],\n\n\t/// The fields defined by this record.\n\tfields: {\n\t\t[field: string]: Type,\n\t},\n};\n\nexport interface EnumDefinition {\n\ttype_parameters: TypeVariableID[],\n\n\t/// The variants defined by this enum.\n\tvariants: {\n\t\t[variant: string]: Type,\n\t},\n}\n\nexport interface VTableFactory {\n\t// The number of type arguments that the v-table factory takes.\n\t// These are instantiated in `interface_arguments`.\n\tfor_any: TypeVariableID[],\n\n\t/// `provides` is the `ConstraintParameter` that this `VTableFactory`\n\t/// provides.\n\tprovides: ConstraintParameter,\n\n\t// The functions to call for the corresponding signatures in the interface.\n\tentries: Record<string, VTableFactoryEntry>,\n};\n\nexport interface VTableFactoryEntry {\n\timplementation: FunctionID,\n\n\t/// `constraint_parameters` has one element for each of the\n\t/// `constraint_parameters` in the `FunctionSignature` of the\n\t/// implementating function.\n\t/// A `number` element indicates the index within the _interface_'s\n\t/// signature to use; a `ConstraintParameter` indicates a v-table to be\n\t/// captured as a closure when this v-table entry is constructed. These\n\t/// specifications may reference variables from the `for_any`\n\t/// parameterization of the containing `VTableFactory`.\n\tconstraint_parameters: (number | ConstraintParameter)[],\n};\n\n/// `Program` represents a Shiru program: a collection of function definitions\n/// and type and constraint definitions. This description is intended to allow\n/// efficient and straightforward typechecking, verification, and runtime\n/// execution.\nexport interface Program {\n\tfunctions: Record<string, IRFunction>,\n\tinterfaces: Record<string, IRInterface>,\n\trecords: Record<string, RecordDefinition>,\n\tenums: Record<string, EnumDefinition>,\n\n\tforeign: Record<string, FunctionSignature>,\n\n\tglobalVTableFactories: Record<string, VTableFactory>,\n};\n\nexport function opTerminates(op: Op) {\n\treturn op.tag === \"op-return\" || op.tag === \"op-unreachable\";\n}\n\nexport function equalTypes(pattern: Type, passed: Type): boolean {\n\tif (pattern.tag === \"type-variable\") {\n\t\t// TODO: Switch to unification?\n\t\treturn passed.tag === \"type-variable\" && passed.id === pattern.id;\n\t} else if (pattern.tag === \"type-compound\" && passed.tag === \"type-compound\") {\n\t\tif (pattern.base !== passed.base) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < pattern.type_arguments.length; i++) {\n\t\t\tif (!equalTypes(pattern.type_arguments[i], passed.type_arguments[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t} else if (pattern.tag === \"type-primitive\" && passed.tag === \"type-primitive\") {\n\t\treturn pattern.primitive === passed.primitive;\n\t}\n\n\treturn false;\n}\n\nfunction typeContainsVariable(\n\tt: Type,\n\tv: TypeVariableID,\n\tassignments: Map<TypeVariableID, Type | null>,\n): boolean {\n\tif (t.tag === \"type-compound\") {\n\t\tfor (const arg of t.type_arguments) {\n\t\t\tif (typeContainsVariable(arg, v, assignments)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t} else if (t.tag === \"type-primitive\") {\n\t\treturn false;\n\t} else if (t.tag === \"type-variable\") {\n\t\tif (t.id === v) {\n\t\t\treturn true;\n\t\t}\n\t\tconst assigned = assignments.get(t.id);\n\t\tif (assigned !== null && assigned !== undefined) {\n\t\t\treturn typeContainsVariable(assigned, v, assignments);\n\t\t}\n\t\treturn false;\n\t} else if (t.tag === \"type-any\") {\n\t\treturn false;\n\t}\n\n\tconst _: never = t;\n\tthrow new Error(\"typeContainsVariable: unreachable `\" + t[\"tag\"] + \"`\");\n}\n\nfunction unifyTypeArrayHelper(\n\tlefts: Type[],\n\trights: Type[],\n\tassignments: Map<TypeVariableID, Type | null>,\n): Map<TypeVariableID, Type | null> | null {\n\tfor (let i = 0; i < lefts.length; i++) {\n\t\tif (unifyTypePairHelper(lefts[i], rights[i], assignments) === null) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn assignments;\n}\n\nfunction unifyTypePairHelper(\n\tleft: Type,\n\tright: Type,\n\tassignments: Map<TypeVariableID, Type | null>,\n): Map<TypeVariableID, Type | null> | null {\n\tif (left.tag === \"type-variable\") {\n\t\tconst mapping = assignments.get(left.id);\n\t\tif (mapping === null) {\n\t\t\tif (typeContainsVariable(right, left.id, assignments)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tassignments.set(left.id, right);\n\t\t\treturn assignments;\n\t\t} else if (mapping !== undefined) {\n\t\t\treturn unifyTypePairHelper(mapping, right, assignments);\n\t\t}\n\t}\n\tif (right.tag === \"type-variable\") {\n\t\tconst mapping = assignments.get(right.id);\n\t\tif (mapping === null) {\n\t\t\tif (typeContainsVariable(left, right.id, assignments)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tassignments.set(right.id, left);\n\t\t\treturn assignments;\n\t\t} else if (mapping !== undefined) {\n\t\t\treturn unifyTypePairHelper(left, mapping, assignments);\n\t\t}\n\t}\n\n\tif (left.tag === \"type-compound\") {\n\t\tif (right.tag !== \"type-compound\") {\n\t\t\treturn null;\n\t\t} else if (left.base !== right.base) {\n\t\t\treturn null;\n\t\t}\n\t\treturn unifyTypeArrayHelper(left.type_arguments, right.type_arguments, assignments);\n\t} else if (left.tag === \"type-primitive\") {\n\t\tif (right.tag !== \"type-primitive\") {\n\t\t\treturn null;\n\t\t}\n\t\treturn left.primitive !== right.primitive ? null : assignments;\n\t} else if (left.tag === \"type-variable\") {\n\t\tif (right.tag !== \"type-variable\") {\n\t\t\treturn null;\n\t\t}\n\t\treturn left.id !== right.id ? null : assignments;\n\t} else if (left.tag === \"type-any\") {\n\t\tif (right.tag !== \"type-any\") {\n\t\t\treturn null;\n\t\t}\n\t\treturn assignments;\n\t}\n\n\tconst _: never = left;\n\tthrow new Error(\"unifyTypesHelper: unreachable `\" + left[\"tag\"] + \"`\");\n}\n\nexport interface UnificationResult {\n\tleftRenaming: Map<TypeVariableID, TypeVariable>,\n\trightRenaming: Map<TypeVariableID, TypeVariable>,\n\n\t/// A `null` instantiation is \"free\".\n\t/// Instantiations may reference other type-variables, but these references\n\t/// will not be cyclic.\n\tinstantiations: Map<TypeVariableID, Type | null>,\n}\n\n/// RETURNS the most-general unification of the two types.\nexport function unifyTypes(\n\tleftVars: TypeVariableID[],\n\tlefts: Type[],\n\trightVars: TypeVariableID[],\n\trights: Type[],\n): UnificationResult | null {\n\tconst assignments = new Map<TypeVariableID, Type | null>();\n\n\t// Rename variables so that they are distinct.\n\tconst leftRenaming = new Map<TypeVariableID, TypeVariable>();\n\tfor (const leftVar of leftVars) {\n\t\tconst id = \"unify_\" + leftVar + Math.random() as TypeVariableID;\n\t\tassignments.set(id, null);\n\t\tleftRenaming.set(leftVar, { tag: \"type-variable\", id });\n\t}\n\n\tconst rightRenaming = new Map<TypeVariableID, TypeVariable>();\n\tfor (const rightVar of rightVars) {\n\t\tconst id = \"unify_\" + rightVar + Math.random() as TypeVariableID;\n\t\tassignments.set(id, null);\n\t\trightRenaming.set(rightVar, { tag: \"type-variable\", id });\n\t}\n\n\tlefts = lefts.map(t => typeSubstitute(t, leftRenaming));\n\trights = rights.map(t => typeSubstitute(t, rightRenaming));\n\n\tconst out = unifyTypeArrayHelper(lefts, rights, assignments);\n\tif (out === null) {\n\t\treturn null;\n\t}\n\treturn {\n\t\tleftRenaming,\n\t\trightRenaming,\n\t\tinstantiations: assignments,\n\t};\n}\n\nexport function typeArgumentsMap(\n\tparameters: TypeVariableID[],\n\targs: Type[],\n): Map<TypeVariableID, Type> {\n\tif (parameters.length !== args.length) {\n\t\tthrow new Error(\"typeArgumentsMap: length mismatch\");\n\t}\n\tconst map: Map<TypeVariableID, Type> = new Map();\n\tfor (let i = 0; i < parameters.length; i++) {\n\t\tmap.set(parameters[i], args[i]);\n\t}\n\treturn map;\n}\n\nexport function typeSubstitute(t: Type, map: Map<TypeVariableID, Type>): Type {\n\tif (t.tag === \"type-compound\") {\n\t\treturn {\n\t\t\ttag: t.tag,\n\t\t\tbase: t.base,\n\t\t\ttype_arguments: t.type_arguments.map(a => typeSubstitute(a, map)),\n\t\t};\n\t} else if (t.tag === \"type-primitive\") {\n\t\treturn t;\n\t} else if (t.tag === \"type-variable\") {\n\t\tconst existing = map.get(t.id);\n\t\tif (existing !== undefined) {\n\t\t\treturn existing;\n\t\t}\n\t\treturn t;\n\t} else if (t.tag === \"type-any\") {\n\t\treturn t;\n\t}\n\n\tconst _: never = t;\n\tthrow new Error(`unhandled type tag \\`${t}\\`.`);\n}\n\nexport function typeRecursiveSubstitute(t: Type, map: Map<TypeVariableID, Type | null>): Type {\n\tif (t.tag === \"type-variable\") {\n\t\tconst e = map.get(t.id);\n\t\tif (e === undefined) {\n\t\t\treturn t;\n\t\t} else if (e === null) {\n\t\t\treturn t;\n\t\t} else {\n\t\t\tconst r = typeRecursiveSubstitute(e, map);\n\t\t\tmap.set(t.id, r);\n\t\t\treturn r;\n\t\t}\n\t} else if (t.tag === \"type-compound\") {\n\t\treturn {\n\t\t\ttag: t.tag,\n\t\t\tbase: t.base,\n\t\t\ttype_arguments: t.type_arguments.map(a => typeRecursiveSubstitute(a, map)),\n\t\t};\n\t} else if (t.tag === \"type-primitive\") {\n\t\treturn t;\n\t} else if (t.tag === \"type-any\") {\n\t\treturn t;\n\t}\n\n\tconst _: never = t;\n\tthrow new Error(`unhandled type tag \\`${t[\"tag\"]}\\`.`);\n}\n\nexport function constraintSubstitute(\n\tc: ConstraintParameter,\n\tmap: Map<TypeVariableID, Type>,\n): ConstraintParameter {\n\treturn {\n\t\tinterface: c.interface,\n\t\tsubjects: c.subjects.map(x => typeSubstitute(x, map)),\n\t};\n}\n","import { SourceLocation } from \"./ir\";\n\nexport type ErrorElement = string | SourceLocation;\n\nexport interface IdenToken {\n\ttag: \"iden\",\n\tname: string,\n\tlocation: SourceLocation,\n};\n\nexport interface TypeIdenToken {\n\ttag: \"type-iden\",\n\tname: string,\n\tlocation: SourceLocation,\n};\n\nexport interface TypeKeywordToken {\n\ttag: \"type-keyword\",\n\tkeyword: keyof typeof TYPE_KEYWORDS,\n\tlocation: SourceLocation,\n};\n\nexport interface KeywordToken {\n\ttag: \"keyword\",\n\tkeyword: keyof typeof KEYWORDS,\n\tlocation: SourceLocation,\n};\n\nexport interface TypeVarToken {\n\ttag: \"type-var\",\n\t// N.B.: This does NOT include the \"#\".\n\tname: string,\n\tlocation: SourceLocation,\n};\n\nexport interface StringLiteralToken {\n\ttag: \"string-literal\",\n\t// TODO: Encoding?\n\tvalue: string,\n\tlocation: SourceLocation,\n}\n\nexport interface NumberLiteralToken {\n\ttag: \"number-literal\",\n\t/// `int` is encoded as ASCII digits.\n\tint: string,\n\tlocation: SourceLocation,\n}\n\nexport interface PunctuationToken {\n\ttag: \"punctuation\",\n\tsymbol: keyof typeof PUNCTUATION,\n\tlocation: SourceLocation,\n}\n\nexport interface OperatorToken {\n\ttag: \"operator\",\n\toperator: keyof typeof OPERATORS,\n\tlocation: SourceLocation,\n}\n\nexport interface EOFToken {\n\ttag: \"eof\",\n\tlocation: SourceLocation,\n}\n\n// These keywords are reserved, but unused. Using them in a program is a syntax\n// error.\nexport const RESERVED = {\n\t\"Never\": true,\n\n\t\"async\": true,\n\t\"await\": true,\n\t\"break\": true,\n\t\"enum\": true,\n\t\"for\": true,\n\t\"function\": true,\n\t\"of\": true,\n\t\"record\": true,\n\t\"resource\": true,\n\t\"resume\": true,\n\t\"service\": true,\n\t\"test\": true,\n\t\"type\": true,\n\t\"until\": true,\n\t\"while\": true,\n\t\"yield\": true,\n};\n\nexport const TYPE_KEYWORDS = {\n\t\"Any\": true,\n\t\"Unit\": true,\n\t\"Boolean\": true,\n\t\"Int\": true,\n\t\"String\": true,\n\t\"This\": true,\n};\n\nexport const KEYWORDS = {\n\t\"and\": true,\n\t\"any\": true,\n\t\"assert\": true,\n\t\"case\": true,\n\t\"class\": true,\n\t\"do\": true,\n\t\"else\": true,\n\t\"elseif\": true,\n\t\"ensures\": true,\n\t\"enum\": true,\n\t\"false\": true,\n\t\"fn\": true,\n\t\"forall\": true,\n\t\"foreign\": true,\n\t\"if\": true,\n\t\"impl\": true,\n\t\"import\": true,\n\t\"implies\": true,\n\t\"interface\": true,\n\t\"is\": true,\n\t\"isa\": true,\n\t\"match\": true,\n\t\"method\": true,\n\t\"new\": true,\n\t\"not\": true,\n\t\"or\": true,\n\t\"package\": true,\n\t\"proof\": true,\n\t\"record\": true,\n\t\"requires\": true,\n\t\"return\": true,\n\t\"this\": true,\n\t\"true\": true,\n\t\"union\": true,\n\t\"unit\": true,\n\t\"unreachable\": true,\n\t\"var\": true,\n\t\"when\": true,\n};\n\nexport const OPERATORS = {\n\t// N.B.: Iteration order determines 'priority', so longer sequences MUST\n\t// come first.\n\t// N.B.: Sequences must NOT contain `//`, so that they remain comments.\n\n\t\"==\": true,\n\t\"!=\": true,\n\t\"<=\": true,\n\t\">=\": true,\n\t\"++\": true,\n\n\t\"+\": true,\n\t\"-\": true,\n\t\"/\": true,\n\t\"*\": true,\n\t\"%\": true,\n\t\"<\": true,\n\t\">\": true,\n};\n\nexport const PUNCTUATION = {\n\t\"=\": true,\n\t\"(\": true,\n\t\")\": true,\n\t\"{\": true,\n\t\"}\": true,\n\t\"[\": true,\n\t\"]\": true,\n\t\"|\": true,\n\t\".\": true,\n\t\",\": true,\n\t\":\": true,\n\t\";\": true,\n};\n\nexport type Token = IdenToken | TypeIdenToken | TypeVarToken\n\t| KeywordToken | TypeKeywordToken\n\t| StringLiteralToken | NumberLiteralToken\n\t| PunctuationToken | OperatorToken\n\t| EOFToken;\n\n/// THROWS LexError\nexport function tokenize(blob: string, fileID: string): Token[] {\n\tlet tokens: Token[] = [];\n\tlet from = 0;\n\twhile (from < blob.length) {\n\t\tconst result = parseToken(blob, from, fileID);\n\t\tif (result.token !== null) {\n\t\t\ttokens.push(result.token);\n\t\t}\n\t\tfrom += result.consumed;\n\t}\n\ttokens.push({\n\t\ttag: \"eof\",\n\t\tlocation: { fileID, offset: blob.length, length: 0 },\n\t});\n\treturn tokens;\n}\n\n/// THROWS LexError\nfunction parseToken(blob: string, from: number, fileID: string): { token: Token | null, consumed: number } {\n\tconst head = blob[from];\n\tif (head === \" \" || head === \"\\n\" || head == \"\\t\" || head == \"\\r\") {\n\t\treturn { token: null, consumed: 1 };\n\t} else if (\"a\" <= head && head <= \"z\") {\n\t\t// Parse an identifier or a keyword.\n\t\tconst breaks = findWordBreak(blob, from, fileID);\n\t\tconst location = {\n\t\t\tfileID,\n\t\t\toffset: from,\n\t\t\tlength: breaks - from,\n\t\t};\n\t\tconst word = blob.substring(from, breaks);\n\t\tif (word in KEYWORDS) {\n\t\t\treturn {\n\t\t\t\ttoken: {\n\t\t\t\t\ttag: \"keyword\",\n\t\t\t\t\tkeyword: word as keyof typeof KEYWORDS,\n\t\t\t\t\tlocation,\n\t\t\t\t},\n\t\t\t\tconsumed: breaks - from,\n\t\t\t};\n\t\t} else if (word in RESERVED) {\n\t\t\tthrow new LexError([\n\t\t\t\t\"Found the reserved term `\" + word + \"` at\",\n\t\t\t\tlocation,\n\t\t\t]);\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttoken: {\n\t\t\t\t\ttag: \"iden\",\n\t\t\t\t\tname: word,\n\t\t\t\t\tlocation,\n\t\t\t\t},\n\t\t\t\tconsumed: breaks - from,\n\t\t\t};\n\t\t}\n\t} else if (\"A\" <= head && head <= \"Z\") {\n\t\t// Parse a type-identifier or a type keyword.\n\t\tconst breaks = findWordBreak(blob, from, fileID);\n\t\tconst location = {\n\t\t\tfileID,\n\t\t\toffset: from,\n\t\t\tlength: breaks - from,\n\t\t};\n\t\tconst word = blob.substring(from, breaks);\n\t\tif (word in TYPE_KEYWORDS) {\n\t\t\treturn {\n\t\t\t\ttoken: {\n\t\t\t\t\ttag: \"type-keyword\",\n\t\t\t\t\tkeyword: word as keyof typeof TYPE_KEYWORDS,\n\t\t\t\t\tlocation,\n\t\t\t\t},\n\t\t\t\tconsumed: breaks - from,\n\t\t\t};\n\t\t} else if (word in RESERVED) {\n\t\t\tthrow new LexError([\n\t\t\t\t\"Found the reserved term `\" + word + \"` at\",\n\t\t\t\tlocation,\n\t\t\t]);\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttoken: {\n\t\t\t\t\ttag: \"type-iden\",\n\t\t\t\t\tname: word,\n\t\t\t\t\tlocation,\n\t\t\t\t},\n\t\t\t\tconsumed: breaks - from,\n\t\t\t};\n\t\t}\n\t} else if (head === \"/\" && blob[from + 1] === \"/\") {\n\t\t// Parse a line comment.\n\t\tlet lineBreak = blob.indexOf(\"\\n\", from);\n\t\tif (lineBreak < 0) {\n\t\t\tlineBreak = blob.length;\n\t\t}\n\t\treturn { token: null, consumed: lineBreak - from };\n\t} else if (\"0\" <= head && head <= \"9\") {\n\t\t// Parse a number literal.\n\t\tconst breaks = findWordBreak(blob, from, fileID);\n\t\tconst location = {\n\t\t\tfileID, offset: from, length: breaks - from,\n\t\t};\n\n\t\tconst slice = blob.substr(from, breaks - from);\n\t\tif (!/^[0-9]+$/.test(blob.substr(from, breaks - from)) || slice.length > 10) {\n\t\t\tthrow new LexError([\n\t\t\t\t\"Found a malformed integer literal at\",\n\t\t\t\tlocation,\n\t\t\t]);\n\t\t}\n\n\t\treturn {\n\t\t\ttoken: {\n\t\t\t\ttag: \"number-literal\",\n\t\t\t\tint: slice,\n\t\t\t\tlocation,\n\t\t\t},\n\t\t\tconsumed: breaks - from,\n\t\t};\n\t} else if (head === \"#\") {\n\t\t// Parse a type variable or keyword.\n\t\tconst first = blob[from + 1];\n\t\tif (!(\"A\" <= first && first <= \"Z\")) {\n\t\t\tconst location = {\n\t\t\t\tfileID,\n\t\t\t\toffset: from,\n\t\t\t\tlength: 2,\n\t\t\t};\n\t\t\tthrow new LexError([\n\t\t\t\t\"Expected a capital letter after `#` at\",\n\t\t\t\tlocation\n\t\t\t]);\n\t\t}\n\n\t\tconst breaks = findWordBreak(blob, from + 1, fileID);\n\t\tconst location = {\n\t\t\tfileID,\n\t\t\toffset: from,\n\t\t\tlength: breaks - from,\n\t\t};\n\t\treturn {\n\t\t\ttoken: {\n\t\t\t\ttag: \"type-var\",\n\t\t\t\tname: blob.substring(from + 1, breaks),\n\t\t\t\tlocation,\n\t\t\t},\n\t\t\tconsumed: breaks - from,\n\t\t};\n\t} else if (head === \"\\\"\") {\n\t\t// Parse a string literal.\n\t\tlet content = \"\";\n\t\tlet escaped = false;\n\t\tlet end = null;\n\t\tfor (let i = from + 1; i < blob.length; i++) {\n\t\t\tconst at = blob[i];\n\t\t\tif (at === \"\\n\") {\n\t\t\t\tthrow new LexError([\n\t\t\t\t\t\"Found string literal interrupted by newline at\",\n\t\t\t\t\t{\n\t\t\t\t\t\tfileID,\n\t\t\t\t\t\toffset: from,\n\t\t\t\t\t\tlength: i - from,\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t} else if (at === \"\\r\") {\n\t\t\t\tthrow new LexError([\n\t\t\t\t\t\"Found string literal interrupted by carriage return at\",\n\t\t\t\t\t{\n\t\t\t\t\t\tfileID,\n\t\t\t\t\t\toffset: from,\n\t\t\t\t\t\tlength: i - from,\n\t\t\t\t\t},\n\t\t\t\t]);\n\t\t\t} else if (escaped) {\n\t\t\t\tif (at === \"n\") {\n\t\t\t\t\tcontent += \"\\n\";\n\t\t\t\t} else if (at === \"r\") {\n\t\t\t\t\tcontent += \"\\r\";\n\t\t\t\t} else if (at === \"t\") {\n\t\t\t\t\tcontent += \"\\t\";\n\t\t\t\t} else if (at === \"\\\"\") {\n\t\t\t\t\tcontent += \"\\\"\";\n\t\t\t\t} else if (at === \"\\\\\") {\n\t\t\t\t\tcontent += \"\\\\\";\n\t\t\t\t} else {\n\t\t\t\t\tthrow new LexError([\n\t\t\t\t\t\t\"Found invalid escape in string literal at\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfileID,\n\t\t\t\t\t\t\toffset: i - 1,\n\t\t\t\t\t\t\tlength: 2,\n\t\t\t\t\t\t},\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t\tescaped = false;\n\t\t\t\tcontinue;\n\t\t\t} else if (at === \"\\\\\") {\n\t\t\t\tescaped = true;\n\t\t\t} else if (at === \"\\\"\") {\n\t\t\t\tend = i + 1;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tcontent += at;\n\t\t\t}\n\t\t}\n\n\t\tif (end === null) {\n\t\t\tthrow new LexError([\n\t\t\t\t\"Found unfinished string literal at\",\n\t\t\t\t{\n\t\t\t\t\tfileID,\n\t\t\t\t\toffset: from,\n\t\t\t\t\tlength: blob.length - from,\n\t\t\t\t},\n\t\t\t]);\n\t\t}\n\t\treturn {\n\t\t\ttoken: {\n\t\t\t\ttag: \"string-literal\",\n\t\t\t\tvalue: content,\n\t\t\t\tlocation: {\n\t\t\t\t\tfileID,\n\t\t\t\t\toffset: from,\n\t\t\t\t\tlength: end - from,\n\t\t\t\t},\n\t\t\t},\n\t\t\tconsumed: end - from,\n\t\t};\n\t} else {\n\t\t// Attempt to parse punctuations.\n\t\tfor (let k = Math.min(blob.length - from, 2); k >= 1; k--) {\n\t\t\tconst lexeme = blob.substr(from, k);\n\t\t\tif (lexeme in PUNCTUATION) {\n\t\t\t\treturn {\n\t\t\t\t\ttoken: {\n\t\t\t\t\t\ttag: \"punctuation\",\n\t\t\t\t\t\tsymbol: lexeme as keyof typeof PUNCTUATION,\n\t\t\t\t\t\tlocation: {\n\t\t\t\t\t\t\tfileID,\n\t\t\t\t\t\t\toffset: from,\n\t\t\t\t\t\t\tlength: k,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tconsumed: k,\n\t\t\t\t};\n\t\t\t} else if (lexeme in OPERATORS) {\n\t\t\t\treturn {\n\t\t\t\t\ttoken: {\n\t\t\t\t\t\ttag: \"operator\",\n\t\t\t\t\t\toperator: lexeme as keyof typeof OPERATORS,\n\t\t\t\t\t\tlocation: {\n\t\t\t\t\t\t\tfileID,\n\t\t\t\t\t\t\toffset: from,\n\t\t\t\t\t\t\tlength: k,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tconsumed: k,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\tconst location: SourceLocation = {\n\t\tfileID,\n\t\toffset: from,\n\t\tlength: 1,\n\t};\n\tthrow new LexError([\"Found an unexpected symbol at\", location]);\n}\n\n/// RETURNS the first index after from which is not a letter/number/underscore\n/// that is valid within Shiru identifiers.\nfunction findWordBreak(blob: string, from: number, fileID: string) {\n\tlet end = blob.length;\n\tfor (let i = from + 1; i < blob.length; i++) {\n\t\tconst c = blob[i];\n\t\tconst lower = \"a\" <= c && c <= \"z\";\n\t\tconst upper = \"A\" <= c && c <= \"Z\";\n\t\tconst digit = \"0\" <= c && c <= \"9\";\n\t\tconst under = c === \"_\";\n\t\tif (!lower && !upper && !digit && !under) {\n\t\t\tend = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tconst doubleUnder = blob.substring(from, end).indexOf(\"__\", from);\n\tif (doubleUnder >= 0) {\n\t\tthrow new LexError([\n\t\t\t\"Found invalid double underscore in identifier at\",\n\t\t\t{\n\t\t\t\tfileID,\n\t\t\t\toffset: from + doubleUnder,\n\t\t\t\tlength: 2,\n\t\t\t},\n\t\t]);\n\t}\n\treturn end;\n}\n\nexport class LexError {\n\tconstructor(public message: ErrorElement[]) { }\n\n\ttoString() {\n\t\treturn JSON.stringify(this.message);\n\t}\n}\n","import { SourceLocation } from \"./ir\";\nimport { ErrorElement } from \"./lexer\";\n\nfunction pluralize(n: number, singular: string, plural = singular + \"s\"): string {\n\tif (n === 1) {\n\t\treturn singular;\n\t}\n\treturn plural;\n}\n\nfunction nth(n: number): string {\n\tif (n % 100 == 11) {\n\t\treturn n + \"th\";\n\t} else if (n % 100 == 12) {\n\t\treturn n + \"th\";\n\t} else if (n % 100 == 13) {\n\t\treturn n + \"th\";\n\t} else if (n % 10 == 1) {\n\t\treturn n + \"st\";\n\t} else if (n % 10 == 2) {\n\t\treturn n + \"nd\";\n\t} else if (n % 10 == 3) {\n\t\treturn n + \"rd\";\n\t}\n\treturn n + \"th\";\n}\n\nexport class SemanticError {\n\tconstructor(public message: ErrorElement[]) { }\n\n\ttoString() {\n\t\treturn JSON.stringify(this.message);\n\t}\n}\n\nexport class EntityRedefinedErr extends SemanticError {\n\tconstructor(args: { name: string, firstBinding: SourceLocation, secondBinding: SourceLocation }) {\n\t\tsuper([\n\t\t\t\"Entity `\" + args.name + \"` was defined for a second time at\",\n\t\t\targs.secondBinding,\n\t\t\t\"The first definition was at\",\n\t\t\targs.firstBinding,\n\t\t]);\n\t}\n}\n\nexport class NoSuchPackageErr extends SemanticError {\n\tconstructor(args: { packageName: string, reference: SourceLocation }) {\n\t\tsuper([\n\t\t\t\"Package `\" + args.packageName + \"` has not been defined, but it was reference at\",\n\t\t\targs.reference,\n\t\t]);\n\t}\n}\n\nexport class NoSuchEntityErr extends SemanticError {\n\tconstructor(args: { entityName: string, reference: SourceLocation }) {\n\t\tsuper([\n\t\t\t\"Entity `\" + args.entityName + \"` has not been defined, but it was referenced at\",\n\t\t\targs.reference,\n\t\t]);\n\t}\n}\n\nexport class NamespaceAlreadyDefinedErr extends SemanticError {\n\tconstructor(args: { namespace: string, firstBinding: SourceLocation, secondBinding: SourceLocation }) {\n\t\tsuper([\n\t\t\t\"The namespace `\" + args.namespace + \"` was defined for a second time at\",\n\t\t\targs.secondBinding,\n\t\t\t\"The first definition was at\",\n\t\t\targs.firstBinding,\n\t\t]);\n\t}\n}\n\nexport class InvalidThisTypeErr extends SemanticError {\n\tconstructor(args: { referenced: SourceLocation }) {\n\t\tsuper([\n\t\t\t\"The keyword `This` cannot be used at\", args.referenced\n\t\t]);\n\t}\n}\n\nexport class MemberRedefinedErr extends SemanticError {\n\tconstructor(args: {\n\t\tmemberName: string,\n\t\tsecondBinding: SourceLocation,\n\t\tfirstBinding: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The member `\" + args.memberName + \"` was defined for a second time at\",\n\t\t\targs.secondBinding,\n\t\t\t\"The first definition of `\" + args.memberName + \"` was at\",\n\t\t\targs.firstBinding,\n\t\t]);\n\t}\n}\n\nexport class TypeVariableRedefinedErr extends SemanticError {\n\tconstructor(args: { typeVariableName: string, firstBinding: SourceLocation, secondBinding: SourceLocation }) {\n\t\tsuper([\n\t\t\t\"The type variable `#\" + args.typeVariableName + \"` was defined for a second time at\",\n\t\t\targs.secondBinding,\n\t\t\t\"The first definition was at\",\n\t\t\targs.firstBinding,\n\t\t]);\n\t}\n}\n\nexport class NoSuchTypeVariableErr extends SemanticError {\n\tconstructor(args: { typeVariableName: string, location: SourceLocation }) {\n\t\tsuper([\n\t\t\t\"Type variable `#\" + args.typeVariableName + \"` has not been defined, but it was referenced at\",\n\t\t\targs.location,\n\t\t]);\n\t}\n}\n\nexport class NonTypeEntityUsedAsTypeErr extends SemanticError {\n\tconstructor(args: { entity: string, entityTag: \"interface\", entityBinding: SourceLocation, useLocation: SourceLocation }) {\n\t\tsuper([\n\t\t\t\"The entity `\" + args.entity + \"` cannot be used a type as was attempted at\",\n\t\t\targs.useLocation,\n\t\t\t\"because it was defined as a \" + args.entityTag + \" at\",\n\t\t\targs.entityBinding,\n\t\t]);\n\t}\n}\n\nexport class TypeUsedAsConstraintErr extends SemanticError {\n\tconstructor(args: {\n\t\tname?: string,\n\t\tkind: \"record\" | \"keyword\" | \"enum\",\n\t\ttypeLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\targs.name === undefined\n\t\t\t\t? \"A \" + args.kind + \" type \"\n\t\t\t\t: \"The \" + args.kind + \" type `\" + args.name + \"` \",\n\t\t\t\"cannot be used as a constraint like it is at\",\n\t\t\targs.typeLocation,\n\t\t]);\n\t}\n}\n\nexport class VariableRedefinedErr extends SemanticError {\n\tconstructor(args: { name: string, firstLocation: SourceLocation, secondLocation: SourceLocation }) {\n\t\tsuper([\n\t\t\t\"The variable `\" + args.name + \"` was defined for a second time at\",\n\t\t\targs.secondLocation,\n\t\t\t\"The first definition was at\",\n\t\t\targs.firstLocation,\n\t\t]);\n\t}\n}\n\nexport class VariableNotDefinedErr extends SemanticError {\n\tconstructor(args: { name: string, referencedAt: SourceLocation }) {\n\t\tsuper([\n\t\t\t\"The variable `\" + args.name + \"` has not been defined, but it was referenced at\",\n\t\t\targs.referencedAt,\n\t\t]);\n\t}\n}\n\nexport class MultiExpressionGroupedErr extends SemanticError {\n\tconstructor(args: {\n\t\tlocation: SourceLocation,\n\t\tvalueCount: number,\n\t\tgrouping: \"parens\" | \"field\" | \"field-init\" | \"method\" | \"if\" | \"op\" | \"contract\" | \"is\",\n\t\top?: string,\n\t}) {\n\t\tconst by = {\n\t\t\tparens: \"parenthesization\",\n\t\t\tfield: \"a field access\",\n\t\t\tmethod: \"a method access\",\n\t\t\tif: \"an `if` condition\",\n\t\t\tis: \"an `is` test\",\n\t\t\top: \"a `\" + args.op + \"` operation\",\n\t\t\tcontract: \"a `\" + args.op + \"` contract\",\n\t\t\t\"field-init\": \"a field initialization\",\n\t\t};\n\t\tsuper([\n\t\t\t\"An expression has \" + args.valueCount + \" values and so cannot be grouped \",\n\t\t\t\"by \" + by[args.grouping] + \" at\",\n\t\t\targs.location,\n\t\t]);\n\t}\n}\n\nexport class ValueCountMismatchErr extends SemanticError {\n\tconstructor(args: { actualCount: number, actualLocation: SourceLocation, expectedCount: number, expectedLocation: SourceLocation }) {\n\t\tsuper([\n\t\t\t\"An expression has \" + args.actualCount + \" \" + pluralize(args.actualCount, \"value\") + \" at\",\n\t\t\targs.actualLocation,\n\t\t\t\"but \" + args.expectedCount + \" \" + pluralize(args.expectedCount, \"value was\", \"values were\") + \" expected at\",\n\t\t\targs.expectedLocation,\n\t\t]);\n\t}\n}\n\nexport class TypeMismatchErr extends SemanticError {\n\tconstructor(args: {\n\t\tgivenType: string,\n\t\tgivenLocation: SourceLocation,\n\t\tgivenIndex?: { index0: number, count: number },\n\t\texpectedType: string,\n\t\texpectedLocation: SourceLocation,\n\t}) {\n\t\tconst value = args.givenIndex && args.givenIndex.count !== 1\n\t\t\t? `${nth(args.givenIndex.count + 1)} value (of ${args.givenIndex.count})`\n\t\t\t: \"value\";\n\t\tsuper([\n\t\t\t\"A \" + value + \" with type `\" + args.givenType + \"` at\",\n\t\t\targs.givenLocation,\n\t\t\t\"cannot be converted to the type `\" + args.expectedType + \"` as expected at\",\n\t\t\targs.expectedLocation,\n\t\t]);\n\t}\n}\n\nexport class ImplParameterCountMismatch extends SemanticError {\n\tconstructor(args: {\n\t\timpl: string,\n\t\tmember: string,\n\t\timplCount: number,\n\t\tinterfaceCount: number,\n\t\timplLocation: SourceLocation,\n\t\tinterfaceLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The impl member `\" + args.member + \"` has \",\n\t\t\targs.implCount + \" \" + pluralize(args.implCount, \"parameter\") + \" at\",\n\t\t\targs.implLocation,\n\t\t\t\"However, `\" + args.impl + \"` needs \" + args.interfaceCount + \", as defined at\",\n\t\t\targs.interfaceLocation,\n\t\t]);\n\t}\n}\n\nexport class ImplReturnCountMismatch extends SemanticError {\n\tconstructor(args: {\n\t\timpl: string,\n\t\tmember: string,\n\t\timplCount: number,\n\t\tinterfaceCount: number,\n\t\timplLocation: SourceLocation,\n\t\tinterfaceLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The impl member `\" + args.member + \"` has \",\n\t\t\targs.implCount + \" \" + pluralize(args.implCount, \"return\") + \" at\",\n\t\t\targs.implLocation,\n\t\t\t\"However, `\" + args.impl + \"` needs \" + args.interfaceCount + \", as defined at\",\n\t\t\targs.interfaceLocation,\n\t\t]);\n\t}\n}\n\nexport class ImplParameterTypeMismatch extends SemanticError {\n\tconstructor(args: {\n\t\timpl: string,\n\t\tmemberName: string,\n\t\tparameterIndex0: number,\n\t\timplType: string,\n\t\tinterfaceType: string,\n\t\timplLocation: SourceLocation,\n\t\tinterfaceLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The type `\" + args.implType + \"` \",\n\t\t\t\"of the \" + nth(args.parameterIndex0 + 1) + \" parameter \",\n\t\t\t\"of the impl member `\" + args.memberName + \"` at\",\n\t\t\targs.implLocation,\n\t\t\t\"does not match the type `\" + args.interfaceType + \"` \",\n\t\t\t\"as required of a `\" + args.impl + \"` by the interface member defined at\",\n\t\t\targs.interfaceLocation,\n\t\t]);\n\t}\n}\n\nexport class ImplReturnTypeMismatch extends SemanticError {\n\tconstructor(args: {\n\t\timpl: string,\n\t\tmemberName: string,\n\t\treturnIndex0: number,\n\t\timplType: string,\n\t\tinterfaceType: string,\n\t\timplLocation: SourceLocation,\n\t\tinterfaceLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The type `\" + args.implType + \"` \",\n\t\t\t\"of the \" + nth(args.returnIndex0 + 1) + \" return \",\n\t\t\t\"of the impl member `\" + args.memberName + \"` at\",\n\t\t\targs.implLocation,\n\t\t\t\"does not match the required type `\" + args.interfaceType + \"` \",\n\t\t\t\"as required of a `\" + args.impl + \"` by the interface member defined at\",\n\t\t\targs.interfaceLocation,\n\t\t]);\n\t}\n}\n\nexport class FieldAccessOnNonCompoundErr extends SemanticError {\n\tconstructor(args: {\n\t\taccessedType: string,\n\t\taccessedLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The type `\" + args.accessedType + \"` is not a compound type so a field access is illegal at\",\n\t\t\targs.accessedLocation,\n\t\t]);\n\t}\n}\n\nexport class VariantTestOnNonEnumErr extends SemanticError {\n\tconstructor(args: {\n\t\ttestedType: string,\n\t\ttestLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The type `\" + args.testedType + \"` is not an enum type, \",\n\t\t\t\"so the `is` test is illegal at\",\n\t\t\targs.testLocation,\n\t\t]);\n\t}\n}\n\nexport class MethodAccessOnNonCompoundErr extends SemanticError {\n\tconstructor(args: {\n\t\taccessedType: string,\n\t\taccessedLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The type `\" + args.accessedType + \"` is not a compound type, so a method access is illegal at\",\n\t\t\targs.accessedLocation,\n\t\t]);\n\t}\n}\n\nexport class BooleanTypeExpectedErr extends SemanticError {\n\tconstructor(args: { givenType: string, location: SourceLocation } & (\n\t\t{ reason: \"if\" }\n\t\t| { reason: \"logical-op\", op: string, opLocation: SourceLocation }\n\t\t| { reason: \"contract\", contract: \"requires\" | \"ensures\" | \"assert\" })\n\t) {\n\t\tif (args.reason === \"if\") {\n\t\t\tsuper([\n\t\t\t\t\"A condition expression with type `\" + args.givenType + \"` at\",\n\t\t\t\targs.location,\n\t\t\t\t\"cannot be converted to the type `Boolean` as required of \",\n\t\t\t\t\"`if` conditions.\"\n\t\t\t]);\n\t\t} else if (args.reason === \"contract\") {\n\t\t\tsuper([\n\t\t\t\t\"A contract expression with type `\" + args.givenType + \"` at\",\n\t\t\t\targs.location,\n\t\t\t\t\"cannot be converted to the type `Boolean` as required of \",\n\t\t\t\t\"`\" + args.contract + \"` conditions.\"\n\t\t\t]);\n\t\t} else {\n\t\t\tsuper([\n\t\t\t\t\"An expression with type `\" + args.givenType + \"` at\",\n\t\t\t\targs.location,\n\t\t\t\t\"cannot be converted to the type `Boolean` as required \",\n\t\t\t\t\"by the `\" + args.op + \"` operator at\",\n\t\t\t\targs.opLocation,\n\t\t\t]);\n\t\t}\n\t}\n}\n\nexport class TypeDoesNotProvideOperatorErr extends SemanticError {\n\tconstructor({ lhsType, operator, operatorLocation }: {\n\t\tlhsType: string,\n\t\toperatorLocation: SourceLocation,\n\t\toperator: string,\n\t}) {\n\t\tsuper([\n\t\t\t\"The type `\" + lhsType + \"` does not have an operator `\" + operator + \"`,\"\n\t\t\t+ \" so an operation is illegal at\",\n\t\t\toperatorLocation,\n\t\t]);\n\t}\n}\n\nexport class OperatorTypeMismatchErr extends SemanticError {\n\tconstructor(args: {\n\t\tlhsType: string,\n\t\toperator: string,\n\t\tgivenRhsType: string,\n\t\texpectedRhsType: string,\n\t\trhsLocation: SourceLocation\n\t}) {\n\t\tsuper([\n\t\t\t\"The operator `\" + args.operator + \"`\"\n\t\t\t+ \" with type `\" + args.lhsType\n\t\t\t+ \"` on the left side expects a value with type `\"\n\t\t\t+ args.expectedRhsType + \"` on the right side, but one of type `\"\n\t\t\t+ args.givenRhsType + \"` was given at\",\n\t\t\targs.rhsLocation\n\t\t]);\n\t}\n}\n\nexport class CallOnNonCompoundErr extends SemanticError {\n\tconstructor(args: {\n\t\tbaseType: string,\n\t\tlocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The type `\" + args.baseType + \"` does not have function members,\"\n\t\t\t+ \" so a function call is illegal at\",\n\t\t\targs.location,\n\t\t]);\n\t}\n}\n\nexport class NoSuchFnErr extends SemanticError {\n\tconstructor(args: {\n\t\tbaseType: string,\n\t\tmethodName: string,\n\t\tmethodNameLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The type `\" + args.baseType + \"` \",\n\t\t\t\"does not have a function member named `\" + args.methodName + \"` \",\n\t\t\t\"so the function call is illegal at\",\n\t\t\targs.methodNameLocation,\n\t\t]);\n\t}\n}\n\nexport class OperationRequiresParenthesizationErr extends SemanticError {\n\tconstructor(args: {\n\t\top1: { str: string, location: SourceLocation },\n\t\top2: { str: string, location: SourceLocation },\n\t\treason: \"unordered\" | \"non-associative\",\n\t}) {\n\t\tsuper([\n\t\t\t\"The operators `\" + args.op1.str + \"` and `\" + args.op2.str + \"` at\",\n\t\t\targs.op1.location,\n\t\t\t\"and at\",\n\t\t\targs.op2.location,\n\t\t\t\"have ambiguous precedence, and require parentheses to specify \"\n\t\t\t+ \"precedence.\"\n\t\t]);\n\t}\n}\n\nexport class RecursivePreconditionErr extends SemanticError {\n\tconstructor(args: {\n\t\tcallsite: SourceLocation,\n\t\tfn: string,\n\t}) {\n\t\tsuper([\n\t\t\t\"The function `\" + args.fn + \"` was recursively invoked in a\"\n\t\t\t+ \" `requires` clause at\",\n\t\t\targs.callsite,\n\t\t\t\"Try moving this reference to an `ensures` clause.\",\n\t\t]);\n\t}\n}\n\nexport class ReturnExpressionUsedOutsideEnsuresErr extends SemanticError {\n\tconstructor(args: {\n\t\treturnLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"A `return` expression cannot be used outside an `ensures`\"\n\t\t\t+ \" clause like it is at\",\n\t\t\targs.returnLocation,\n\t\t]);\n\t}\n}\n\nexport class TypesDontSatisfyConstraintErr extends SemanticError {\n\tconstructor(args: {\n\t\t/// `neededConstraint` is a constraint-implementation in the form\n\t\t/// `\"X is Y[Z]\"`.\n\t\tneededConstraint: string,\n\t\tneededLocation: SourceLocation,\n\t\tconstraintLocation: SourceLocation | null,\n\t}) {\n\t\tconst arr = [\n\t\t\t\"There is no impl for `\" + args.neededConstraint + \"` at\",\n\t\t\targs.neededLocation,\n\t\t];\n\t\tif (args.constraintLocation !== null) {\n\t\t\tarr.push(\"This impl is required by the constraint at\",\n\t\t\t\targs.constraintLocation);\n\t\t}\n\t\tsuper(arr);\n\t}\n}\n\nexport class NonCompoundInRecordLiteralErr extends SemanticError {\n\tconstructor(args: {\n\t\tt: string,\n\t\tlocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The type `\" + args.t + \"` is not a record type, and\"\n\t\t\t+ \" cannot be used in a record-literal expression like it is at\",\n\t\t\targs.location,\n\t\t]);\n\t}\n}\n\nexport class MemberRepeatedInCompoundLiteralErr extends SemanticError {\n\tconstructor(args: {\n\t\tkind: \"field\" | \"variant\",\n\t\tfieldName: string,\n\t\tfirstLocation: SourceLocation,\n\t\tsecondLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The \" + args.kind + \" `\" + args.fieldName + \"` was initialized a second time at\",\n\t\t\targs.secondLocation,\n\t\t\t\"The first initialization was at\",\n\t\t\targs.firstLocation,\n\t\t]);\n\t}\n}\n\nexport class NoSuchFieldErr extends SemanticError {\n\tconstructor(args: {\n\t\trecordType: string,\n\t\tfieldName: string,\n\t\tlocation: SourceLocation,\n\t\tkind: \"access\" | \"initialization\",\n\t}) {\n\t\tsuper([\n\t\t\t\"The record type `\" + args.recordType\n\t\t\t+ \"` does not have a field called `\" + args.fieldName\n\t\t\t+ \"`, so the \" + args.kind + \" is illegal at\",\n\t\t\targs.location,\n\t\t]);\n\t}\n}\n\nexport class NoSuchVariantErr extends SemanticError {\n\tconstructor(args: {\n\t\tkind: \"is test\" | \"variant access\" | \"initialization\",\n\t\tenumType: string,\n\t\tvariantName: string,\n\t\tlocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The enum type `\" + args.enumType + \"` \",\n\t\t\t\"does not have a variant called `\" + args.variantName + \"`, \",\n\t\t\t\"so the \" + args.kind + \" is illegal at\",\n\t\t\targs.location,\n\t\t]);\n\t}\n}\n\nexport class UninitializedFieldErr extends SemanticError {\n\tconstructor(args: {\n\t\trecordType: string,\n\t\tmissingFieldName: string,\n\t\tdefinedLocation: SourceLocation,\n\t\tinitializerLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The initialization of type `\" + args.recordType + \"` \",\n\t\t\t\"is missing field `\" + args.missingFieldName + \"` at\",\n\t\t\targs.initializerLocation,\n\t\t\t\"The field `\" + args.missingFieldName + \"` is defined at\",\n\t\t\targs.definedLocation,\n\t\t]);\n\t}\n}\n\nexport class MultipleVariantsErr extends SemanticError {\n\tconstructor(args: {\n\t\tenumType: string,\n\t\tfirstVariant: string,\n\t\tfirstLocation: SourceLocation,\n\t\tsecondVariant: string,\n\t\tsecondLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The initialization of enum type `\" + args.enumType + \"` \",\n\t\t\t\"includes a second variant `\" + args.secondVariant + \"` at\",\n\t\t\targs.secondLocation,\n\t\t\t\"The first variant `\" + args.firstVariant + \"` is included at\",\n\t\t\targs.firstLocation,\n\t\t]);\n\t}\n}\n\nexport class EnumLiteralMissingVariantErr extends SemanticError {\n\tconstructor(args: {\n\t\tenumType: string,\n\t\tlocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The initialization of enum type `\" + args.enumType + \"` \",\n\t\t\t\"is missing a variant at\",\n\t\t\targs.location,\n\t\t]);\n\t}\n}\n\nexport class TypeParameterCountMismatchErr extends SemanticError {\n\tconstructor(args: {\n\t\tentityType: \"record\" | \"interface\",\n\t\tentityName: string,\n\t\texpectedCount: number,\n\t\texpectedLocation: SourceLocation,\n\t\tgivenCount: number,\n\t\tgivenLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The \" + args.entityType + \" `\" + args.entityName + \"` was given \",\n\t\t\targs.givenCount + \" \",\n\t\t\tpluralize(args.givenCount, \"type parameter\") + \" at\",\n\t\t\targs.givenLocation,\n\t\t\t\"but \" + args.expectedCount + \" \",\n\t\t\tpluralize(args.expectedCount, \"type parameter was \", \"type parameters were \"),\n\t\t\t\"expected at\",\n\t\t\targs.expectedLocation,\n\t\t]);\n\t}\n}\n\nexport class OverlappingImplsErr extends SemanticError {\n\tconstructor(args: {\n\t\tfirstImpl: string,\n\t\tfirstLocation: SourceLocation,\n\t\tsecondImpl: string,\n\t\tsecondLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The impl `\" + args.secondImpl + \"` given at\",\n\t\t\targs.secondLocation,\n\t\t\t\"conflicts with the impl `\" + args.firstImpl + \"` given at\",\n\t\t\targs.firstLocation,\n\t\t]);\n\t}\n}\n\nexport class ImplMemberDoesNotExistOnInterface extends SemanticError {\n\tconstructor(args: {\n\t\timpl: string,\n\t\tmember: string,\n\t\tmemberLocation: SourceLocation,\n\t\tinterface: string,\n\t\tinterfaceLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The impl `\" + args.impl + \"` \",\n\t\t\t\"defines a member `\" + args.member + \"` at\",\n\t\t\targs.memberLocation,\n\t\t\t\"However, the interface `\" + args.interface + \"` defined at\",\n\t\t\targs.interfaceLocation,\n\t\t\t\"does not have a member named `\" + args.member + \"`.\",\n\t\t]);\n\t}\n}\n\nexport class ImplMissingInterfaceMember extends SemanticError {\n\tconstructor(args: {\n\t\timpl: string,\n\t\tmember: string,\n\t\timplLocation: SourceLocation,\n\t\tinterface: string,\n\t\tmemberLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The impl `\" + args.impl + \"` \",\n\t\t\t\"is missing member `\" + args.member + \"` at\",\n\t\t\targs.implLocation,\n\t\t\t\"However, the interface `\" + args.interface + \"` requires a `\" + args.member + \"` member at\",\n\t\t\targs.memberLocation,\n\t\t]);\n\t}\n}\n\nexport class ImplMayNotHavePreconditionErr extends SemanticError {\n\tconstructor(args: {\n\t\timpl: string,\n\t\tmemberName: string,\n\t\tpreconditionLocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The member `\" + args.memberName + \"` of impl `\",\n\t\t\targs.impl + \"` declares an additional precondition at\",\n\t\t\targs.preconditionLocation,\n\t\t\t\"However, impls may not state additional preconditions; \",\n\t\t\t\"preconditions on the interface are automatically applied.\",\n\t\t]);\n\t}\n}\n\nexport class ProofMemberUsedOutsideProofContextErr extends SemanticError {\n\tconstructor(args: {\n\t\toperation: string,\n\t\tlocation: SourceLocation,\n\t}) {\n\t\tsuper([\n\t\t\t\"The operation `\" + args.operation + \"` \",\n\t\t\t\"cannot be used outside a proof context as it is at\",\n\t\t\targs.location,\n\t\t]);\n\t}\n}\n","/// `ParsersFor` is a utility type to make it easy to make a recursively defined\n/// \"grammar\" object type-safe.\nexport type ParsersFor<Token, ASTs> = {\n\t[P in keyof ASTs]: Parser<Token, ASTs[P]>\n};\n\n/// `TokenSpan` represents an contiguous range of tokens within a token stream.\nexport interface TokenSpan<Token> {\n\t/// The first Token in this span.\n\tfirst: Token,\n\n\t/// The Token which immediately follows this span.\n\tfollowing: Token,\n};\n\nexport type DebugContext<Token> = Record<string, TokenSpan<Token>>;\n\n/// The result of a parsing operation.\n/// `null` represents non-fatal failure to match.\n/// `ParseError` represents an illegal program fragment was detected while\n/// attempting to parse this object.\nexport type ParseResult<Result> = { object: Result, rest: number } | null;\n\n/// Parser represents a parser from a stream of `Token`s to a particular\n/// `Result` AST.\nexport abstract class Parser<Token, Result> {\n\tabstract parse(stream: Token[], from: number, debugContext: DebugContext<Token>): ParseResult<Result>;\n\n\tmap<Q>(f: (r: Result, stream: Token[], from: number) => Q): Parser<Token, Q> {\n\t\treturn new MapParser<Token, Result, Q>(this, f);\n\t}\n\n\trequired(f: FailHandler<Token, unknown>): Parser<Token, Result> {\n\t\treturn new ChoiceParser(() => [this, new FailParser(f)]);\n\t}\n\n\totherwise<Q>(q: Q): Parser<Token, Result | Q> {\n\t\treturn new ChoiceParser(() => [this, new ConstParser<Token, Result | Q>(q)]);\n\t}\n}\n\nexport class MapParser<T, A, B> extends Parser<T, B> {\n\tparser: Parser<T, A>;\n\tf: (a: A, stream: T[], from: number) => B;\n\n\tconstructor(parser: Parser<T, A>, f: (a: A, stream: T[], from: number) => B) {\n\t\tsuper();\n\t\tthis.parser = parser;\n\t\tthis.f = f;\n\t}\n\n\tparse(stream: T[], from: number, debugContext: DebugContext<T>): ParseResult<B> {\n\t\tconst result = this.parser.parse(stream, from, debugContext);\n\t\tif (result && \"object\" in result) {\n\t\t\tconst mapped = this.f(result.object, stream, from);\n\t\t\treturn { object: mapped, rest: result.rest };\n\t\t} else {\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\nexport class EndOfStreamParser<T> extends Parser<T, {}> {\n\tparse(stream: T[], from: number): { object: {}, rest: number } | null {\n\t\tif (from === stream.length) {\n\t\t\treturn { object: {}, rest: stream.length };\n\t\t}\n\t\treturn null;\n\t}\n}\n\nexport class ConstParser<T, R> extends Parser<T, R> {\n\tconstructor(private value: R) {\n\t\tsuper();\n\t}\n\n\tparse(stream: T[], from: number): { object: R, rest: number } {\n\t\treturn { object: this.value, rest: from };\n\t}\n}\n\nexport class TokenParser<T, R> extends Parser<T, R> {\n\tf: (t: T) => (null | R);\n\n\tconstructor(f: (t: T) => (null | R)) {\n\t\tsuper();\n\t\tthis.f = f;\n\t}\n\n\tparse(stream: T[], from: number): null | { object: R, rest: number } {\n\t\tif (from >= stream.length) {\n\t\t\treturn null;\n\t\t}\n\t\tconst front = stream[from];\n\t\tconst value = this.f(front);\n\t\tif (value === null) return null;\n\t\treturn { object: value, rest: from + 1 };\n\t}\n}\n\nexport class RepeatParser<T, R> extends Parser<T, R[]> {\n\telement: Parser<T, R>;\n\tmin?: number;\n\tmax?: number;\n\n\tconstructor(element: Parser<T, R>, min?: number, max?: number) {\n\t\tsuper();\n\t\tthis.element = element;\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t}\n\n\tparse(stream: T[], from: number, debugContext: DebugContext<T>): ParseResult<R[]> {\n\t\tconst list: R[] = [];\n\t\twhile (this.max === undefined || list.length < this.max) {\n\t\t\tconst result = this.element.parse(stream, from, debugContext);\n\t\t\tif (result === null) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlist.push(result.object);\n\t\t\t\tif (result.rest <= from) {\n\t\t\t\t\tthrow new Error(\"Encountered zero-token element in RepeatParser `\" + JSON.stringify(result) + \"`\");\n\t\t\t\t}\n\t\t\t\tfrom = result.rest;\n\t\t\t}\n\t\t}\n\n\t\tif (this.min !== undefined && list.length < this.min) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn { object: list, rest: from };\n\t}\n};\n\n/// PeekParser applies a subparser to the stream, but does not consume any\n/// tokens.\nexport class PeekParser<T, R> extends Parser<T, R> {\n\tconstructor(private subparser: Parser<T, R>) {\n\t\tsuper();\n\t}\n\n\tparse(stream: T[], from: number, debugContext: DebugContext<T>): ParseResult<R> {\n\t\tconst peek = this.subparser.parse(stream, from, debugContext);\n\t\tif (peek === null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn {\n\t\t\tobject: peek.object,\n\t\t\trest: from,\n\t\t};\n\t}\n}\n\nexport type RecordParserDescription<T, R> = { [P in keyof R]: (Parser<T, R[P]>) };\n\nexport class RecordParser<T, R> extends Parser<T, R> {\n\tprivate description: () => RecordParserDescription<T, R>;\n\tprivate mem: null | RecordParserDescription<T, R> = null;\n\n\tconstructor(description: () => RecordParserDescription<T, R>) {\n\t\tsuper();\n\t\tthis.description = description;\n\t}\n\n\tparse(stream: T[], from: number, debugContext: DebugContext<T>): ParseResult<R> {\n\t\t// Each RecordParser opens a new debug context.\n\t\t// TODO: Link the debug context to the parent context.\n\t\tdebugContext = {};\n\n\t\tlet mem = this.mem;\n\t\tif (mem === null) {\n\t\t\tmem = this.description();\n\t\t\tthis.mem = mem;\n\t\t}\n\n\t\tlet record: Partial<R> = {};\n\t\tfor (let p in mem) {\n\t\t\tlet firstToken = stream[from];\n\t\t\tconst parser = mem[p];\n\t\t\tlet result = parser.parse(stream, from, debugContext);\n\t\t\tif (result === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (p[0] !== \"_\") {\n\t\t\t\trecord[p] = result.object;\n\t\t\t}\n\t\t\tfrom = result.rest;\n\t\t\tconst followingToken = stream[from];\n\t\t\tdebugContext[p] = { first: firstToken, following: followingToken };\n\t\t}\n\t\treturn { object: record as R, rest: from };\n\t}\n}\n\n/// ChoiceParser implements *ordered* choice. The first constituent parser that\n/// accepts the input results in a parse.\nexport class ChoiceParser<T, U> extends Parser<T, U> {\n\tparsers: () => Parser<T, U>[];\n\tconstructor(parsers: () => Parser<T, U>[]) {\n\t\tsuper();\n\t\tthis.parsers = parsers;\n\t}\n\n\tparse(stream: T[], from: number, debugContext: DebugContext<T>): ParseResult<U> {\n\t\tfor (let parser of this.parsers()) {\n\t\t\tlet result = parser.parse(stream, from, debugContext);\n\t\t\tif (result === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn null;\n\t}\n}\n\n/// choice is a convenience function for getting terse inference.\nexport function choice<T, As, K extends keyof As>(grammar: () => ParsersFor<T, As>, ...keys: K[]) {\n\treturn new ChoiceParser<T, As[K]>(() => {\n\t\tconst g = grammar();\n\t\treturn keys.map(k => g[k]);\n\t});\n}\n\nexport type FailHandler<T, Q> = (stream: T[], from: number, context: DebugContext<T>) => Q;\n\nexport class FailParser<T> extends Parser<T, never> {\n\tconstructor(private f: FailHandler<T, unknown>) {\n\t\tsuper();\n\t}\n\n\tparse(stream: T[], from: number, debugContext: Record<string, TokenSpan<T>>): ParseResult<never> {\n\t\tthrow this.f(stream, from, debugContext);\n\t}\n}\n","import { SourceLocation } from \"./ir\";\nimport { ErrorElement, IdenToken, KeywordToken, NumberLiteralToken, OperatorToken, PUNCTUATION, PunctuationToken, StringLiteralToken, Token, tokenize, TypeIdenToken, TypeKeywordToken, TypeVarToken } from \"./lexer\";\nimport {\n\tchoice,\n\tChoiceParser,\n\tConstParser,\n\tDebugContext,\n\tFailHandler,\n\tParser,\n\tParseResult,\n\tParsersFor,\n\tPeekParser,\n\tRecordParser,\n\tRecordParserDescription,\n\tRepeatParser,\n\tTokenParser,\n\tTokenSpan,\n} from \"./parser\";\n\nfunction keywordParser<K extends KeywordToken[\"keyword\"]>(keyword: K): Parser<Token, KeywordToken & { keyword: K }> {\n\treturn new TokenParser((t) => {\n\t\tif (t.tag === \"keyword\") {\n\t\t\tif (t.keyword === keyword) {\n\t\t\t\treturn t as KeywordToken & { keyword: K };\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t});\n}\n\nfunction tokenParser<T extends Token[\"tag\"]>(tag: T): Parser<Token, Extract<Token, { tag: T }>> {\n\treturn new TokenParser((t: Token) => {\n\t\tif (t.tag === tag) {\n\t\t\treturn t as Extract<Token, { tag: T }>;\n\t\t}\n\t\treturn null;\n\t});\n}\n\nfunction punctuationParser<K extends keyof typeof PUNCTUATION>(symbol: K): Parser<Token, PunctuationToken> {\n\treturn new TokenParser((t: Token) => {\n\t\tif (t.tag === \"punctuation\" && t.symbol === symbol) {\n\t\t\treturn t;\n\t\t}\n\t\treturn null;\n\t});\n}\n\n\nconst eofParser: Parser<Token, SourceLocation> = new TokenParser(t => t.tag === \"eof\" ? t.location : null);\n\n/// `TrailingCommaParser` is a combinator that parses a comma-separated sequence\n/// of elements, with an optional trailing comma.\nclass TrailingCommaParser<T> extends Parser<Token, T[]> {\n\tconstructor(\n\t\tprivate element: Parser<Token, T>,\n\t) {\n\t\tsuper();\n\t}\n\n\tparse(stream: Token[], from: number,\n\t\tdebugContext: Record<string, TokenSpan<Token>>,\n\t): ParseResult<T[]> {\n\t\tlet list = [];\n\t\twhile (true) {\n\t\t\tconst element = this.element.parse(stream, from, debugContext);\n\t\t\tif (element === null) {\n\t\t\t\treturn { object: list, rest: from };\n\t\t\t}\n\t\t\tlist.push(element.object);\n\t\t\tfrom = element.rest;\n\t\t\tconst comma = punctuation.comma.parse(stream, from, debugContext);\n\t\t\tif (comma === null) {\n\t\t\t\treturn { object: list, rest: from };\n\t\t\t}\n\t\t\tfrom = comma.rest;\n\t\t}\n\t}\n}\n\n/// `CommaParser` is a combinator that parses a comma-separated sequence of\n/// elements.\nclass CommaParser<T> extends Parser<Token, T[]> {\n\tconstructor(\n\t\tprivate element: Parser<Token, T>,\n\t\tprivate expected: string,\n\t\tprivate min = 0) {\n\t\tsuper();\n\t}\n\n\tparse(stream: Token[], from: number, debugContext: Record<string, TokenSpan<Token>>): ParseResult<T[]> {\n\t\tlet out = [];\n\t\twhile (true) {\n\t\t\tconst object = this.element.parse(stream, from, debugContext);\n\t\t\tif (object === null) {\n\t\t\t\tif (out.length < this.min) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (out.length === 0) {\n\t\t\t\t\treturn { object: [], rest: from };\n\t\t\t\t}\n\t\t\t\tthrow new ParseError([this.expected, stream[from].location]);\n\t\t\t} else {\n\t\t\t\tout.push(object.object);\n\t\t\t\tfrom = object.rest;\n\t\t\t}\n\n\t\t\t// Parse a comma.\n\t\t\tconst comma = punctuation.comma.parse(stream, from, debugContext);\n\t\t\tif (comma === null) {\n\t\t\t\tif (out.length < this.min) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tobject: out,\n\t\t\t\t\trest: from,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tfrom = comma.rest;\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass StructParser<T extends { location: SourceLocation }, R> extends Parser<T, R & { location: SourceLocation }> {\n\tparser: RecordParser<T, R>;\n\n\tconstructor(spec: () => RecordParserDescription<T, R>) {\n\t\tsuper();\n\t\tthis.parser = new RecordParser(spec);\n\t}\n\n\tparse(stream: T[], from: number, debugContext: DebugContext<T>): ParseResult<R & { location: SourceLocation }> {\n\t\tconst firstToken = stream[from].location;\n\n\t\tconst result = this.parser.parse(stream, from, debugContext);\n\t\tif (result === null || \"message\" in result) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst lastToken = stream[result.rest - 1].location;\n\t\tconst location = {\n\t\t\tfileID: firstToken.fileID,\n\t\t\toffset: firstToken.offset,\n\t\t\tlength: lastToken.offset + lastToken.length - firstToken.offset,\n\t\t};\n\n\t\treturn {\n\t\t\tobject: { ...result.object, location },\n\t\t\trest: result.rest,\n\t\t};\n\t}\n}\n\nfunction requireAtLeastOne<T>(thing: string) {\n\treturn (array: T[], tokens: Token[], from: number) => {\n\t\tif (array.length === 0) {\n\t\t\tthrow new ParseError([\n\t\t\t\t\"Expected at least one \" + thing + \" at\",\n\t\t\t\ttokens[from].location,\n\t\t\t]);\n\t\t}\n\t\treturn array;\n\t};\n}\n\nfunction parseProblem(...message: (ErrorElement | FailHandler<Token, ErrorElement | ErrorElement[]>)[]) {\n\treturn (stream: Token[], from: number, context: DebugContext<Token>) => {\n\t\tconst out = [];\n\t\tfor (let e of message) {\n\t\t\tif (typeof e === \"function\") {\n\t\t\t\tconst x = e(stream, from, context);\n\t\t\t\tif (Array.isArray(x)) {\n\t\t\t\t\tout.push(...x);\n\t\t\t\t} else {\n\t\t\t\t\tout.push(x);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tout.push(e);\n\t\t\t}\n\t\t}\n\t\treturn new ParseError(out);\n\t};\n}\n\nexport class ParseError {\n\tconstructor(public message: ErrorElement[]) { }\n\n\ttoString() {\n\t\treturn JSON.stringify(this.message);\n\t}\n}\n\nfunction atReference(name: string) {\n\treturn (stream: Token[], from: number, props: DebugContext<Token>): SourceLocation => {\n\t\tconst token = props[name].first;\n\t\tif (token === null) {\n\t\t\tthrow new Error(\"null first in atReference\");\n\t\t} else {\n\t\t\treturn token.location;\n\t\t}\n\t}\n}\n\nfunction atHead(stream: Token[], from: number): SourceLocation {\n\tconst token = stream[from];\n\tif (token === undefined) {\n\t\tthrow new Error(\"out of bounds\");\n\t} else {\n\t\treturn token.location;\n\t}\n}\n\n/// THROWS `LexError`\n/// THROWS `ParseError`\nexport function parseSource(blob: string, fileID: string) {\n\tconst tokens = tokenize(blob, fileID);\n\tconst result = grammar.Source.parse(tokens, 0, {})!;\n\t// N.B.: The end-of parser in Source ensures no tokens are left afterwards.\n\treturn result.object;\n}\n\nexport type BooleanLiteralToken = KeywordToken & { keyword: \"true\" | \"false\" };\nexport type BinaryLogicalToken = KeywordToken & { keyword: \"and\" | \"or\" | \"implies\" };\n\nconst tokens = {\n\tpackageIden: tokenParser(\"iden\"),\n\ttypeIden: tokenParser(\"type-iden\"),\n\tiden: tokenParser(\"iden\"),\n\ttypeVarIden: tokenParser(\"type-var\"),\n\ttypeParameterConstraintMethodSubject: new TokenParser((token: Token) => {\n\t\tif (token.tag === \"type-var\") {\n\t\t\treturn token;\n\t\t} else if (token.tag === \"type-keyword\" && token.keyword === \"This\") {\n\t\t\treturn token as TypeKeywordToken & { keyword: \"This\" };\n\t\t}\n\t\treturn null;\n\t}),\n\ttypeKeyword: tokenParser(\"type-keyword\"),\n\toperator: tokenParser(\"operator\"),\n\tstringLiteral: tokenParser(\"string-literal\"),\n\tnumberLiteral: tokenParser(\"number-literal\"),\n\tbooleanLiteral: new TokenParser((token: Token) => {\n\t\tif (token.tag !== \"keyword\") {\n\t\t\treturn null;\n\t\t} else if (token.keyword !== \"true\" && token.keyword !== \"false\") {\n\t\t\treturn null;\n\t\t}\n\t\treturn token as BooleanLiteralToken;\n\t}),\n\tlogicalOperator: new TokenParser((token: Token) => {\n\t\tif (token.tag !== \"keyword\") {\n\t\t\treturn null;\n\t\t} else if (token.keyword !== \"and\" && token.keyword !== \"or\" && token.keyword !== \"implies\") {\n\t\t\treturn null;\n\t\t}\n\t\treturn token as BinaryLogicalToken;\n\t}),\n\treturnKeyword: keywordParser(\"return\"),\n};\n\nconst keywords = {\n\tassert: keywordParser(\"assert\"),\n\tclass: keywordParser(\"class\"),\n\telse: keywordParser(\"else\"),\n\tensures: keywordParser(\"ensures\"),\n\tenum: keywordParser(\"enum\"),\n\tfn: keywordParser(\"fn\"),\n\tif: keywordParser(\"if\"),\n\timpl: keywordParser(\"impl\"),\n\timport: keywordParser(\"import\"),\n\tis: keywordParser(\"is\"),\n\tinterface: keywordParser(\"interface\"),\n\tpackage: keywordParser(\"package\"),\n\tproof: keywordParser(\"proof\"),\n\trecord: keywordParser(\"record\"),\n\trequires: keywordParser(\"requires\"),\n\treturn: keywordParser(\"return\"),\n\tunreachable: keywordParser(\"unreachable\"),\n\tvar: keywordParser(\"var\"),\n};\n\nconst punctuation = {\n\tsemicolon: punctuationParser(\";\"),\n\tcomma: punctuationParser(\",\"),\n\tcolon: punctuationParser(\":\"),\n\tdot: punctuationParser(\".\"),\n\tequal: punctuationParser(\"=\"),\n\tpipe: punctuationParser(\"|\"),\n\tcurlyOpen: punctuationParser(\"{\"),\n\tcurlyClose: punctuationParser(\"}\"),\n\troundOpen: punctuationParser(\"(\"),\n\troundClose: punctuationParser(\")\"),\n\tsquareOpen: punctuationParser(\"[\"),\n\tsquareClose: punctuationParser(\"]\"),\n};\n\nexport interface Source {\n\tpackage: PackageDef,\n\timports: Import[],\n\tdefinitions: Definition[],\n}\n\nexport interface PackageDef {\n\tpackageName: IdenToken,\n}\n\nexport interface ImportOfObject {\n\ttag: \"of-object\",\n\n\tpackageName: IdenToken,\n\tobjectName: TypeIdenToken,\n\n\tlocation: SourceLocation,\n}\n\nexport interface ImportOfPackage {\n\ttag: \"of-package\",\n\n\tpackageName: IdenToken,\n\n\tlocation: SourceLocation,\n}\n\nexport interface Import {\n\timported: ImportOfObject | ImportOfPackage,\n}\n\nexport type Definition =\n\tRecordDefinition | EnumDefinition\n\t| InterfaceDefinition | ImplDefinition;\n\nexport interface RecordDefinition {\n\ttag: \"record-definition\",\n\tentityName: TypeIdenToken,\n\ttypeParameters: TypeParameters,\n\tfields: Field[],\n\tfns: Fn[],\n\n\tlocation: SourceLocation,\n}\n\nexport interface EnumDefinition {\n\ttag: \"enum-definition\",\n\tentityName: TypeIdenToken,\n\ttypeParameters: TypeParameters,\n\tvariants: Field[],\n\tfns: Fn[],\n\n\tlocation: SourceLocation,\n}\n\nexport interface ImplDefinition {\n\ttag: \"impl-definition\",\n\n\timpl: KeywordToken,\n\ttypeParameters: TypeParameters,\n\n\tbase: TypeNamed,\n\tconstraint: Constraint,\n\tfns: Fn[],\n\n\tlocation: SourceLocation,\n}\n\nexport interface InterfaceMember {\n\tsignature: FnSignature,\n}\n\nexport interface InterfaceDefinition {\n\ttag: \"interface-definition\",\n\tentityName: TypeIdenToken,\n\n\t/// Unlike other type-parameters, the `constraints` list may be non-empty\n\t/// even when `parameters` is empty (listing constraints on the implicit\n\t/// `This` type-parameter)\n\ttypeParameters: TypeParameters,\n\n\tmembers: InterfaceMember[],\n}\n\nexport interface Field {\n\tname: IdenToken,\n\tt: Type,\n}\n\nexport interface FnParameters {\n\tlist: FnParameter[],\n\n\tlocation: SourceLocation,\n}\n\nexport interface FnParameter {\n\tname: IdenToken,\n\tt: Type,\n}\n\nexport interface FnSignature {\n\tproof: KeywordToken | false,\n\tname: IdenToken,\n\tparameters: FnParameters,\n\treturns: Type[],\n\trequires: RequiresClause[],\n\tensures: EnsuresClause[],\n}\n\nexport interface RequiresClause {\n\texpression: Expression,\n}\n\nexport interface EnsuresClause {\n\texpression: Expression,\n}\n\nexport interface Fn {\n\tsignature: FnSignature,\n\tbody: Block,\n}\n\n// For bringing new type variables into a scope.\nexport interface TypeParameters {\n\tparameters: TypeVarToken[],\n\tconstraints: TypeConstraint[],\n}\n\n// For specifying arguments to some entity.\ninterface TypeArguments {\n\targuments: Type[],\n}\n\ninterface TypeConstraint {\n\tmethodSubject: TypeVarToken | (TypeKeywordToken & { keyword: \"This\" }),\n\tconstraint: Constraint,\n\n\tlocation: SourceLocation,\n}\n\ninterface TypeConstraints {\n\tconstraints: TypeConstraint[],\n}\n\nexport interface TypeNamed {\n\ttag: \"named\",\n\tpackageQualification: PackageQualification | null,\n\tentity: TypeIdenToken,\n\targuments: Type[],\n\tlocation: SourceLocation,\n}\n\nexport interface PackageQualification {\n\tpackage: IdenToken,\n\n\tlocation: SourceLocation,\n}\n\nexport type Type = TypeNamed | TypeKeywordToken | TypeVarToken;\n\nexport interface Block {\n\tstatements: Statement[],\n\tclosing: SourceLocation,\n}\n\nexport interface ReturnSt {\n\ttag: \"return\",\n\tvalues: Expression[],\n\n\tlocation: SourceLocation,\n}\n\nexport interface IfSt {\n\ttag: \"if\",\n\tcondition: Expression,\n\tbody: Block,\n\telseIfClauses: ElseIfClause[],\n\telseClause: ElseClause | null,\n}\n\nexport interface ElseIfClause {\n\tcondition: Expression,\n\tbody: Block,\n}\n\nexport interface ElseClause {\n\tbody: Block,\n}\n\nexport type Statement = VarSt | ReturnSt | IfSt | AssertSt | UnreachableSt;\n\nexport interface UnreachableSt {\n\ttag: \"unreachable\",\n\n\tlocation: SourceLocation,\n}\n\nexport interface AssertSt {\n\ttag: \"assert\",\n\texpression: Expression,\n\n\tlocation: SourceLocation,\n}\n\nexport interface VarSt {\n\ttag: \"var\",\n\tvariables: VarDecl[],\n\tinitialization: Expression[],\n\n\tlocation: SourceLocation,\n}\n\nexport interface VarDecl {\n\tvariable: IdenToken,\n\tt: Type,\n\n\tlocation: SourceLocation,\n}\n\nexport interface Expression {\n\tleft: ExpressionOperand,\n\toperations: ExpressionOperation[],\n\n\tlocation: SourceLocation,\n}\n\nexport type ExpressionAccess = ExpressionAccessMethod | ExpressionAccessField;\n\nexport interface ExpressionAccessMethod {\n\ttag: \"method\",\n\tmethodName: IdenToken,\n\targs: Expression[],\n\n\tlocation: SourceLocation,\n}\n\nexport interface ExpressionAccessField {\n\ttag: \"field\",\n\tfieldName: IdenToken,\n}\n\nexport interface ExpressionOperand {\n\tatom: ExpressionAtom,\n\taccesses: ExpressionAccess[],\n\tsuffixIs: ExpressionSuffixIs | null,\n\n\tlocation: SourceLocation,\n}\n\nexport interface ExpressionOperationLogical {\n\ttag: \"logical\",\n\toperator: BinaryLogicalToken,\n\tright: ExpressionOperand,\n}\n\nexport interface ExpressionSuffixIs {\n\ttag: \"is\",\n\toperator: KeywordToken,\n\tvariant: IdenToken,\n\n\tlocation: SourceLocation,\n}\n\nexport type ExpressionOperation = ExpressionOperationBinary | ExpressionOperationLogical;\n\nexport interface ExpressionOperationBinary {\n\ttag: \"binary\",\n\toperator: OperatorToken,\n\tright: ExpressionOperand,\n}\n\nexport interface ExpressionParenthesized {\n\ttag: \"paren\",\n\texpression: Expression,\n\n\tlocation: SourceLocation,\n}\n\nexport interface ExpressionTypeCall {\n\ttag: \"type-call\",\n\tt: Type,\n\tmethodName: IdenToken,\n\targuments: Expression[],\n\n\tlocation: SourceLocation,\n}\n\nexport interface ExpressionConstraintCall {\n\ttag: \"constraint-call\",\n\tconstraint: ExpressionConstraint,\n\tmethodName: IdenToken,\n\targuments: Expression[],\n\n\tlocation: SourceLocation,\n}\n\ntype Constraint = TypeNamed;\n\nexport interface ExpressionConstraint {\n\tsubject: Type,\n\tconstraint: Constraint,\n\n\tlocation: SourceLocation,\n}\n\n\nexport interface ExpressionRecordLiteral {\n\ttag: \"record-literal\",\n\tt: Type,\n\tinitializations: ExpressionRecordFieldInit[],\n\n\tlocation: SourceLocation,\n}\n\nexport interface ExpressionRecordFieldInit {\n\tfieldName: IdenToken,\n\tvalue: Expression,\n}\n\nexport type ExpressionAtom = ExpressionParenthesized\n\t| StringLiteralToken | NumberLiteralToken\n\t| BooleanLiteralToken\n\t| (KeywordToken & { keyword: \"return\" })\n\t| IdenToken\n\t| ExpressionTypeCall\n\t| ExpressionRecordLiteral\n\t| ExpressionConstraintCall;\n\ntype ASTs = {\n\tAssertSt: AssertSt,\n\tBlock: Block,\n\tDefinition: Definition,\n\tElseClause: ElseClause,\n\tElseIfClause: ElseIfClause,\n\tEnsuresClause: EnsuresClause,\n\tEnumDefinition: EnumDefinition,\n\tExpression: Expression,\n\tExpressionAccess: ExpressionAccess,\n\tExpressionAccessField: ExpressionAccessField,\n\tExpressionAccessMethod: ExpressionAccessMethod,\n\tExpressionAtom: ExpressionAtom,\n\tExpressionConstraint: ExpressionConstraint,\n\tExpressionConstraintCall: ExpressionConstraintCall,\n\tExpressionOperand: ExpressionOperand,\n\tExpressionOperation: ExpressionOperation,\n\tExpressionOperationBinary: ExpressionOperationBinary,\n\tExpressionOperationLogical: ExpressionOperationLogical,\n\tExpressionParenthesized: ExpressionParenthesized,\n\tExpressionRecordLiteral: ExpressionRecordLiteral,\n\tExpressionRecordFieldInit: ExpressionRecordFieldInit,\n\tExpressionSuffixIs: ExpressionSuffixIs,\n\tExpressionTypeCall: ExpressionTypeCall,\n\tField: Field,\n\tFn: Fn,\n\tFnParameter: FnParameter,\n\tFnParameters: FnParameters,\n\tFnSignature: FnSignature,\n\tIfSt: IfSt,\n\tImplDefinition: ImplDefinition,\n\tImport: Import,\n\tImportOfObject: ImportOfObject,\n\tImportOfPackage: ImportOfPackage,\n\tInterfaceDefinition: InterfaceDefinition,\n\tInterfaceMember: InterfaceMember,\n\tPackageDef: PackageDef,\n\tPackageQualification: PackageQualification,\n\tRecordDefinition: RecordDefinition,\n\tRequiresClause: RequiresClause,\n\tReturnSt: ReturnSt,\n\tSource: Source,\n\tStatement: Statement,\n\tType: Type,\n\tTypeArguments: TypeArguments,\n\tTypeConstraint: TypeConstraint,\n\tTypeConstraints: TypeConstraints,\n\tTypeNamed: TypeNamed,\n\tTypeParameters: TypeParameters,\n\tTypeParametersOnlyConstraints: TypeParameters,\n\tUnreachableSt: UnreachableSt,\n\tVarDecl: VarDecl,\n\tVarSt: VarSt,\n};\n\nexport const grammar: ParsersFor<Token, ASTs> = {\n\tAssertSt: new StructParser(() => ({\n\t\t_assert: keywords.assert,\n\t\ttag: new ConstParser(\"assert\"),\n\t\texpression: grammar.Expression\n\t\t\t.required(parseProblem(\"Expected an expression at\", atHead,\n\t\t\t\t\"after `assert`\")),\n\t\t_semicolon: punctuation.semicolon\n\t\t\t.required(parseProblem(\"Expected a `;` after assert condition at\", atHead)),\n\t})),\n\tBlock: new RecordParser(() => ({\n\t\t_open: punctuation.curlyOpen,\n\t\tstatements: new RepeatParser(grammar.Statement),\n\t\tclosing: punctuation.curlyClose\n\t\t\t.required(parseProblem(\n\t\t\t\t\"Expected a `}` at\", atHead,\n\t\t\t\t\"to complete a block started at\", atReference(\"_open\")))\n\t\t\t.map(x => x.location),\n\t})),\n\tTypeNamed: new StructParser(() => ({\n\t\tpackageQualification: grammar.PackageQualification\n\t\t\t.otherwise(null),\n\t\tentity: tokens.typeIden,\n\t\ttag: new ConstParser(\"named\"),\n\t\targuments: grammar.TypeArguments.map(x => x.arguments).otherwise([]),\n\t})),\n\tDefinition: choice(() => grammar,\n\t\t\"RecordDefinition\", \"EnumDefinition\", \"ImplDefinition\", \"InterfaceDefinition\"),\n\tElseClause: new RecordParser(() => ({\n\t\t_else: keywords.else,\n\t\tbody: grammar.Block\n\t\t\t.required(parseProblem(\"Expected a block after `else` at\", atHead)),\n\t})),\n\tElseIfClause: new RecordParser(() => ({\n\t\t_else: keywords.else,\n\t\t_if: keywords.if,\n\t\tcondition: grammar.Expression\n\t\t\t.required(parseProblem(\"Expected an expression after `if` at\", atHead)),\n\t\tbody: grammar.Block\n\t\t\t.required(parseProblem(\"Expected a block after condition at\", atHead)),\n\t})),\n\tEnsuresClause: new RecordParser(() => ({\n\t\t_ensures: keywords.ensures,\n\t\texpression: grammar.Expression\n\t\t\t.required(parseProblem(\"Expected an expression after `ensures` at\", atHead)),\n\t})),\n\tEnumDefinition: new StructParser(() => ({\n\t\t_enum: keywords.enum,\n\t\ttag: new ConstParser(\"enum-definition\"),\n\t\tentityName: tokens.typeIden\n\t\t\t.required(parseProblem(\"Expected a type name after `enum` at\", atHead)),\n\t\ttypeParameters: grammar.TypeParameters\n\t\t\t.otherwise({ parameters: [], constraints: [] } as TypeParameters),\n\t\t_open: punctuation.curlyOpen\n\t\t\t.required(parseProblem(\"Expected a `{` to begin enum body at\", atHead)),\n\t\tvariants: new RepeatParser(grammar.Field),\n\t\tfns: new RepeatParser(grammar.Fn),\n\t\t_close: punctuation.curlyClose\n\t\t\t.required(parseProblem(\"Expected a `}` at\", atHead,\n\t\t\t\t\"to complete an enum definition beginning at\", atReference(\"_open\"))),\n\t})),\n\tExpression: new StructParser(() => ({\n\t\tleft: grammar.ExpressionOperand,\n\t\toperations: new RepeatParser(grammar.ExpressionOperation),\n\t})),\n\tExpressionAccess: choice(() => grammar, \"ExpressionAccessMethod\", \"ExpressionAccessField\"),\n\tExpressionAccessField: new StructParser(() => ({\n\t\t_dot: punctuation.dot,\n\t\tfieldName: tokens.iden,\n\t\ttag: new ConstParser(\"field\"),\n\t})),\n\tExpressionAccessMethod: new StructParser(() => ({\n\t\t_dot: punctuation.dot,\n\t\tmethodName: tokens.iden\n\t\t\t.required(parseProblem(\"Expected a field or method name after a `.` at\", atHead)),\n\t\t_open: punctuation.roundOpen,\n\t\ttag: new ConstParser(\"method\"),\n\t\targs: new CommaParser(grammar.Expression,\n\t\t\t\"Expected another method argument at\"),\n\t\t_close: punctuation.roundClose\n\t\t\t.required(parseProblem(\"Expected a `)` at\", atHead,\n\t\t\t\t\"to complete a method call beginning at\", atReference(\"_open\"))),\n\t})),\n\tExpressionAtom: new ChoiceParser<Token, ExpressionAtom>(() => [\n\t\tgrammar.ExpressionParenthesized,\n\t\ttokens.stringLiteral,\n\t\ttokens.numberLiteral,\n\t\ttokens.booleanLiteral,\n\t\ttokens.returnKeyword,\n\t\ttokens.iden,\n\t\tgrammar.ExpressionTypeCall,\n\t\tgrammar.ExpressionRecordLiteral,\n\t\tgrammar.ExpressionConstraintCall,\n\t]),\n\tExpressionConstraint: new StructParser(() => ({\n\t\t_open: punctuation.roundOpen,\n\t\tsubject: grammar.Type,\n\t\t_is: keywords.is,\n\t\tconstraint: grammar.TypeNamed\n\t\t\t.required(parseProblem(\n\t\t\t\t\"Expected a constraint after `is` at\", atHead)),\n\t\t_close: punctuation.roundClose\n\t\t\t.required(parseProblem(\n\t\t\t\t\"Expected a `)`\", atHead,\n\t\t\t\t\"to complete constraint group at\", atReference(\"_open\"))),\n\t})),\n\tExpressionConstraintCall: new StructParser(() => ({\n\t\tconstraint: grammar.ExpressionConstraint,\n\t\ttag: new ConstParser(\"constraint-call\"),\n\t\t_dot: punctuation.dot,\n\t\tmethodName: tokens.iden\n\t\t\t.required(parseProblem(\n\t\t\t\t\"Expected a function name after `.` in a constraint-call expression at\", atHead)),\n\t\t_open: punctuation.roundOpen\n\t\t\t.required(parseProblem(\n\t\t\t\t\"Expected a `(` after a function name in a call expression at\", atHead)),\n\t\targuments: new CommaParser(grammar.Expression, \"Expected another argument at\"),\n\t\t_close: punctuation.roundClose\n\t\t\t.required(parseProblem(\"Expected a `)` at\", atHead,\n\t\t\t\t\"to complete a function call beginning at\", atReference(\"_open\"))),\n\t})),\n\tExpressionTypeCall: new StructParser(() => ({\n\t\tt: grammar.Type,\n\t\ttag: new ConstParser(\"type-call\"),\n\t\t_dot: punctuation.dot,\n\t\tmethodName: tokens.iden\n\t\t\t.required(parseProblem(\n\t\t\t\t\"Expected a function name after `.` in a type-call expression at\", atHead)),\n\t\t_open: punctuation.roundOpen\n\t\t\t.required(parseProblem(\n\t\t\t\t\"Expected a `(` after a function name in a call expression at\", atHead)),\n\t\targuments: new CommaParser(grammar.Expression, \"Expected another argument at\"),\n\t\t_close: punctuation.roundClose\n\t\t\t.required(parseProblem(\n\t\t\t\t\"Expected a `)` at\", atHead,\n\t\t\t\t\"to complete a function call beginning at\", atReference(\"_open\"))),\n\t})),\n\tExpressionRecordLiteral: new StructParser(() => ({\n\t\tt: grammar.Type,\n\t\t_open: punctuation.curlyOpen,\n\t\ttag: new ConstParser(\"record-literal\"),\n\t\tinitializations: new TrailingCommaParser(grammar.ExpressionRecordFieldInit),\n\t\t_close: punctuation.curlyClose\n\t\t\t.required(parseProblem(\n\t\t\t\t\"Expected a `}` at\", atHead,\n\t\t\t\t\"to complete a record literal beginning at\", atReference(\"_open\"))),\n\t})),\n\tExpressionRecordFieldInit: new RecordParser(() => ({\n\t\tfieldName: tokens.iden,\n\t\t_eq: punctuation.equal\n\t\t\t.required(parseProblem(\n\t\t\t\t\"Expected an `=` after a field name in a new-expression at\", atHead)),\n\t\tvalue: grammar.Expression\n\t\t\t.required(parseProblem(\n\t\t\t\t\"Expected an expression after `=` in a new-expression argument list at\", atHead)),\n\t})),\n\tExpressionOperand: new StructParser(() => ({\n\t\tatom: grammar.ExpressionAtom,\n\t\taccesses: new RepeatParser(grammar.ExpressionAccess),\n\t\tsuffixIs: grammar.ExpressionSuffixIs.otherwise(null),\n\t})),\n\tExpressionOperation: choice(() => grammar, \"ExpressionOperationBinary\", \"ExpressionOperationLogical\"),\n\tExpressionOperationBinary: new RecordParser(() => ({\n\t\ttag: new ConstParser(\"binary\"),\n\t\toperator: tokens.operator,\n\t\tright: grammar.ExpressionOperand\n\t\t\t.required(parseProblem(\"Expected an operand at\", atHead,\n\t\t\t\t\"after the binary operator at\", atReference(\"operator\")))\n\t})),\n\tExpressionOperationLogical: new RecordParser(() => ({\n\t\ttag: new ConstParser(\"logical\"),\n\t\toperator: tokens.logicalOperator,\n\t\tright: grammar.ExpressionOperand,\n\t})),\n\tExpressionSuffixIs: new StructParser(() => ({\n\t\ttag: new ConstParser(\"is\"),\n\t\toperator: keywords.is,\n\t\tvariant: tokens.iden,\n\t})),\n\tExpressionParenthesized: new StructParser(() => ({\n\t\t_open: punctuation.roundOpen,\n\t\ttag: new ConstParser(\"paren\"),\n\t\texpression: grammar.Expression,\n\t\t_close: punctuation.roundClose\n\t\t\t.required(parseProblem(\"Expected a `)` at\", atHead,\n\t\t\t\t\"to complete a grouping that began at\", atReference(\"_open\"))),\n\t})),\n\tField: new StructParser(() => ({\n\t\t_var: keywords.var,\n\t\tname: tokens.iden\n\t\t\t.required(parseProblem(\"Expected a field name after `var` at\", atHead)),\n\t\t_colon: punctuation.colon\n\t\t\t.required(parseProblem(\"Expected a `;` after variable name at\", atHead)),\n\t\tt: grammar.Type\n\t\t\t.required(parseProblem(\"Expected a type after `:` at\", atHead)),\n\t\t_semicolon: punctuation.semicolon\n\t\t\t.required(parseProblem(\"Expected a `;` after field type at\", atHead)),\n\t})),\n\tFn: new RecordParser(() => ({\n\t\tsignature: grammar.FnSignature,\n\t\tbody: grammar.Block\n\t\t\t.required(parseProblem(\"Expected a `{` to begin a function body at\", atHead))\n\t})),\n\tFnParameter: new RecordParser(() => ({\n\t\tname: tokens.iden,\n\t\t_colon: punctuation.colon,\n\t\tt: grammar.Type,\n\t})),\n\tFnParameters: new StructParser(() => ({\n\t\t_open: punctuation.roundOpen,\n\t\tlist: new CommaParser(grammar.FnParameter,\n\t\t\t\"Expected another function parameter after `,` at\"),\n\t\t_close: punctuation.roundClose\n\t\t\t.required(parseProblem(\"Expected a `)` at\", atHead,\n\t\t\t\t\"to complete the parameter list started at\", atReference(\"_open\"))),\n\t})),\n\tFnSignature: new StructParser(() => ({\n\t\tproof: keywords.proof.otherwise(false as const),\n\t\t_fn: keywords.fn,\n\t\tname: tokens.iden\n\t\t\t.required(parseProblem(\"Expected a function name after `fn` at\", atHead)),\n\t\tparameters: grammar.FnParameters\n\t\t\t.required(parseProblem(\"Expected a `(` to begin function parameters at\", atHead)),\n\t\t_colon: punctuation.colon\n\t\t\t.required(parseProblem(\"Expected a `:` after function parameters at\", atHead)),\n\t\treturns: new CommaParser(grammar.Type, \"Expected a return type at\")\n\t\t\t.map(requireAtLeastOne(\"return type\")),\n\t\trequires: new RepeatParser(grammar.RequiresClause),\n\t\tensures: new RepeatParser(grammar.EnsuresClause),\n\t})),\n\tIfSt: new RecordParser(() => ({\n\t\t_if: keywords.if,\n\t\ttag: new ConstParser(\"if\"),\n\t\tcondition: grammar.Expression\n\t\t\t.required(parseProblem(\"Expected a condition after `if` at\", atHead)),\n\t\tbody: grammar.Block\n\t\t\t.required(parseProblem(\"Expected a block after if condition at\", atHead)),\n\t\telseIfClauses: new RepeatParser(grammar.ElseIfClause),\n\t\telseClause: grammar.ElseClause.otherwise(null),\n\t})),\n\tInterfaceMember: new RecordParser(() => ({\n\t\tsignature: grammar.FnSignature,\n\t\t_semicolon: punctuation.semicolon\n\t\t\t.required(parseProblem(\"Expected a `;` to complete the interface member at\", atHead)),\n\t})),\n\tInterfaceDefinition: new RecordParser(() => ({\n\t\t_interface: keywords.interface,\n\t\ttag: new ConstParser(\"interface-definition\"),\n\t\tentityName: tokens.typeIden,\n\t\ttypeParameters: new ChoiceParser(() => [grammar.TypeParametersOnlyConstraints, grammar.TypeParameters])\n\t\t\t.otherwise({ parameters: [], constraints: [] } as TypeParameters),\n\t\t_open: punctuation.curlyOpen,\n\t\tmembers: new RepeatParser(grammar.InterfaceMember),\n\t\t_close: punctuation.curlyClose\n\t\t\t.required(parseProblem(\"Expected a `}` at\", atHead,\n\t\t\t\t\"to complete an interface definition beginning at\", atReference(\"_open\"))),\n\t})),\n\tImplDefinition: new StructParser(() => ({\n\t\timpl: keywords.impl,\n\t\ttag: new ConstParser(\"impl-definition\"),\n\t\ttypeParameters: grammar.TypeParameters\n\t\t\t.otherwise({ parameters: [], constraints: [] } as TypeParameters),\n\t\tbase: grammar.TypeNamed\n\t\t\t.required(parseProblem(\"Expected a compound type after `impl` at\", atHead)),\n\t\t_is: keywords.is\n\t\t\t.required(parseProblem(\"Expected `is` after compound type in `impl` definition at\", atHead)),\n\t\tconstraint: grammar.TypeNamed\n\t\t\t.required(parseProblem(\"Expected a constraint after `is` in `impl` definition at\", atHead)),\n\t\t_open: punctuation.curlyOpen\n\t\t\t.required(parseProblem(\"Expected a `{` after constraint in `impl` definition at\", atHead)),\n\t\tfns: new RepeatParser(grammar.Fn),\n\t\t_close: punctuation.curlyClose\n\t\t\t.required(parseProblem(\"Expected a `}` after `impl` defition function members at\", atHead)),\n\t})),\n\tImport: new RecordParser(() => ({\n\t\t_import: keywords.import,\n\t\timported: choice(() => grammar, \"ImportOfObject\", \"ImportOfPackage\")\n\t\t\t.required(parseProblem(\"Expected an entity or package to import after `import` at\", atHead)),\n\t\t_semicolon: punctuation.semicolon\n\t\t\t.required(parseProblem(\"Expected a `;` to end the import at\", atHead)),\n\t})),\n\tImportOfObject: new StructParser(() => ({\n\t\ttag: new ConstParser(\"of-object\"),\n\t\tpackageName: tokens.packageIden,\n\t\t_dot: punctuation.dot,\n\t\tobjectName: tokens.typeIden\n\t\t\t.required(parseProblem(\"Expected an object name to import after `:` at\", atHead)),\n\t})),\n\tImportOfPackage: new StructParser(() => ({\n\t\ttag: new ConstParser(\"of-package\"),\n\t\tpackageName: tokens.packageIden,\n\t})),\n\tPackageDef: new RecordParser(() => ({\n\t\t_package: keywords.package,\n\t\tpackageName: tokens.packageIden\n\t\t\t.required(parseProblem(\"Expected a package name after `package` at\", atHead)),\n\t\t_semicolon: punctuation.semicolon\n\t\t\t.required(parseProblem(\"Expected a `;` to end the package declaration at\", atHead)),\n\t})),\n\tPackageQualification: new StructParser(() => ({\n\t\tpackage: tokens.iden,\n\t\t_dot: punctuation.dot\n\t\t\t.required(parseProblem(\"Expected a `.` after a package name at\", atHead)),\n\t})),\n\tRecordDefinition: new StructParser(() => ({\n\t\t_record: keywords.record,\n\t\ttag: new ConstParser(\"record-definition\"),\n\t\tentityName: tokens.typeIden\n\t\t\t.required(parseProblem(\"Expected a type name after `record` at\", atHead)),\n\t\ttypeParameters: grammar.TypeParameters\n\t\t\t.otherwise({ parameters: [], constraints: [] } as TypeParameters),\n\t\t_open: punctuation.curlyOpen\n\t\t\t.required(parseProblem(\"Expected a `{` to begin record body at\", atHead)),\n\t\tfields: new RepeatParser(grammar.Field),\n\t\tfns: new RepeatParser(grammar.Fn),\n\t\t_close: punctuation.curlyClose\n\t\t\t.required(parseProblem(\"Expected a `}` at\", atHead,\n\t\t\t\t\"to complete a record definition beginning at\", atReference(\"_open\"))),\n\t})),\n\tRequiresClause: new RecordParser(() => ({\n\t\t_requires: keywords.requires,\n\t\texpression: grammar.Expression\n\t\t\t.required(parseProblem(\"Expected an expression after `requires` at\", atHead)),\n\t})),\n\tReturnSt: new StructParser(() => ({\n\t\t_return: keywords.return,\n\t\ttag: new ConstParser(\"return\"),\n\t\tvalues: new CommaParser(grammar.Expression, \"Expected an expression at\", 1)\n\t\t\t.required(parseProblem(\"Expected at least one value after `return` at\", atHead)),\n\t\t_semicolon: punctuation.semicolon\n\t\t\t.required(parseProblem(\"Expected a `;` to complete a return statement at\", atHead)),\n\t})),\n\tSource: new RecordParser(() => ({\n\t\tpackage: grammar.PackageDef\n\t\t\t.required(parseProblem(\"Expected a package declaration to begin the source file at\", atHead)),\n\t\timports: new RepeatParser(grammar.Import),\n\t\tdefinitions: new RepeatParser(grammar.Definition),\n\t\t_eof: eofParser\n\t\t\t.required(parseProblem(\"Expected another definition at\", atHead)),\n\t})),\n\tStatement: choice(() => grammar, \"VarSt\", \"ReturnSt\", \"IfSt\", \"AssertSt\", \"UnreachableSt\"),\n\tType: new ChoiceParser<Token, Type>(() => [grammar.TypeNamed, tokens.typeKeyword, tokens.typeVarIden]),\n\tTypeArguments: new RecordParser(() => ({\n\t\t_open: punctuation.squareOpen,\n\t\targuments: new CommaParser(grammar.Type, \"Expected another type argument at\")\n\t\t\t.map(requireAtLeastOne(\"type argument\")),\n\t\t_close: punctuation.squareClose\n\t\t\t.required(parseProblem(\"Expected a `]` at\", atHead,\n\t\t\t\t\"to complete type arguments started at\", atReference(\"_open\"))),\n\t})),\n\tTypeConstraint: new StructParser(() => ({\n\t\tmethodSubject: tokens.typeParameterConstraintMethodSubject,\n\t\t_is: keywords.is\n\t\t\t.required(parseProblem(\"Expected `is` after type constraint method subject at\", atHead)),\n\t\tconstraint: grammar.TypeNamed\n\t\t\t.required(parseProblem(\"Expected a constraint to be named after `is` at\", atHead)),\n\t})),\n\tTypeConstraints: new RecordParser(() => ({\n\t\t_pipe: punctuation.pipe,\n\t\tconstraints: new CommaParser(grammar.TypeConstraint,\n\t\t\t\"Expected a type constraint at\", 1)\n\t\t\t.required(parseProblem(\"Expected at least one type constraint at\", atHead)),\n\t})),\n\tTypeParametersOnlyConstraints: new RecordParser(() => ({\n\t\t_open: punctuation.squareOpen,\n\t\t_peekNonTypeVar: new PeekParser(tokens.typeKeyword),\n\t\tconstraints: new CommaParser(grammar.TypeConstraint,\n\t\t\t\"Expected a type constraint at\", 1)\n\t\t\t.required(parseProblem(\"Expected at least one type constraint at\", atHead)),\n\t\tparameters: new ConstParser([]),\n\t\t_close: punctuation.squareClose\n\t\t\t.required(parseProblem(\"Expected a `]` at\", atHead,\n\t\t\t\t\"to complete type parameters started at\", atReference(\"_open\"))),\n\t})),\n\tTypeParameters: new RecordParser(() => ({\n\t\t_open: punctuation.squareOpen,\n\t\tparameters: new CommaParser(tokens.typeVarIden, \"Expected a type variable at\", 1)\n\t\t\t.required(parseProblem(\"Expected a type variable at\", atHead)),\n\t\tconstraints: grammar.TypeConstraints.map(x => x.constraints)\n\t\t\t.otherwise([]),\n\t\t_close: punctuation.squareClose\n\t\t\t.required(parseProblem(\"Expected a `]` at\", atHead,\n\t\t\t\t\"to complete type parameters started at\", atReference(\"_open\"))),\n\t})),\n\tUnreachableSt: new StructParser(() => ({\n\t\t_unreachable: keywords.unreachable,\n\t\ttag: new ConstParser(\"unreachable\"),\n\t\t_semicolon: punctuation.semicolon\n\t\t\t.required(parseProblem(\"Expected a `;` after `unreachable` at\", atHead)),\n\t})),\n\tVarSt: new StructParser(() => ({\n\t\tvariables: new CommaParser(grammar.VarDecl, \"Expected another `var` variable declaration at\", 1),\n\t\ttag: new ConstParser(\"var\"),\n\t\t\"_eq\": punctuation.equal\n\t\t\t.required(parseProblem(\"Expected a `=` after variable declarations at\", atHead)),\n\t\tinitialization: new CommaParser(grammar.Expression, \"Expected another expression expression at\", 1)\n\t\t\t.required(parseProblem(\"Expected an initialization expression after `=` in a variable declaration at\", atHead)),\n\t\t\"_semicolon\": punctuation.semicolon\n\t\t\t.required(parseProblem(\"Expected a `;` after variable initialization at\", atHead)),\n\t})),\n\tVarDecl: new StructParser(() => ({\n\t\t_var: keywordParser(\"var\"),\n\t\tvariable: tokens.iden\n\t\t\t.required(parseProblem(\"Expected a variable name after `var` in a variable declaration at\", atHead)),\n\t\t_colon: punctuation.colon\n\t\t\t.required(parseProblem(\"Expected a `:` after a variable name in a variable declaration at\", atHead)),\n\t\tt: grammar.Type\n\t\t\t.required(parseProblem(\"Expected a type after `:` in a variable declaration at\", atHead)),\n\t})),\n};\n","import * as ir from \"./ir\";\nimport { ErrorElement } from \"./lexer\";\n\nexport type Value = RecordValue | EnumValue | BooleanValue | BytesValue | IntValue;\n\nexport type RecordValue = {\n\tsort: \"record\",\n\tfields: Record<string, Value>,\n};\n\nexport type EnumValue = {\n\tsort: \"enum\",\n\tfield: Record<string, Value>,\n}\n\nexport type BooleanValue = {\n\tsort: \"boolean\",\n\tboolean: boolean,\n};\n\nexport type BytesValue = {\n\tsort: \"bytes\",\n\tbytes: string,\n};\n\nexport type IntValue = {\n\tsort: \"int\",\n\tint: bigint,\n};\n\ninterface VTable {\n\ttag: \"dictionary\",\n\tentries: Record<string, VTableEntry>,\n}\n\ninterface VTableEntry {\n\timplementation: ir.FunctionID,\n\tclosureConstraints: VTable[],\n}\n\ninterface ConstraintsContext {\n\t// search:\n\tglobal: Map<ir.InterfaceID, Record<string, ir.VTableFactory>>,\n\n\tlocal: Map<ir.InterfaceID, {\n\t\t// runtime:\n\t\tvtable: VTable,\n\t\t// search:\n\t\tprovides: ir.ConstraintParameter,\n\t}[]>,\n}\n\n// N.B.: Only uses \"runtime\" fields.\ntype VTableProducer = (c: ConstraintsContext, callsite: VTable[]) => VTable;\n\n/// `makeVTableProducer` scans the \"search\" fields of the context, and produces\n/// a `VTableProducer` that only consumes the \"runtime\" fields of the context.j\n/// The returned producer can thus be cached, avoiding the expensive search\n/// process, for subsequent calls which have different runtime contexts but the\n/// same search context.\nfunction makeVTableProducer(\n\t// N.B.: Only uses \"search\" fields.\n\tcontext: ConstraintsContext,\n\tconstraint: ir.ConstraintParameter,\n): VTableProducer {\n\tconst locals = context.local.get(constraint.interface);\n\tif (locals !== undefined) {\n\t\tfor (let i = 0; i < locals.length; i++) {\n\t\t\tconst ti = i;\n\t\t\tconst local = locals[ti];\n\t\t\tconst matched = matchTypes([], local.provides.subjects, constraint.subjects);\n\t\t\tif (matched !== null) {\n\t\t\t\treturn (runtimeCtx, callsite) => {\n\t\t\t\t\treturn runtimeCtx.local.get(constraint.interface)![ti].vtable;\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\tconst globals = context.global.get(constraint.interface);\n\tif (globals !== undefined) {\n\t\tfor (const k in globals) {\n\t\t\tconst global = globals[k];\n\t\t\tconst matched = matchTypes(global.for_any, global.provides.subjects, constraint.subjects);\n\t\t\tif (matched !== null) {\n\t\t\t\tconst entrySchema: Record<string, {\n\t\t\t\t\timplementation: ir.FunctionID,\n\t\t\t\t\tclosureConstraints: (number | VTableProducer)[],\n\t\t\t\t}> = {};\n\t\t\t\tfor (const s in global.entries) {\n\t\t\t\t\tconst entry = global.entries[s];\n\t\t\t\t\tentrySchema[s] = {\n\t\t\t\t\t\timplementation: entry.implementation,\n\t\t\t\t\t\tclosureConstraints: entry.constraint_parameters.map(x => {\n\t\t\t\t\t\t\tif (typeof x === \"number\") {\n\t\t\t\t\t\t\t\treturn x;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn makeVTableProducer(context, {\n\t\t\t\t\t\t\t\tinterface: x.interface,\n\t\t\t\t\t\t\t\tsubjects: x.subjects.map(t => ir.typeSubstitute(t, matched)),\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}),\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn (runtimeCtx, callsite) => {\n\t\t\t\t\tconst entries: Record<string, VTableEntry> = {};\n\t\t\t\t\tfor (const s in entrySchema) {\n\t\t\t\t\t\tconst schema = entrySchema[s];\n\t\t\t\t\t\tentries[s] = {\n\t\t\t\t\t\t\timplementation: schema.implementation,\n\t\t\t\t\t\t\tclosureConstraints: schema.closureConstraints.map(x => {\n\t\t\t\t\t\t\t\tif (typeof x === \"number\") {\n\t\t\t\t\t\t\t\t\treturn callsite[x];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn x(runtimeCtx, callsite);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttag: \"dictionary\",\n\t\t\t\t\t\tentries,\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow new Error(\"Could not find an implementation of `\"\n\t\t+ JSON.stringify(constraint) + \"`\");\n}\n\nfunction matchTypeSingle(\n\tvariables: Map<ir.TypeVariableID, ir.Type | null>,\n\tpattern: ir.Type,\n\tsubject: ir.Type,\n): boolean {\n\tif (pattern.tag === \"type-variable\") {\n\t\tconst existing = variables.get(pattern.id);\n\t\tif (existing !== undefined) {\n\t\t\tif (existing === null || ir.equalTypes(existing, subject)) {\n\t\t\t\tvariables.set(pattern.id, subject);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t} else {\n\t\t\t// Literally references a type-variable, which must match the subject.\n\t\t\tif (subject.tag !== \"type-variable\") {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn pattern.id === subject.id;\n\t\t}\n\t} else if (pattern.tag === \"type-compound\" && subject.tag === \"type-compound\") {\n\t\tif (pattern.base !== subject.base) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (pattern.type_arguments.length !== subject.type_arguments.length) {\n\t\t\tthrow new Error(`Arity of type \\`${pattern.base}\\` is inconsistent.`);\n\t\t}\n\n\t\tfor (let i = 0; i < pattern.type_arguments.length; i++) {\n\t\t\tif (!matchTypeSingle(variables, pattern.type_arguments[i], subject.type_arguments[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t} else if (pattern.tag === \"type-primitive\" && subject.tag === \"type-primitive\") {\n\t\treturn pattern.primitive === subject.primitive;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/// `matchTypes` compares a `subject` to a particular `pattern`, returning a\n/// possible instantiation of the variables named in `forAny` such that the\n/// subject is equal to the instantiated pattern, or `null` if there is no such\n/// instantiation.\nfunction matchTypes(\n\tforAny: ir.TypeVariableID[],\n\tpattern: ir.Type[],\n\tsubject: ir.Type[],\n): Map<ir.TypeVariableID, ir.Type> | null {\n\tif (pattern.length !== subject.length) {\n\t\tthrow new Error(\"invalid\");\n\t}\n\n\tlet mapping: Map<ir.TypeVariableID, ir.Type | null> = new Map();\n\tfor (let t of forAny) {\n\t\tmapping.set(t, null);\n\t}\n\n\tfor (let i = 0; i < pattern.length; i++) {\n\t\tif (!matchTypeSingle(mapping, pattern[i], subject[i])) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tfor (let [k, v] of mapping) {\n\t\tif (!v) {\n\t\t\t// All variables must be referenced in the pattern.\n\t\t\tconsole.error(\"mapping:\", mapping);\n\t\t\tconsole.error(\"Illegal pattern in matchTypes:\", pattern);\n\t\t\tthrow new Error(\"pattern variable `\" + k + \"` is not referenced in pattern.\");\n\t\t}\n\t}\n\n\treturn mapping as Map<ir.TypeVariableID, ir.Type>;\n}\n\nfunction isTruthy(value: Value): boolean {\n\tif (value.sort !== \"boolean\") {\n\t\tthrow new Error(\"bad value sort for isTruthy `\" + value.sort + \"`\");\n\t}\n\treturn value.boolean;\n}\n\nexport type ForeignImpl = (args: Value[]) => Value[];\n\ninterface Context {\n\tprogram: ir.Program,\n\tforeign: Record<string, ForeignImpl>,\n\tconstraintContext: ConstraintsContext,\n}\n\nclass Frame {\n\tprivate stack: { name: ir.VariableID, t: ir.Type, value: Value, previous: undefined | number }[] = [];\n\tprivate variables: Map<ir.VariableID, number> = new Map();\n\n\tdefine(definition: ir.VariableDefinition, value: Value) {\n\t\tconst slot = this.stack.length;\n\t\tthis.stack.push({\n\t\t\tname: definition.variable,\n\t\t\tt: definition.type,\n\t\t\tvalue,\n\t\t\tprevious: this.variables.get(definition.variable)\n\t\t});\n\t\tthis.variables.set(definition.variable, slot);\n\t}\n\n\tload(name: ir.VariableID): Value {\n\t\tconst v = this.variables.get(name);\n\t\tif (v === undefined) {\n\t\t\tthrow new Error(\"variable `\" + name + \"` is not defined\");\n\t\t}\n\t\treturn this.stack[v].value;\n\t}\n\n\tstackSize(): number {\n\t\treturn this.stack.length;\n\t}\n\n\tpop(slice: number) {\n\t\tconst removed = this.stack.splice(slice);\n\t\tfor (let i = removed.length - 1; i >= 0; i--) {\n\t\t\tconst e = removed[i];\n\t\t\tif (e.previous === undefined) {\n\t\t\t\tthis.variables.delete(e.name);\n\t\t\t} else {\n\t\t\t\tthis.variables.set(e.name, e.previous);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function interpret(\n\tfn: ir.FunctionID,\n\targs: Value[],\n\tprogram: ir.Program,\n\tforeign: Record<string, ForeignImpl>,\n): Value[] {\n\tconst constraintContext: ConstraintsContext = {\n\t\tglobal: new Map(),\n\t\tlocal: new Map(),\n\t};\n\tfor (const k in program.globalVTableFactories) {\n\t\tconst factory = program.globalVTableFactories[k];\n\n\t\tlet group = constraintContext.global.get(factory.provides.interface);\n\t\tif (group === undefined) {\n\t\t\tgroup = {};\n\t\t\tconstraintContext.global.set(factory.provides.interface, group);\n\t\t}\n\t\tgroup[k] = factory;\n\t}\n\n\tconst context: Context = {\n\t\tprogram,\n\t\tforeign,\n\t\tconstraintContext,\n\t};\n\n\tconst iter = interpretCall(fn, args, [], context);\n\twhile (true) {\n\t\tconst x = iter.next();\n\t\tif (x.done) {\n\t\t\treturn x.value;\n\t\t}\n\t}\n}\n\n/// Execute a Shiru program until termination, returning the result from the\n/// given `entry` function.\nfunction* interpretCall(\n\tfnName: ir.FunctionID,\n\targs: Value[],\n\tvtables: VTable[],\n\tcontext: Context,\n): Generator<{}, Value[], unknown> {\n\tif (!context.program.functions[fnName]) {\n\t\tthrow new Error(\"The program has no function named `\" + fnName + \"`\");\n\t}\n\n\tconst fn = context.program.functions[fnName];\n\tif (fn.signature.constraint_parameters.length !== vtables.length) {\n\t\tthrow new Error(\"interpretCall: Wrong number of constraint parameters\");\n\t}\n\tconst newContext: Context = {\n\t\t...context,\n\t\tconstraintContext: {\n\t\t\tglobal: context.constraintContext.global,\n\t\t\tlocal: new Map(),\n\t\t},\n\t};\n\tfor (let i = 0; i < vtables.length; i++) {\n\t\tconst vtable = vtables[i];\n\t\tconst constraint = fn.signature.constraint_parameters[i];\n\t\tlet group = newContext.constraintContext.local.get(constraint.interface);\n\t\tif (group === undefined) {\n\t\t\tgroup = [];\n\t\t\tnewContext.constraintContext.local.set(constraint.interface, group);\n\t\t}\n\t\tgroup.push({\n\t\t\tvtable,\n\t\t\tprovides: constraint,\n\t\t});\n\t}\n\n\tconst frame: Frame = new Frame();\n\tfor (let i = 0; i < args.length; i++) {\n\t\tframe.define(fn.signature.parameters[i], args[i]);\n\t}\n\tconst result = yield* interpretBlock(fn.body, frame, newContext);\n\tif (result === null) {\n\t\tthrow new Error(\"Function `\" + fnName + \"` failed to return a result\");\n\t}\n\treturn result;\n}\n\nfunction* interpretBlock(\n\tblock: ir.OpBlock,\n\tframe: Frame,\n\tcontext: Context,\n\tcallback?: () => void,\n): Generator<{}, Value[] | null, unknown> {\n\tconst initialStack = frame.stackSize();\n\tfor (let op of block.ops) {\n\t\tconst result = yield* interpretOp(op, frame, context);\n\t\tif (result !== null) {\n\t\t\treturn result;\n\t\t}\n\t}\n\tif (callback !== undefined) {\n\t\tcallback();\n\t}\n\tframe.pop(initialStack);\n\treturn null;\n}\n\nfunction* interpretOp(\n\top: ir.Op,\n\tframe: Frame,\n\tcontext: Context,\n): Generator<{}, Value[] | null, unknown> {\n\tyield {};\n\tif (op.tag === \"op-return\") {\n\t\treturn op.sources.map(variable => frame.load(variable));\n\t} else if (op.tag === \"op-const\") {\n\t\tlet value: Value;\n\t\tif (op.type === \"Boolean\") {\n\t\t\tvalue = { sort: \"boolean\", boolean: op.boolean };\n\t\t} else if (op.type === \"Int\") {\n\t\t\tvalue = { sort: \"int\", int: BigInt(op.int) };\n\t\t} else if (op.type === \"Bytes\") {\n\t\t\tvalue = { sort: \"bytes\", bytes: op.bytes };\n\t\t} else {\n\t\t\tconst _: never = op;\n\t\t\tthrow new Error(\"interpretOp: unhandled op-const value\");\n\t\t}\n\t\tframe.define(op.destination, value);\n\t\treturn null;\n\t} else if (op.tag === \"op-copy\") {\n\t\tfor (const copy of op.copies) {\n\t\t\tconst sourceValue = frame.load(copy.source);\n\t\t\tframe.define(copy.destination, sourceValue);\n\t\t}\n\t\treturn null;\n\t} else if (op.tag === \"op-static-call\") {\n\t\tconst args = op.arguments.map(variable => frame.load(variable));\n\n\t\tconst constraintArgs: VTable[] = [];\n\t\tconst signature = context.program.functions[op.function].signature;\n\t\tconst instantiation = ir.typeArgumentsMap(signature.type_parameters, op.type_arguments);\n\t\tfor (let constraintTemplate of signature.constraint_parameters) {\n\t\t\tconst subjects = constraintTemplate.subjects.map(t => ir.typeSubstitute(t, instantiation));\n\t\t\tconst constraint: ir.ConstraintParameter = {\n\t\t\t\tinterface: constraintTemplate.interface,\n\t\t\t\tsubjects,\n\t\t\t}\n\n\t\t\tconst vtableProducer = makeVTableProducer(context.constraintContext, constraint);\n\t\t\tconst vtable = vtableProducer(context.constraintContext, []);\n\t\t\tconstraintArgs.push(vtable);\n\t\t}\n\n\t\tconst result = yield* interpretCall(op.function, args, constraintArgs, context);\n\t\tfor (let i = 0; i < result.length; i++) {\n\t\t\tframe.define(op.destinations[i], result[i]);\n\t\t}\n\t\treturn null;\n\t} else if (op.tag === \"op-foreign\") {\n\t\tconst args = op.arguments.map(source => frame.load(source));\n\t\tconst f = context.foreign[op.operation];\n\t\tif (f === undefined) {\n\t\t\tthrow new Error(\"interpretOp: no implementation for `\" + op.operation + \"`\");\n\t\t}\n\t\tconst result = f(args);\n\t\tfor (let i = 0; i < op.destinations.length; i++) {\n\t\t\tframe.define(op.destinations[i], result[i]);\n\t\t}\n\t\treturn null;\n\t} else if (op.tag === \"op-branch\") {\n\t\tconst conditionValue = frame.load(op.condition);\n\t\tconst condition = isTruthy(conditionValue);\n\t\tconst branch = condition ? op.trueBranch : op.falseBranch;\n\t\tconst result = yield* interpretBlock(branch, frame, context);\n\t\treturn result;\n\t} else if (op.tag === \"op-dynamic-call\") {\n\t\tconst args = op.arguments.map(arg => frame.load(arg));\n\t\tconst vtableProducer = makeVTableProducer(context.constraintContext, op.constraint);\n\t\tconst int = context.program.interfaces[op.constraint.interface];\n\t\tconst signature = int.signatures[op.signature_id];\n\n\t\tconst interfaceMap = ir.typeArgumentsMap(int.type_parameters, op.constraint.subjects);\n\t\tconst signatureMap = ir.typeArgumentsMap(signature.type_parameters, op.signature_type_arguments);\n\t\tconst substitutionMap = new Map([...interfaceMap.entries(), ...signatureMap.entries()]);\n\n\t\tconst callsite: VTable[] = [];\n\t\tfor (const genericConstraint of signature.constraint_parameters) {\n\t\t\tconst neededConstraint = ir.constraintSubstitute(genericConstraint, substitutionMap);\n\t\t\tconst argumentProducer = makeVTableProducer(context.constraintContext, neededConstraint);\n\t\t\tconst callsiteVTable = argumentProducer(context.constraintContext, []);\n\t\t\tcallsite.push(callsiteVTable);\n\t\t}\n\t\tconst vtable = vtableProducer(context.constraintContext, callsite);\n\n\t\tconst spec = vtable.entries[op.signature_id];\n\t\tconst constraintArgs = spec.closureConstraints;\n\n\t\tconst result = yield* interpretCall(spec.implementation, args, constraintArgs, context);\n\t\tfor (let i = 0; i < result.length; i++) {\n\t\t\tframe.define(op.destinations[i], result[i]);\n\t\t}\n\t\treturn null;\n\t} else if (op.tag === \"op-proof\") {\n\t\t// Do nothing.\n\t\treturn null;\n\t} else if (op.tag === \"op-proof-eq\") {\n\t\tthrow new Error(\"unexpected op-proof-eq\");\n\t} else if (op.tag === \"op-new-record\") {\n\t\tconst recordValue: RecordValue = {\n\t\t\tsort: \"record\",\n\t\t\tfields: {},\n\t\t};\n\t\tfor (let f in op.fields) {\n\t\t\trecordValue.fields[f] = frame.load(op.fields[f]);\n\t\t}\n\t\tframe.define(op.destination, recordValue);\n\t\treturn null;\n\t} else if (op.tag === \"op-new-enum\") {\n\t\tconst enumValue: EnumValue = {\n\t\t\tsort: \"enum\",\n\t\t\tfield: {},\n\t\t};\n\t\tenumValue.field[op.variant] = frame.load(op.variantValue);\n\t\tframe.define(op.destination, enumValue);\n\t\treturn null;\n\t} else if (op.tag === \"op-field\") {\n\t\tconst recordValue = frame.load(op.object);\n\t\tif (recordValue.sort !== \"record\") {\n\t\t\tthrow new Error(\"bad value sort for field access\");\n\t\t}\n\t\tframe.define(op.destination, recordValue.fields[op.field]);\n\t\treturn null;\n\t} else if (op.tag === \"op-variant\") {\n\t\tconst compoundValue = frame.load(op.object);\n\t\tif (compoundValue.sort !== \"enum\") {\n\t\t\tthrow new Error(\"bad value sort for variant access\");\n\t\t}\n\t\tconst variant = compoundValue.field[op.variant];\n\t\tif (variant === undefined) {\n\t\t\tthrow new RuntimeErr([\n\t\t\t\t\"Retrieve uninitialized variant at\",\n\t\t\t\top.diagnostic_location || \" (unknown location)\",\n\t\t\t]);\n\t\t}\n\t\tframe.define(op.destination, variant);\n\t\treturn null;\n\t} else if (op.tag === \"op-unreachable\") {\n\t\tthrow new RuntimeErr([\n\t\t\t\"Hit unreachable op at\",\n\t\t\top.diagnostic_location || \" (unknown location)\",\n\t\t]);\n\t} else if (op.tag === \"op-is-variant\") {\n\t\tconst base = frame.load(op.base);\n\t\tif (base.sort !== \"enum\") {\n\t\t\tthrow new Error(\"bad value sort for is-variant\");\n\t\t}\n\t\tconst contains = op.variant in base.field;\n\t\tframe.define(op.destination, { sort: \"boolean\", boolean: contains });\n\t\treturn null;\n\t}\n\n\tconst _: never = op;\n\tthrow new Error(\"interpretOp: unhandled op tag `\" + op[\"tag\"] + \"`\");\n}\n\nexport class RuntimeErr {\n\tconstructor(public message: ErrorElement[]) { }\n}\n\nfunction showType(t: ir.Type): string {\n\tif (t.tag === \"type-compound\") {\n\t\tconst generics = \"[\" + t.type_arguments.map(x => showType(x)).join(\", \") + \"]\";\n\t\treturn t.base + generics;\n\t} else if (t.tag === \"type-primitive\") {\n\t\treturn t.primitive;\n\t} else if (t.tag === \"type-variable\") {\n\t\treturn \"#\" + t.id;\n\t} else if (t.tag === \"type-any\") {\n\t\treturn \"Any\";\n\t}\n\n\tconst _: never = t;\n\tthrow new Error(\"showType: unknown tag `\" + t[\"tag\"] + \"`\");\n}\n\nexport function printProgram(program: ir.Program, lines: string[]) {\n\tfor (let fnName in program.functions) {\n\t\tprintFn(program, fnName, lines);\n\t}\n}\n\nexport function printFn(program: ir.Program, fnName: string, lines: string[]) {\n\tconst fn = program.functions[fnName];\n\tconst context = { typeVariables: [] as string[] };\n\tfor (let i = 0; i < fn.signature.type_parameters.length; i++) {\n\t\tcontext.typeVariables[i] = \"T\" + i;\n\t}\n\tconst parameters = [];\n\tfor (const parameter of fn.signature.parameters) {\n\t\tparameters.push(parameter.variable + \": \" + showType(parameter.type));\n\t}\n\tconst typeParameters = context.typeVariables.map(x => \"#\" + x).join(\", \");\n\tlines.push(\"fn \" + fnName + \"[\" + typeParameters + \"](\" + parameters.join(\", \") + \")\");\n\tfor (const pre of fn.signature.preconditions) {\n\t\tlines.push(\"precondition (\" + pre.precondition + \") {\");\n\t\tprintBlockContents(pre.block, \"\", context, lines);\n\t\tlines.push(\"}\");\n\t}\n\tfor (const post of fn.signature.postconditions) {\n\t\tlines.push(\"postcondition (\"\n\t\t\t+ post.returnedValues.map(printVariable).join(\", \")\n\t\t\t+ \" -> \" + post.postcondition + \") {\");\n\t\tprintBlockContents(post.block, \"\", context, lines);\n\t\tlines.push(\"}\");\n\t}\n\tlines.push(\"body {\");\n\tprintBlockContents(fn.body, \"\", context, lines);\n\tlines.push(\"}\");\n\tlines.push(\"\");\n}\n\nexport function printBlockContents(\n\tblock: ir.OpBlock,\n\tindent: string,\n\tcontext: { typeVariables: string[] },\n\tlines: string[],\n) {\n\tfor (let op of block.ops) {\n\t\tprintOp(op, indent + \"\\t\", context, lines);\n\t}\n}\n\nfunction printVariable(variable: ir.VariableDefinition) {\n\treturn \"var \" + variable.variable + \": \" + showType(variable.type);\n}\n\nexport function printOp(\n\top: ir.Op,\n\tindent: string,\n\tcontext: { typeVariables: string[] },\n\tlines: string[],\n) {\n\tif (op.tag === \"op-branch\") {\n\t\tconst cond = op.condition;\n\t\tlines.push(indent + \"if \" + cond + \" {\");\n\t\tprintBlockContents(op.trueBranch, indent, context, lines);\n\t\tlines.push(indent + \"}\");\n\t\tfor (const phi of op.destinations) {\n\t\t\tlines.push(indent + \"\\t\" + phi.destination.variable + \" := \" + (phi.trueSource as any).variable);\n\t\t}\n\t\tlines.push(indent + \"else {\");\n\t\tprintBlockContents(op.falseBranch, indent, context, lines);\n\t\tlines.push(indent + \"}\");\n\t\tfor (const phi of op.destinations) {\n\t\t\tlines.push(indent + \"\\t\" + phi.destination.variable + \" := \" + (phi.falseSource as any).variable);\n\t\t}\n\t\t// TODO: Format destinations?\n\t\treturn;\n\t} else if (op.tag === \"op-return\") {\n\t\tlines.push(indent + \"return \" + op.sources.join(\", \") + \";\");\n\t\treturn;\n\t} else if (op.tag === \"op-const\") {\n\t\tconst lhs = printVariable(op.destination);\n\t\tif (op.type === \"Int\") {\n\t\t\tlines.push(indent + lhs + \" = \" + op.int + \";\");\n\t\t} else if (op.type === \"Boolean\") {\n\t\t\tlines.push(indent + lhs + \" = \" + op.boolean + \";\");\n\t\t} else if (op.type === \"Bytes\") {\n\t\t\tlines.push(indent + lhs + \" = \" + JSON.stringify(op.bytes) + \";\");\n\t\t} else {\n\t\t\tconst _: never = op;\n\t\t\tthrow new Error(\"printOp: unrecognized const type\");\n\t\t}\n\t\treturn;\n\t} else if (op.tag === \"op-copy\") {\n\t\tconst lhs = op.copies.map(x => printVariable(x.destination));\n\t\tconst rhs = op.copies.map(x => x.source);\n\t\tlines.push(indent + lhs.join(\", \") + \" = \" + rhs.join(\", \") + \";\");\n\t\treturn;\n\t} else if (op.tag === \"op-foreign\") {\n\t\tconst lhs = op.destinations.map(printVariable).join(\", \");\n\t\tconst rhs = op.operation + \"(\" + op.arguments.join(\", \") + \");\";\n\t\tlines.push(indent + lhs + \" = \" + rhs);\n\t\treturn;\n\t} else if (op.tag === \"op-unreachable\") {\n\t\tlines.push(indent + \"unreachable; // \" + op.diagnostic_kind);\n\t\treturn;\n\t} else if (op.tag === \"op-static-call\") {\n\t\tconst targs = op.type_arguments.map(x => showType(x));\n\t\tconst lhs = op.destinations.map(x => printVariable).join(\", \");\n\t\tconst rhs = op.function + \"[\" + targs.join(\", \") + \"](\" + op.arguments.join(\", \") + \");\";\n\t\tlines.push(indent + lhs + \" = \" + rhs);\n\t\treturn;\n\t} else if (op.tag === \"op-proof\") {\n\t\tlines.push(indent + \"proof {\");\n\t\tprintBlockContents(op.body, indent, context, lines);\n\t\tlines.push(indent + \"}\");\n\t\treturn;\n\t} else if (op.tag === \"op-dynamic-call\") {\n\t\tconst f = op.constraint + \".\" + op.signature_id;\n\t\tconst targs = op.signature_type_arguments.map(x => showType(x));\n\t\tconst lhs = op.destinations.map(x => printVariable(x)).join(\", \");\n\t\tconst rhs = f + \"[\" + targs.join(\", \") + \"](\" + op.arguments.join(\", \") + \")\";\n\t\tlines.push(indent + lhs + \" = \" + rhs + \";\");\n\t\treturn;\n\t} else if (op.tag === \"op-field\") {\n\t\tconst lhs = printVariable(op.destination);\n\t\tconst rhs = op.object + \".\" + op.field;\n\t\tlines.push(indent + lhs + \" = \" + rhs + \";\");\n\t\treturn;\n\t} else if (op.tag === \"op-new-record\") {\n\t\tconst lhs = printVariable(op.destination);\n\t\tconst args = [];\n\t\tfor (let k in op.fields) {\n\t\t\targs.push(k + \" = \" + op.fields[k]);\n\t\t}\n\t\tconst recordType = showType(op.destination.type);\n\t\tconst recordLiteral = recordType + \"{\" + args.join(\", \") + \"}\";\n\t\tlines.push(indent + lhs + \" = \" + recordLiteral + \";\");\n\t\treturn;\n\t} else if (op.tag === \"op-new-enum\") {\n\t\tconst lhs = printVariable(op.destination);\n\t\tconst enumType = showType(op.destination.type);\n\t\tconst arg = op.variant + \" = \" + op.variantValue;\n\t\tconst enumLiteral = enumType + \"{\" + arg + \"}\";\n\t\tlines.push(indent + lhs + \" = \" + enumLiteral + \";\");\n\t\treturn;\n\t} else if (op.tag === \"op-is-variant\") {\n\t\tconst lhs = printVariable(op.destination);\n\t\tlines.push(indent + lhs + \" = \" + op.base + \" is \" + op.variant + \";\");\n\t\treturn;\n\t} else if (op.tag === \"op-variant\") {\n\t\tconst lhs = printVariable(op.destination);\n\t\tlines.push(indent + lhs + \" = \" + op.object + \".\" + op.variant + \";\");\n\t\treturn;\n\t} else if (op.tag === \"op-proof-eq\") {\n\t\tconst lhs = printVariable(op.destination);\n\t\tlines.push(indent + lhs + \" = \" + op.left + \" proof== \" + op.right + \";\");\n\t\treturn;\n\t}\n\n\tconst _: never = op;\n\tlines.push(indent + \"??? \" + op[\"tag\"] + \" ???\");\n}\n","/// TrieMap implements a map where keys are arrays.\n/// This is implemented using a \"trie\" of ES6 Map objects.\nexport class TrieMap<KS extends readonly unknown[], V> {\n\t// Unfortunately, more accurate typing of this very elaborate.\n\tprivate map: Map<KS[number], TrieMap<KS, V>> = new Map();\n\tprivate value: V | undefined = undefined;\n\n\tget(key: KS, from?: number): V | undefined {\n\t\tfrom = from || 0;\n\n\t\tif (key.length === from) {\n\t\t\treturn this.value;\n\t\t} else {\n\t\t\tconst head = key[from];\n\t\t\tconst child = this.map.get(head);\n\t\t\tif (child) {\n\t\t\t\treturn child.get(key, from + 1);\n\t\t\t} else {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t}\n\n\tput(key: KS, v: V, from?: number) {\n\t\tfrom = from || 0;\n\t\tif (key.length === from) {\n\t\t\tthis.value = v;\n\t\t} else {\n\t\t\tconst head = key[from];\n\t\t\tlet child = this.map.get(head);\n\t\t\tif (!child) {\n\t\t\t\tchild = new TrieMap;\n\t\t\t\tthis.map.set(key[from], child);\n\t\t\t}\n\t\t\tchild.put(key, v, from + 1);\n\t\t}\n\t}\n\n\t/// Iterate over [K[], V] pairs in this map.\n\t/// N.B.: The key array is retained and mutated by this generator, so it\n\t// should not be retained or modified by the caller.\n\t*[Symbol.iterator](progress: KS[number][] = []): Generator<[KS, V]> {\n\t\tif (this.value !== undefined) {\n\t\t\tyield [progress as unknown as KS, this.value];\n\t\t}\n\t\tfor (let [key, tree] of this.map) {\n\t\t\tprogress.push(key);\n\t\t\tyield* tree[Symbol.iterator](progress);\n\t\t\tprogress.pop();\n\t\t}\n\t}\n}\n\nexport class DefaultMap<K, V> {\n\tprivate map = new Map<K, V>();\n\tconstructor(private defaulter: (k: K) => V) { }\n\n\tget(key: K): V {\n\t\tif (this.map.has(key)) {\n\t\t\treturn this.map.get(key)!;\n\t\t} else {\n\t\t\tconst v = this.defaulter(key);\n\t\t\tthis.map.set(key, v);\n\t\t\treturn v;\n\t\t}\n\t}\n\n\t*[Symbol.iterator]() {\n\t\tyield* this.map[Symbol.iterator]();\n\t}\n}\n\ninterface Edge<E, K> {\n\tnext: E,\n\tkey: K,\n};\n\ntype BFS<E, K> = { n: E, parent: null } | { n: E, parent: BFS<E, K>, key: K };\n\n/// DisjointSet implements the \"disjoint set\" (a.k.a. \"union find\") data-\n/// structure, which tracks the set of components in an undirected graph between\n/// a set of integers {0, 1, 2, ... n} as edges are added.\n/// This implementation is augmented with information about \"keys\" so that\n/// queries can find a path between two nodes in the same component.\nexport class DisjointSet<E, K> {\n\tparents: Map<E, E> = new Map();\n\tranks: Map<E, number> = new Map();\n\toutgoingEdges: Map<E, Edge<E, K>[]> = new Map();\n\n\treset() {\n\t\tfor (const [k, _] of this.parents) {\n\t\t\tthis.parents.set(k, k);\n\t\t\tthis.ranks.set(k, 0);\n\t\t\tthis.outgoingEdges.set(k, []);\n\t\t}\n\t}\n\n\tinit(e: E) {\n\t\tif (!this.parents.has(e)) {\n\t\t\tthis.parents.set(e, e);\n\t\t\tthis.ranks.set(e, 0);\n\t\t\tthis.outgoingEdges.set(e, []);\n\t\t}\n\t}\n\n\t/// representative returns a \"representative\" element of the given object's\n\t/// equivalence class, such that two elements are members of the same\n\t/// equivalence class if and only if their representatives are the same.\n\trepresentative(e: E): E {\n\t\tthis.init(e);\n\t\twhile (true) {\n\t\t\tconst parent = this.parents.get(e)!;\n\t\t\tif (parent === e) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst grandparent = this.parents.get(parent)!;\n\t\t\tthis.parents.set(e, grandparent);\n\t\t\te = grandparent;\n\t\t}\n\t\treturn e;\n\t}\n\n\t/// compareEqual returns whether or not the two objects are members of the\n\t/// same equivalence class.\n\tcompareEqual(a: E, b: E): boolean {\n\t\treturn this.representative(a) === this.representative(b);\n\t}\n\n\t/// explainEquality returns a sequences of keys linking the two values in\n\t/// the same component.\n\texplainEquality(a: E, b: E): K[] {\n\t\t// Perform BFS on the outgoing edges graph.\n\t\tconst q: BFS<E, K>[] = [{ n: a, parent: null }];\n\t\tfor (let i = 0; i < q.length; i++) {\n\t\t\tconst top = q[i];\n\t\t\tif (top.n === b) {\n\t\t\t\tlet keys = [];\n\t\t\t\tlet c = top;\n\t\t\t\twhile (c.parent) {\n\t\t\t\t\tkeys.push(c.key);\n\t\t\t\t\tc = c.parent;\n\t\t\t\t}\n\t\t\t\treturn keys;\n\t\t\t}\n\t\t\tfor (const e of this.outgoingEdges.get(top.n)!) {\n\t\t\t\t// The outgoingEdges graph is strictly a tree, so we can avoid\n\t\t\t\t// using a set for visited edges by simply skipping edges that\n\t\t\t\t// go directly backward.\n\t\t\t\tconst isBackEdge = e.next === top.parent?.n;\n\t\t\t\tif (!isBackEdge) {\n\t\t\t\t\tq.push({\n\t\t\t\t\t\tn: e.next,\n\t\t\t\t\t\tparent: top,\n\t\t\t\t\t\tkey: e.key,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error(`objects ${String(a)} and ${String(b)} are in different components`);\n\t}\n\n\t/// union updates this datastructure to join the equivalence classes of\n\t/// objects a and b.\n\t/// RETURNS false when the objects were already members of the same\n\t///         equivalence class.\n\tunion(a: E, b: E, key: K): boolean {\n\t\tthis.init(a);\n\t\tthis.init(b);\n\t\tconst ra = this.representative(a);\n\t\tconst rb = this.representative(b);\n\t\tif (ra == rb) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.outgoingEdges.get(a)!.push({ next: b, key: key });\n\t\tthis.outgoingEdges.get(b)!.push({ next: a, key: key });\n\n\t\tlet child: E;\n\t\tlet parent: E;\n\t\tif (this.ranks.get(ra)! < this.ranks.get(rb)!) {\n\t\t\tchild = ra;\n\t\t\tparent = rb;\n\t\t} else {\n\t\t\tchild = rb;\n\t\t\tparent = ra;\n\t\t}\n\n\t\tthis.parents.set(child, parent);\n\t\tif (this.ranks.get(child) === this.ranks.get(parent)) {\n\t\t\tthis.ranks.set(parent, this.ranks.get(parent)! + 1);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/// RETURNS the set of equivalence classes managed by this data structure.\n\tcomponents(): E[][] {\n\t\tlet components: Map<E, E[]> = new Map();\n\t\tfor (const [e, parent] of this.parents) {\n\t\t\tif (e === parent) {\n\t\t\t\tcomponents.set(e, []);\n\t\t\t}\n\t\t}\n\t\tfor (const [e, _] of this.parents) {\n\t\t\tcomponents.get(this.representative(e))!.push(e);\n\t\t}\n\t\treturn [...components.values()];\n\t}\n}\n","import * as grammar from \"./grammar\";\nimport * as ir from \"./ir\";\nimport * as diagnostics from \"./diagnostics\";\nimport * as lexer from \"./lexer\";\nimport { DefaultMap } from \"./data\";\n\ninterface FieldBinding {\n\tnameLocation: ir.SourceLocation,\n\tt: ir.Type,\n\ttypeLocation: ir.SourceLocation,\n}\n\ninterface TypeBinding {\n\tt: ir.Type,\n\tnameLocation: ir.SourceLocation,\n\ttypeLocation: ir.SourceLocation,\n}\n\ninterface FnBinding {\n\ttag: \"fn-binding\",\n\n\tnameLocation: ir.SourceLocation,\n\tparameters: TypeBinding[],\n\tparametersLocation: ir.SourceLocation,\n\treturns: TypeBinding[],\n\tast: grammar.Fn,\n\n\t/// The type variables bound by the containing entity (e.g., record).\n\tentityTypeVariables: ir.TypeVariableID[],\n\n\t/// The type variables bound specifically to this signature.\n\tsignatureTypeVariables: ir.TypeVariableID[],\n\n\tid: ir.FunctionID,\n}\n\ninterface InterfaceFnBinding {\n\ttag: \"vtable-binding\",\n\tsignature_id: string,\n\n\tnameLocation: ir.SourceLocation,\n\tparameters: TypeBinding[],\n\tparametersLocation: ir.SourceLocation,\n\treturns: TypeBinding[],\n\tast: grammar.InterfaceMember,\n\n\tinterfaceTypeVariables: ir.TypeVariableID[],\n\tsignatureTypeVariables: ir.TypeVariableID[],\n}\n\ninterface RecordEntityDef {\n\ttag: \"record\",\n\tast: grammar.RecordDefinition,\n\tsourceID: string,\n\tbindingLocation: ir.SourceLocation,\n\n\t/// `typeScope` indicates the type-parameters (and their available\n\t/// constraints) within each member of `fields`, `implements`, and `fns`.\n\ttypeScope: TypeScopeI<ir.TypeCompound>,\n\tfields: Record<string, FieldBinding>,\n\n\t/// The set of constraints that this record type is the method-subject of.\n\timplsByInterface: DefaultMap<ir.InterfaceID, ImplEntityDef[]>,\n\n\tfns: Record<string, FnBinding>,\n}\n\ninterface EnumEntityDef {\n\ttag: \"enum\",\n\tast: grammar.EnumDefinition,\n\tsourceID: string,\n\tbindingLocation: ir.SourceLocation,\n\n\ttypeScope: TypeScopeI<ir.TypeCompound>,\n\tvariants: Record<string, FieldBinding>,\n\n\timplsByInterface: DefaultMap<ir.InterfaceID, ImplEntityDef[]>,\n\n\tfns: Record<string, FnBinding>,\n}\n\ninterface InterfaceEntityDef {\n\ttag: \"interface\",\n\tast: grammar.InterfaceDefinition,\n\tsourceID: string,\n\tbindingLocation: ir.SourceLocation,\n\n\ttypeScope: TypeScopeI<ir.TypeVariable>,\n\tfns: Record<string, InterfaceFnBinding>,\n}\n\ninterface ImplEntityDef {\n\ttag: \"impl\",\n\tast: grammar.ImplDefinition,\n\theadLocation: ir.SourceLocation,\n\tsourceID: string,\n\n\ttypeScope: TypeScopeI<null>,\n\tconstraint: ir.ConstraintParameter,\n}\n\ntype NamedEntityDef = RecordEntityDef | EnumEntityDef | InterfaceEntityDef;\ntype EntityDef = NamedEntityDef | ImplEntityDef;\n\ninterface EntityBinding {\n\tcanonicalName: string,\n\tbindingLocation: ir.SourceLocation,\n}\n\ninterface PackageBinding {\n\tpackageName: string,\n\tbindingLocation: ir.SourceLocation,\n}\n\n/// `ProgramContext` is built up over time to include the \"signature\"\n/// information needed to check references of one entity by another.\nclass ProgramContext {\n\t/// `canonicalByQualifiedName` is map from package name to entity name to\n\t/// canonical name.\n\tcanonicalByQualifiedName: Record<string, Record<string, string>> = {};\n\n\t/// `entitiesByCanonical` identifies information of the entity with the\n\t/// given \"canonical\" name.of the entity.\n\tprivate entitiesByCanonical: Record<string, NamedEntityDef> = {};\n\n\tforeignSignatures: Record<string, ir.FunctionSignature> = {};\n\n\tsourceContexts: Record<string, SourceContext> = {};\n\n\t/// `uncheckedTypes` and `uncheckedConstraints` are initially `[]`, and\n\t/// become `null` once  enough members have been collected to check that\n\t/// type arguments implement the required constraints.\n\tuncheckedTypes: null | {\n\t\tt: grammar.Type,\n\t\tscope: TypeScope,\n\t\tsourceContext: SourceContext,\n\t}[] = [];\n\tuncheckedConstraints: null | {\n\t\tc: grammar.TypeNamed,\n\t\tmethodSubject: ir.Type,\n\t\tsourceContext: Readonly<SourceContext>,\n\t\tscope: TypeScope,\n\t\t/// The location of the constraint, including the method subject and\n\t\t/// `is`.\n\t\tconstraintLocation: ir.SourceLocation,\n\t}[] = [];\n\n\t*namedEntities(): Generator<[string, NamedEntityDef]> {\n\t\tfor (const key in this.entitiesByCanonical) {\n\t\t\tyield [key, this.entitiesByCanonical[key as any]];\n\t\t}\n\t}\n\n\tgetDataEntity(id: ir.RecordID | ir.EnumID): RecordEntityDef | EnumEntityDef {\n\t\tconst entity = this.entitiesByCanonical[id as string];\n\t\tif (entity === undefined || entity.tag !== \"enum\" && entity.tag !== \"record\") {\n\t\t\tthrow new Error(\"getDataEntity: bad id\");\n\t\t}\n\t\treturn entity;\n\t}\n\n\tgetNamedEntity(canonicalName: string): NamedEntityDef | null {\n\t\tconst entity = this.entitiesByCanonical[canonicalName];\n\t\tif (entity === undefined) {\n\t\t\treturn null;\n\t\t}\n\t\treturn entity;\n\t}\n\n\tdefineEntity(canonicalName: string, entity: NamedEntityDef) {\n\t\tif (canonicalName in this.entitiesByCanonical) {\n\t\t\tthrow new Error(\"ProgramContext.defineEntity: entity already exists\");\n\t\t}\n\n\t\tthis.entitiesByCanonical[canonicalName] = entity;\n\t}\n\n\tgetRecord(recordID: ir.RecordID): RecordEntityDef {\n\t\tconst entity = this.entitiesByCanonical[recordID];\n\t\tif (entity === undefined || entity.tag !== \"record\") {\n\t\t\tthrow new Error(\"ICE: unexpected non-record ID `\" + recordID + \"`\");\n\t\t}\n\t\treturn entity;\n\t}\n\n\tgetInterface(interfaceID: ir.InterfaceID): InterfaceEntityDef {\n\t\tconst entity = this.entitiesByCanonical[interfaceID];\n\t\tif (entity === undefined || entity.tag !== \"interface\") {\n\t\t\tthrow new Error(\"ICE: unexpected non-interface ID `\" + interfaceID + \"`\");\n\t\t}\n\t\treturn entity;\n\t}\n}\n\n/// `SourceContext` represents the \"view\" of the program from the perspective of\n/// an individual source file. Currently, that is limited to aliases of objects\n/// and namespaces, which are driven primarily by import declarations.\ninterface SourceContext {\n\t/// `entityAliases` maps an unqualified name to a canonical entity.\n\t/// This includes an entry for each entity defined within this source's\n\t/// package.\n\tentityAliases: Record<string, EntityBinding>,\n\n\t/// `namespaces` maps a qualifier on a name to a package name.\n\t/// This does NOT include an entry for the current package, as explicit\n\t/// qualification in that form is not allowed.\n\tnamespaces: Record<string, PackageBinding>,\n\n\timplASTs: grammar.ImplDefinition[],\n\n\t/// `programContext` is a reference to the single common `ProgramContext`.\n\tprogramContext: ProgramContext,\n}\n\nfunction collectInterfaceRecordEntity(\n\tprogramContext: ProgramContext,\n\tpack: Record<string, string>,\n\tpackageName: string,\n\tsourceID: string,\n\tdefinition: grammar.InterfaceDefinition | grammar.RecordDefinition | grammar.EnumDefinition,\n) {\n\tconst entityName = definition.entityName.name;\n\tconst bindingLocation = definition.entityName.location;\n\tif (pack[entityName] !== undefined) {\n\t\tconst firstCanonical = pack[entityName];\n\t\tconst firstBinding = programContext.getNamedEntity(firstCanonical)!;\n\t\tthrow new diagnostics.EntityRedefinedErr({\n\t\t\tname: `${packageName}.${entityName}`,\n\t\t\tfirstBinding: firstBinding.bindingLocation,\n\t\t\tsecondBinding: bindingLocation,\n\t\t})\n\t}\n\tconst canonicalName = packageName + \".\" + entityName;\n\n\tlet entity: EntityDef;\n\tif (definition.tag === \"record-definition\") {\n\t\tconst thisType: ir.Type = {\n\t\t\ttag: \"type-compound\",\n\t\t\tbase: canonicalName as ir.RecordID,\n\t\t\ttype_arguments: definition.typeParameters.parameters.map(t => ({\n\t\t\t\ttag: \"type-variable\",\n\t\t\t\tid: t.name as ir.TypeVariableID,\n\t\t\t})),\n\t\t};\n\n\t\tentity = {\n\t\t\ttag: \"record\",\n\t\t\tast: definition,\n\t\t\tbindingLocation,\n\t\t\tsourceID,\n\n\t\t\ttypeScope: {\n\t\t\t\tthisType,\n\n\t\t\t\tconstraints: [],\n\t\t\t\ttypeVariables: new Map(),\n\t\t\t\ttypeVariableList: [],\n\t\t\t},\n\n\t\t\t// These are filled in by `collectMembers`.\n\t\t\tfields: {},\n\t\t\tfns: {},\n\t\t\timplsByInterface: new DefaultMap<ir.InterfaceID, ImplEntityDef[]>(() => []),\n\t\t};\n\t} else if (definition.tag === \"enum-definition\") {\n\t\tconst thisType: ir.Type = {\n\t\t\ttag: \"type-compound\",\n\t\t\tbase: canonicalName as ir.RecordID,\n\t\t\ttype_arguments: definition.typeParameters.parameters.map(t => ({\n\t\t\t\ttag: \"type-variable\",\n\t\t\t\tid: t.name as ir.TypeVariableID,\n\t\t\t})),\n\t\t};\n\n\t\tentity = {\n\t\t\ttag: \"enum\",\n\t\t\tast: definition,\n\t\t\tbindingLocation,\n\t\t\tsourceID,\n\n\t\t\ttypeScope: {\n\t\t\t\tthisType,\n\n\t\t\t\tconstraints: [],\n\t\t\t\ttypeVariables: new Map(),\n\t\t\t\ttypeVariableList: [],\n\t\t\t},\n\n\t\t\t// These are filled in by `collectMembers`.\n\t\t\tvariants: {},\n\t\t\tfns: {},\n\t\t\timplsByInterface: new DefaultMap<ir.InterfaceID, ImplEntityDef[]>(() => []),\n\t\t};\n\t} else {\n\t\tconst thisType = \"This\" as ir.TypeVariableID;\n\t\tentity = {\n\t\t\ttag: \"interface\",\n\t\t\tast: definition,\n\t\t\tbindingLocation,\n\t\t\tsourceID,\n\n\t\t\t// The \"first\" type-parameter is `This` rather than a named\n\t\t\t// `#T` type-variable.\n\t\t\ttypeScope: {\n\t\t\t\tthisType: {\n\t\t\t\t\ttag: \"type-variable\",\n\t\t\t\t\tid: thisType,\n\t\t\t\t},\n\t\t\t\tconstraints: [],\n\t\t\t\ttypeVariables: new Map(),\n\t\t\t\ttypeVariableList: [thisType],\n\t\t\t},\n\n\t\t\t// These are filled in by `collectMembers`.\n\t\t\tfns: {},\n\t\t};\n\t}\n\n\tprogramContext.defineEntity(canonicalName, entity);\n\tpack[entityName] = canonicalName;\n}\n\n// Collects the set of entities defined across all given sources.\nfunction collectAllEntities(sources: Record<string, grammar.Source>) {\n\tconst programContext = new ProgramContext();\n\tprogramContext.foreignSignatures = getBasicForeign();\n\n\tfor (const sourceID in sources) {\n\t\tconst source = sources[sourceID];\n\t\tconst packageName = source.package.packageName.name;\n\t\tconst pack = programContext.canonicalByQualifiedName[packageName] || {};\n\t\tprogramContext.canonicalByQualifiedName[packageName] = pack;\n\t\tfor (let definition of source.definitions) {\n\t\t\tif (definition.tag === \"impl-definition\") {\n\t\t\t\t// These are instead collected in `resolveSourceContext`.\n\t\t\t} else {\n\t\t\t\tcollectInterfaceRecordEntity(programContext, pack, packageName, sourceID, definition);\n\t\t\t}\n\t\t}\n\t}\n\treturn programContext;\n}\n\ninterface TypeVariableBinding {\n\tbindingLocation: ir.SourceLocation,\n\tvariable: ir.TypeVariable,\n}\n\ninterface TypeScopeI<This extends ir.Type | null> {\n\tthisType: This,\n\n\t/// `typeVariables` maps from the `TypeVarToken.name` to the ID in IR.\n\ttypeVariables: Map<ir.TypeVariableID, TypeVariableBinding>,\n\ttypeVariableList: ir.TypeVariableID[],\n\n\tconstraints: TypeArgumentConstraint[],\n}\n\ninterface TypeArgumentConstraint {\n\tconstraint: ir.ConstraintParameter,\n\tlocation: ir.SourceLocation,\n}\n\ntype TypeScope = TypeScopeI<ir.Type | null>;\n\n/// RETURNS the canonicalized version of the given entity name within the given\n/// source context.\nfunction resolveEntity(\n\tt: grammar.TypeNamed,\n\tsourceContext: Readonly<SourceContext>\n): string {\n\tif (t.packageQualification !== null) {\n\t\tconst namespaceQualifier = t.packageQualification.package.name;\n\t\tconst namespace = sourceContext.namespaces[namespaceQualifier];\n\t\tif (!namespace) {\n\t\t\tthrow new diagnostics.NoSuchPackageErr({\n\t\t\t\tpackageName: namespaceQualifier,\n\t\t\t\treference: t.packageQualification.location,\n\t\t\t});\n\t\t}\n\n\t\tconst entitiesInNamespace = sourceContext.programContext.canonicalByQualifiedName[namespaceQualifier];\n\t\tconst canonicalName = entitiesInNamespace[t.entity.name];\n\t\tif (!canonicalName) {\n\t\t\tthrow new diagnostics.NoSuchEntityErr({\n\t\t\t\tentityName: namespace.packageName + \".\" + t.entity.name,\n\t\t\t\treference: t.entity.location,\n\t\t\t});\n\t\t}\n\t\treturn canonicalName;\n\t} else {\n\t\tconst bound = sourceContext.entityAliases[t.entity.name];\n\t\tif (!bound) {\n\t\t\tthrow new diagnostics.NoSuchEntityErr({\n\t\t\t\tentityName: t.entity.name,\n\t\t\t\treference: t.entity.location,\n\t\t\t});\n\t\t}\n\t\treturn bound.canonicalName;\n\t}\n}\n\nfunction compileConstraint(\n\t// TODO: Use a `grammar.TypeConstraint` instead.\n\tc: grammar.TypeNamed,\n\tmethodSubject: ir.Type,\n\tsourceContext: Readonly<SourceContext>,\n\tscope: TypeScope,\n\tcheckConstraints: \"check\" | \"skip\" | \"skip-internal\",\n\t/// The location of the constraint, including the method subject.\n\tconstraintLocation: ir.SourceLocation,\n): ir.ConstraintParameter {\n\tconst programContext = sourceContext.programContext;\n\tif (programContext.uncheckedConstraints !== null) {\n\t\tif (checkConstraints === \"skip\") {\n\t\t\tprogramContext.uncheckedConstraints.push({\n\t\t\t\tc,\n\t\t\t\tmethodSubject,\n\t\t\t\tsourceContext,\n\t\t\t\tscope,\n\t\t\t\tconstraintLocation,\n\t\t\t});\n\t\t\tcheckConstraints = \"skip-internal\";\n\t\t}\n\t} else if (checkConstraints !== \"check\") {\n\t\tthrow new Error(\"compileConstraint: invalid `checkConstraints` argument.\");\n\t}\n\n\t// Resolve the entity.\n\tconst canonicalName = resolveEntity(c, sourceContext);\n\tconst interfaceEntity = programContext.getNamedEntity(canonicalName)!;\n\tif (interfaceEntity.tag !== \"interface\") {\n\t\tthrow new diagnostics.TypeUsedAsConstraintErr({\n\t\t\tname: canonicalName,\n\t\t\tkind: interfaceEntity.tag,\n\t\t\ttypeLocation: c.location,\n\t\t});\n\t}\n\n\tconst argumentSubjects = c.arguments.map(a =>\n\t\tcompileType(a, scope, sourceContext, checkConstraints));\n\n\tif (checkConstraints === \"check\") {\n\t\tconst expectedLocations = [];\n\t\tfor (let [_, binding] of interfaceEntity.typeScope.typeVariables) {\n\t\t\texpectedLocations.push({\n\t\t\t\tlocation: binding.bindingLocation,\n\t\t\t});\n\t\t}\n\n\t\tif (c.arguments.length !== expectedLocations.length) {\n\t\t\tthrow new diagnostics.TypeParameterCountMismatchErr({\n\t\t\t\tentityType: \"interface\",\n\t\t\t\tentityName: canonicalName,\n\t\t\t\texpectedCount: expectedLocations.length,\n\t\t\t\texpectedLocation: ir.locationsSpan(expectedLocations),\n\t\t\t\tgivenCount: c.arguments.length,\n\t\t\t\tgivenLocation: c.location,\n\t\t\t});\n\t\t}\n\n\t\tconst allArguments = [methodSubject, ...argumentSubjects];\n\t\tif (interfaceEntity.typeScope.typeVariableList[0] !== interfaceEntity.typeScope.thisType!.id) {\n\t\t\tthrow new Error(\"ICE: First InterfaceEntity type parameter must be `this` type\")\n\t\t}\n\t\tconst instantiation = ir.typeArgumentsMap(interfaceEntity.typeScope.typeVariableList, allArguments);\n\t\tconst thisType = interfaceEntity.typeScope.thisType;\n\t\tif (thisType === null) {\n\t\t\tthrow new Error(\"compileConstraint: InterfaceEntity thisType must be a type variable.\");\n\t\t}\n\t\tfor (const requirementBinding of interfaceEntity.typeScope.constraints) {\n\t\t\tconst genericConstraint = requirementBinding.constraint;\n\t\t\tconst instantiated: ir.ConstraintParameter = ir.constraintSubstitute(genericConstraint, instantiation);\n\t\t\tcheckConstraintSatisfied(instantiated, scope, sourceContext, {\n\t\t\t\tconstraintDeclaredAt: requirementBinding.location,\n\t\t\t\tneededAt: constraintLocation,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn {\n\t\tinterface: canonicalName as ir.InterfaceID,\n\t\tsubjects: [methodSubject, ...argumentSubjects],\n\t};\n}\n\nfunction allEqualTypes(a: ir.Type[], b: ir.Type[]): boolean {\n\tif (a.length !== b.length) {\n\t\tthrow new Error(\"length mismatch\");\n\t}\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (!ir.equalTypes(a[i], b[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction checkConstraintSatisfied(\n\trequiredConstraint: ir.ConstraintParameter,\n\ttypeScope: TypeScope,\n\tsourceContext: SourceContext,\n\t{ constraintDeclaredAt, neededAt }: {\n\t\tconstraintDeclaredAt: ir.SourceLocation | null,\n\t\tneededAt: ir.SourceLocation,\n\t},\n) {\n\tconst programContext = sourceContext.programContext;\n\tconst methodSubject = requiredConstraint.subjects[0];\n\tif (methodSubject === undefined) {\n\t\tthrow new Error(\"ICE: Constraint requires at least one subject.\");\n\t} else if (methodSubject.tag === \"type-compound\") {\n\t\tconst baseEntity = programContext.getDataEntity(methodSubject.base);\n\n\t\tconst implCandidates = baseEntity.implsByInterface.get(requiredConstraint.interface);\n\t\tfor (const impl of implCandidates) {\n\t\t\t// Check whether `impl.constraint` may be instantiated by replacing\n\t\t\t// `impl.typeScope`'s variables to become `requiredConstraint`.\n\t\t\tconst unifier = ir.unifyTypes(\n\t\t\t\timpl.typeScope.typeVariableList,\n\t\t\t\timpl.constraint.subjects,\n\t\t\t\t[],\n\t\t\t\trequiredConstraint.subjects,\n\t\t\t);\n\n\t\t\tif (unifier !== null) {\n\t\t\t\t// This instantiation was possible.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// No implementation was found in the record entity.\n\t} else if (methodSubject.tag === \"type-variable\") {\n\t\t// Consult the typeScope.\n\t\tfor (const { constraint } of typeScope.constraints) {\n\t\t\tif (allEqualTypes(constraint.subjects, requiredConstraint.subjects)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// No implementation was found in the type scope.\n\t} else if (methodSubject.tag === \"type-primitive\") {\n\t\t// TODO: Defer to the \"built in\" set of constraints (Eq, etc).\n\t} else if (methodSubject.tag === \"type-any\") {\n\t\t// TODO: Emit a custom message indicating that a cast is required.\n\t} else {\n\t\tconst _: never = methodSubject;\n\t\tthrow new Error(\"checkConstraintSatisfied: Unhandled methodSubject tag `\" + methodSubject[\"tag\"] + \"`\");\n\t}\n\n\tthrow new diagnostics.TypesDontSatisfyConstraintErr({\n\t\tneededConstraint: displayConstraint(requiredConstraint),\n\t\tneededLocation: neededAt,\n\t\tconstraintLocation: constraintDeclaredAt,\n\t});\n}\n\n/// `compileType` transforms an AST type into an IR type.\n/// When `checkConstraints` is `\"check\"`, type arguments must satisfy the\n/// constraints indicated by the base type. However, this cannot be `\"skip\"`\n/// until `ProgramContext.hasCollectedMembers` becomes `true`.\nfunction compileType(\n\tt: grammar.Type,\n\tscope: TypeScope,\n\tsourceContext: Readonly<SourceContext>,\n\tcheckConstraints: \"check\" | \"skip\" | \"skip-internal\",\n): ir.Type {\n\tif (sourceContext.programContext.uncheckedTypes !== null) {\n\t\tif (checkConstraints === \"skip\") {\n\t\t\tsourceContext.programContext.uncheckedTypes.push({\n\t\t\t\tt, scope, sourceContext\n\t\t\t});\n\t\t\tcheckConstraints = \"skip-internal\";\n\t\t}\n\t} else if (checkConstraints !== \"check\") {\n\t\tthrow new Error(\"compileType: invalid `checkConstraints` argument\");\n\t}\n\n\tif (t.tag === \"type-keyword\") {\n\t\tif (t.keyword === \"This\") {\n\t\t\tif (scope.thisType === null) {\n\t\t\t\tthrow new diagnostics.InvalidThisTypeErr({\n\t\t\t\t\treferenced: t.location,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn scope.thisType;\n\t\t} else if (t.keyword === \"String\") {\n\t\t\treturn {\n\t\t\t\ttag: \"type-primitive\",\n\t\t\t\tprimitive: \"Bytes\",\n\t\t\t};\n\t\t} else if (t.keyword === \"Any\") {\n\t\t\treturn ir.T_ANY;\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttag: \"type-primitive\",\n\t\t\t\tprimitive: t.keyword,\n\t\t\t};\n\t\t}\n\t} else if (t.tag === \"named\") {\n\t\t// Resolve the entity.\n\t\tconst canonicalName = resolveEntity(t, sourceContext);\n\t\tconst entity = sourceContext.programContext.getNamedEntity(canonicalName)!;\n\t\tif (entity.tag === \"interface\") {\n\t\t\tthrow new diagnostics.NonTypeEntityUsedAsTypeErr({\n\t\t\t\tentity: canonicalName,\n\t\t\t\tentityTag: entity.tag,\n\t\t\t\tuseLocation: t.entity.location,\n\t\t\t\tentityBinding: entity.bindingLocation,\n\t\t\t});\n\t\t}\n\n\t\tconst typeArguments = t.arguments.map(a =>\n\t\t\tcompileType(a, scope, sourceContext, checkConstraints));\n\n\t\tif (checkConstraints === \"check\") {\n\t\t\tconst expectedTypeParameterCount = entity.typeScope.typeVariableList.length;\n\t\t\tif (typeArguments.length !== expectedTypeParameterCount) {\n\t\t\t\tconst typeVariableLocations = [];\n\t\t\t\tfor (let [_, binding] of entity.typeScope.typeVariables) {\n\t\t\t\t\ttypeVariableLocations.push({\n\t\t\t\t\t\tlocation: binding.bindingLocation,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthrow new diagnostics.TypeParameterCountMismatchErr({\n\t\t\t\t\tentityType: \"record\",\n\t\t\t\t\tentityName: t.entity.name,\n\t\t\t\t\texpectedCount: expectedTypeParameterCount,\n\t\t\t\t\texpectedLocation: ir.locationsSpan(typeVariableLocations),\n\t\t\t\t\tgivenCount: t.arguments.length,\n\t\t\t\t\tgivenLocation: t.location,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst instantiation = ir.typeArgumentsMap(entity.typeScope.typeVariableList, typeArguments);\n\t\t\tfor (let requirementBinding of entity.typeScope.constraints) {\n\t\t\t\tconst instantiated = ir.constraintSubstitute(requirementBinding.constraint, instantiation);\n\t\t\t\tcheckConstraintSatisfied(instantiated, scope, sourceContext, {\n\t\t\t\t\tconstraintDeclaredAt: requirementBinding.location,\n\t\t\t\t\tneededAt: t.location,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttag: \"type-compound\",\n\t\t\tbase: canonicalName as ir.RecordID | ir.EnumID,\n\t\t\ttype_arguments: typeArguments,\n\t\t};\n\t} else if (t.tag === \"type-var\") {\n\t\tconst id = scope.typeVariables.get(t.name as ir.TypeVariableID);\n\t\tif (id === undefined) {\n\t\t\tthrow new diagnostics.NoSuchTypeVariableErr({\n\t\t\t\ttypeVariableName: t.name,\n\t\t\t\tlocation: t.location,\n\t\t\t});\n\t\t}\n\t\treturn id.variable;\n\t}\n\n\tconst _: never = t;\n\tthrow new Error(\"compileType: unhandled tag `\" + t[\"tag\"] + \"`\");\n}\n\n/// `resolveImport` MODIFIES the given `sourceContext` to include the\n/// entity or namespace introduced by the given import.\nfunction resolveImport(\n\timported: grammar.ImportOfObject | grammar.ImportOfPackage,\n\tsourcePackage: grammar.PackageDef,\n\tsourceContext: Readonly<SourceContext>,\n\tprogramContext: ProgramContext) {\n\tif (imported.tag === \"of-object\") {\n\t\tconst packageName = imported.packageName.name;\n\t\tconst packageEntities = programContext.canonicalByQualifiedName[packageName];\n\t\tif (packageEntities === undefined) {\n\t\t\tthrow new diagnostics.NoSuchPackageErr({\n\t\t\t\tpackageName,\n\t\t\t\treference: imported.packageName.location,\n\t\t\t});\n\t\t}\n\t\tconst entityName = imported.objectName.name;\n\t\tconst canonicalName = packageEntities[entityName];\n\t\tif (canonicalName === undefined) {\n\t\t\tthrow new diagnostics.NoSuchEntityErr({\n\t\t\t\tentityName: `${packageName}.${entityName}`,\n\t\t\t\treference: imported.location,\n\t\t\t});\n\t\t}\n\t\tif (sourceContext.entityAliases[entityName] !== undefined) {\n\t\t\tthrow new diagnostics.EntityRedefinedErr({\n\t\t\t\tname: entityName,\n\t\t\t\tfirstBinding: sourceContext.entityAliases[entityName].bindingLocation,\n\t\t\t\tsecondBinding: imported.objectName.location,\n\t\t\t});\n\t\t}\n\t\tsourceContext.entityAliases[entityName] = {\n\t\t\tcanonicalName,\n\t\t\tbindingLocation: imported.objectName.location,\n\t\t};\n\t} else if (imported.tag === \"of-package\") {\n\t\tconst packageName = imported.packageName.name;\n\t\tif (packageName === sourcePackage.packageName.name) {\n\t\t\tthrow new diagnostics.NamespaceAlreadyDefinedErr({\n\t\t\t\tnamespace: packageName,\n\t\t\t\tfirstBinding: sourcePackage.packageName.location,\n\t\t\t\tsecondBinding: imported.packageName.location,\n\t\t\t});\n\t\t} else if (sourceContext.namespaces[packageName] !== undefined) {\n\t\t\tthrow new diagnostics.NamespaceAlreadyDefinedErr({\n\t\t\t\tnamespace: packageName,\n\t\t\t\tfirstBinding: sourceContext.namespaces[packageName].bindingLocation,\n\t\t\t\tsecondBinding: imported.packageName.location,\n\t\t\t});\n\t\t}\n\t\tsourceContext.namespaces[packageName] = {\n\t\t\tpackageName,\n\t\t\tbindingLocation: imported.packageName.location,\n\t\t};\n\t}\n}\n\nfunction resolveSourceContext(\n\tsourceID: string,\n\tsource: grammar.Source,\n\tprogramContext: ProgramContext,\n) {\n\tconst packageName = source.package.packageName.name;\n\tconst pack = programContext.canonicalByQualifiedName[packageName];\n\n\tconst sourceContext: SourceContext = {\n\t\tentityAliases: {},\n\t\tnamespaces: {},\n\t\timplASTs: [],\n\t\tprogramContext,\n\t};\n\n\tfor (const definition of source.definitions) {\n\t\tif (definition.tag === \"impl-definition\") {\n\t\t\t// impls will only be processed after all available types have been\n\t\t\t// resolved.\n\t\t\tsourceContext.implASTs.push(definition);\n\t\t}\n\t}\n\n\t// Bring all entities defined within this package into scope.\n\tfor (let entityName in pack) {\n\t\tconst canonicalName = pack[entityName];\n\t\tconst binding = programContext.getNamedEntity(canonicalName)!;\n\t\tsourceContext.entityAliases[entityName] = {\n\t\t\tcanonicalName,\n\t\t\tbindingLocation: binding.bindingLocation,\n\t\t};\n\t}\n\n\t// Bring all imports into scope.\n\tfor (const { imported } of source.imports) {\n\t\tresolveImport(imported, source.package, sourceContext, programContext);\n\t}\n\n\tprogramContext.sourceContexts[sourceID] = sourceContext;\n}\n\nfunction collectTypeScope(\n\tsourceContext: SourceContext,\n\ttypeScope: TypeScope,\n\ttypeParameters: grammar.TypeParameters,\n): void {\n\tfor (const parameter of typeParameters.parameters) {\n\t\tconst id = parameter.name as ir.TypeVariableID;\n\t\tconst existingBinding = typeScope.typeVariables.get(id);\n\t\tif (existingBinding !== undefined) {\n\t\t\tthrow new diagnostics.TypeVariableRedefinedErr({\n\t\t\t\ttypeVariableName: parameter.name,\n\t\t\t\tfirstBinding: existingBinding.bindingLocation,\n\t\t\t\tsecondBinding: parameter.location,\n\t\t\t});\n\t\t}\n\t\ttypeScope.typeVariables.set(id, {\n\t\t\tvariable: { tag: \"type-variable\", id },\n\t\t\tbindingLocation: parameter.location,\n\t\t});\n\t\ttypeScope.typeVariableList.push(parameter.name as ir.TypeVariableID);\n\t}\n\tfor (let c of typeParameters.constraints) {\n\t\tconst methodSubject = compileType(c.methodSubject, typeScope,\n\t\t\tsourceContext, \"skip\")\n\t\tconst constraint = compileConstraint(c.constraint, methodSubject,\n\t\t\tsourceContext, typeScope, \"skip\", c.location);\n\t\ttypeScope.constraints.push({\n\t\t\tconstraint,\n\t\t\tlocation: c.location,\n\t\t});\n\t}\n}\n\n/// Collects enough information to determine which types satisfy which\n/// interfaces, so that types collected in `collectMembers` can be ensured to be\n/// valid.\nfunction resolveAvailableTypes(\n\tprogramContext: ProgramContext,\n\tentity: NamedEntityDef,\n) {\n\tif (entity.tag === \"record\") {\n\t\tcollectTypeScope(programContext.sourceContexts[entity.sourceID],\n\t\t\tentity.typeScope, entity.ast.typeParameters);\n\t\treturn;\n\t} else if (entity.tag === \"enum\") {\n\t\tcollectTypeScope(programContext.sourceContexts[entity.sourceID],\n\t\t\tentity.typeScope, entity.ast.typeParameters);\n\t\treturn;\n\t} else if (entity.tag === \"interface\") {\n\t\tcollectTypeScope(programContext.sourceContexts[entity.sourceID],\n\t\t\tentity.typeScope, entity.ast.typeParameters);\n\t\treturn;\n\t}\n\n\tconst _: never = entity;\n\tthrow new Error(\"collectTypeScopesAndConstraints: unhandled tag `\" + entity[\"tag\"] + \"`\");\n}\n\nfunction resolveMemberFn(\n\tcanonicalName: ir.FunctionID,\n\tfn: grammar.Fn,\n\tentityTypeScope: TypeScopeI<ir.TypeCompound>,\n\tsourceContext: SourceContext,\n): FnBinding {\n\n\tconst parameterTypes = fn.signature.parameters.list.map(p => ({\n\t\tt: compileType(p.t, entityTypeScope, sourceContext, \"check\"),\n\t\tnameLocation: p.name.location,\n\t\ttypeLocation: p.t.location,\n\t}));\n\n\tconst returnTypes = fn.signature.returns.map(r => ({\n\t\tt: compileType(r, entityTypeScope, sourceContext, \"check\"),\n\t\tnameLocation: r.location,\n\t\ttypeLocation: r.location,\n\t}));\n\n\treturn {\n\t\ttag: \"fn-binding\",\n\t\tid: canonicalName,\n\n\t\tnameLocation: fn.signature.name.location,\n\t\tparameters: parameterTypes,\n\t\tparametersLocation: fn.signature.parameters.location,\n\t\treturns: returnTypes,\n\t\tast: fn,\n\n\t\tentityTypeVariables: entityTypeScope.typeVariableList,\n\t\tsignatureTypeVariables: [],\n\t};\n}\n\nfunction resolveRecordMemberSignatures(\n\tentity: RecordEntityDef,\n\tsourceContext: SourceContext,\n\tentityName: string,\n) {\n\t// Collect the defined fields.\n\tfor (let field of entity.ast.fields) {\n\t\tconst fieldName = field.name.name;\n\t\tconst existingField = entity.fields[fieldName];\n\t\tif (existingField !== undefined) {\n\t\t\tthrow new diagnostics.MemberRedefinedErr({\n\t\t\t\tmemberName: fieldName,\n\t\t\t\tfirstBinding: existingField.nameLocation,\n\t\t\t\tsecondBinding: field.name.location,\n\t\t\t});\n\t\t}\n\n\t\tconst fieldType = compileType(field.t,\n\t\t\tentity.typeScope, sourceContext, \"check\");\n\n\t\tentity.fields[fieldName] = {\n\t\t\tnameLocation: field.name.location,\n\t\t\tt: fieldType,\n\t\t\ttypeLocation: field.t.location,\n\t\t};\n\t}\n\n\t// Collect the defined methods.\n\tfor (let fn of entity.ast.fns) {\n\t\tconst fnName = fn.signature.name.name;\n\n\t\tconst existingField = entity.fields[fnName];\n\t\tif (existingField !== undefined) {\n\t\t\tthrow new diagnostics.MemberRedefinedErr({\n\t\t\t\tmemberName: fnName,\n\t\t\t\tfirstBinding: existingField.nameLocation,\n\t\t\t\tsecondBinding: fn.signature.name.location,\n\t\t\t});\n\t\t}\n\n\t\tconst existingFn = entity.fns[fnName];\n\t\tif (existingFn !== undefined) {\n\t\t\tthrow new diagnostics.MemberRedefinedErr({\n\t\t\t\tmemberName: fnName,\n\t\t\t\tfirstBinding: existingFn.nameLocation,\n\t\t\t\tsecondBinding: fn.signature.name.location,\n\t\t\t});\n\t\t}\n\n\t\tconst canonicalName = canonicalFunctionName(entityName, fnName);\n\t\tentity.fns[fnName] = resolveMemberFn(canonicalName, fn, entity.typeScope, sourceContext);\n\t}\n}\n\nfunction resolveEnumMemberSignatures(\n\tentity: EnumEntityDef,\n\tsourceContext: SourceContext,\n\tentityName: string,\n) {\n\t// Collect the defined variants.\n\tfor (const variant of entity.ast.variants) {\n\t\tconst variantName = variant.name.name;\n\t\tconst existingVariant = entity.variants[variantName];\n\t\tif (existingVariant !== undefined) {\n\t\t\tthrow new diagnostics.MemberRedefinedErr({\n\t\t\t\tmemberName: variantName,\n\t\t\t\tfirstBinding: existingVariant.nameLocation,\n\t\t\t\tsecondBinding: variant.name.location,\n\t\t\t});\n\t\t}\n\n\t\tconst variantType = compileType(variant.t,\n\t\t\tentity.typeScope, sourceContext, \"check\");\n\n\t\tentity.variants[variantName] = {\n\t\t\tnameLocation: variant.name.location,\n\t\t\tt: variantType,\n\t\t\ttypeLocation: variant.t.location,\n\t\t};\n\t}\n\n\t// Collect the defined methods.\n\tfor (const fn of entity.ast.fns) {\n\t\tconst fnName = fn.signature.name.name;\n\n\t\tconst existingVariant = entity.variants[fnName];\n\t\tif (existingVariant !== undefined) {\n\t\t\tthrow new diagnostics.MemberRedefinedErr({\n\t\t\t\tmemberName: fnName,\n\t\t\t\tfirstBinding: existingVariant.nameLocation,\n\t\t\t\tsecondBinding: fn.signature.name.location,\n\t\t\t});\n\t\t}\n\n\t\tconst existingFn = entity.fns[fnName];\n\t\tif (existingFn !== undefined) {\n\t\t\tthrow new diagnostics.MemberRedefinedErr({\n\t\t\t\tmemberName: fnName,\n\t\t\t\tfirstBinding: existingFn.nameLocation,\n\t\t\t\tsecondBinding: fn.signature.name.location,\n\t\t\t});\n\t\t}\n\n\t\tconst canonicalName = canonicalFunctionName(entityName, fnName);\n\t\tentity.fns[fnName] = resolveMemberFn(canonicalName, fn, entity.typeScope, sourceContext);\n\t}\n}\n\nfunction resolveInterfaceMemberSignatures(\n\tentity: InterfaceEntityDef,\n\tsourceContext: SourceContext,\n) {\n\t// Collect the defined methods.\n\tfor (const member of entity.ast.members) {\n\t\tconst fnName = member.signature.name.name;\n\t\tconst existingFn = entity.fns[fnName];\n\t\tif (existingFn !== undefined) {\n\t\t\tthrow new diagnostics.MemberRedefinedErr({\n\t\t\t\tmemberName: fnName,\n\t\t\t\tfirstBinding: existingFn.nameLocation,\n\t\t\t\tsecondBinding: member.signature.name.location,\n\t\t\t});\n\t\t}\n\n\t\tconst parameterTypes = member.signature.parameters.list.map(p => ({\n\t\t\tt: compileType(p.t, entity.typeScope, sourceContext, \"check\"),\n\t\t\tnameLocation: p.name.location,\n\t\t\ttypeLocation: p.t.location,\n\t\t}));\n\n\t\tconst returnTypes = member.signature.returns.map(r => ({\n\t\t\tt: compileType(r, entity.typeScope, sourceContext, \"check\"),\n\t\t\tnameLocation: r.location,\n\t\t\ttypeLocation: r.location,\n\t\t}));\n\n\t\tentity.fns[fnName] = {\n\t\t\ttag: \"vtable-binding\",\n\t\t\tsignature_id: fnName,\n\n\t\t\tnameLocation: member.signature.name.location,\n\t\t\tparameters: parameterTypes,\n\t\t\tparametersLocation: member.signature.parameters.location,\n\t\t\treturns: returnTypes,\n\t\t\tast: member,\n\t\t\tinterfaceTypeVariables: entity.typeScope.typeVariableList,\n\t\t\tsignatureTypeVariables: [],\n\t\t};\n\t}\n}\n\n/// Collects the \"signatures\" such that references to this entity within the\n/// bodies of other entities can be type-checked.\n/// Constraints must have already been collected in all entities using\n/// `collectTypeScopesAndConstraints` prior to invoking `collectMembers`.\n/// NOTE that this does NOT include compiling \"requires\" and \"ensures\" clauses,\n/// which are compiled alongside function bodies in a later pass.\nfunction resolveMemberSignatures(\n\tprogramContext: ProgramContext,\n\tentityName: string,\n\tentity: NamedEntityDef,\n) {\n\tconst sourceContext = programContext.sourceContexts[entity.sourceID];\n\tif (entity.tag === \"record\") {\n\t\tresolveRecordMemberSignatures(entity, sourceContext, entityName);\n\t\treturn;\n\t} else if (entity.tag === \"enum\") {\n\t\tresolveEnumMemberSignatures(entity, sourceContext, entityName);\n\t\treturn;\n\t} else if (entity.tag === \"interface\") {\n\t\tresolveInterfaceMemberSignatures(entity, sourceContext);\n\t\treturn;\n\t}\n\n\tconst _: never = entity;\n\tthrow new Error(\"collectMembers: unhandled tag `\" + entity[\"tag\"] + \"`\");\n}\n\nfunction canonicalFunctionName(entityName: string, memberName: string): ir.FunctionID {\n\treturn entityName + \".\" + memberName as ir.FunctionID;\n}\n\ninterface FunctionContext {\n\t/// `returnsTo` indicates the types that an `op-return` returns to,\n\t/// and where those return types can be found annotated in the source.\n\treturnsTo: { t: ir.Type, location: ir.SourceLocation }[],\n\n\t/// `ensuresReturnExpression` indicates the variables  that a `return`\n\t/// expression refers to. It is `null` if a `return` expression is not valid\n\t/// in the given context (i.e., it's not in an `ensures` clause).\n\tensuresReturnExpression: null | ValueInfo,\n\n\tsourceContext: SourceContext,\n}\n\ninterface VariableBinding {\n\tlocalName: string,\n\tbindingLocation: ir.SourceLocation,\n\tt: ir.Type,\n\tcurrentValue: ir.VariableID,\n}\n\ninterface VariableStackInfo {\n\tbindingLocation: ir.SourceLocation,\n\tt: ir.Type,\n\tcurrentValue: ir.VariableID,\n\tblock: number,\n}\n\ninterface VariableStackBlock {\n\tstackStart: number,\n\tassignments: Record<string, { originalValue: ir.VariableID, latestValue: ir.VariableID }>,\n\tisProofBlock: boolean,\n}\n\nclass VariableStack {\n\tprivate variables: Record<string, VariableStackInfo> = {};\n\tprivate variableStack: string[] = [];\n\tprivate blocks: VariableStackBlock[] = [];\n\n\tprivate nextUnique = 1;\n\tuniqueID(hint: string): ir.VariableID {\n\t\tif (hint.indexOf(\"'\") >= 0) {\n\t\t\tthrow new Error(\"hint must not contain `'`\");\n\t\t}\n\t\tconst id = hint + \"'\" + this.nextUnique;\n\t\tthis.nextUnique += 1;\n\t\treturn id as ir.VariableID;\n\t}\n\n\tdefineLocal(\n\t\tlocal: string,\n\t\tt: ir.Type,\n\t\tlocation: ir.SourceLocation,\n\t\tinitialValue: ir.VariableID,\n\t) {\n\t\tconst existing = this.variables[local];\n\t\tif (existing !== undefined) {\n\t\t\tthrow new diagnostics.VariableRedefinedErr({\n\t\t\t\tname: local,\n\t\t\t\tfirstLocation: existing.bindingLocation,\n\t\t\t\tsecondLocation: location,\n\t\t\t});\n\t\t}\n\t\tthis.variables[local] = {\n\t\t\tbindingLocation: location,\n\t\t\tt,\n\t\t\tcurrentValue: initialValue,\n\t\t\tblock: this.blocks.length,\n\t\t};\n\t\tthis.variableStack.push(local);\n\t}\n\n\t/// THROWS SemanticError when a variable of this name is not in scope.\n\tresolve(local: lexer.IdenToken): VariableBinding {\n\t\tconst def = this.variables[local.name];\n\t\tif (def === undefined) {\n\t\t\tthrow new diagnostics.VariableNotDefinedErr({\n\t\t\t\tname: local.name,\n\t\t\t\treferencedAt: local.location,\n\t\t\t});\n\t\t}\n\t\treturn {\n\t\t\tlocalName: local.name,\n\t\t\tbindingLocation: def.bindingLocation,\n\t\t\tt: def.t,\n\t\t\tcurrentValue: def.currentValue,\n\t\t};\n\t}\n\n\t/// `openBlock(proofBlock)` opens a new scope. Variables added after this\n\t/// call will be deleted when a corresponding `closeBlock()` call is made.\n\t/// If `proofBlock` is `true`, `isInProofBlock()` will return `true` until\n\t/// the corresponding `closeBlock()` call is made.\n\topenBlock(proofBlock: boolean) {\n\t\tthis.blocks.push({\n\t\t\tstackStart: this.variableStack.length,\n\t\t\tassignments: {},\n\t\t\tisProofBlock: proofBlock || this.isInProofBlock(),\n\t\t});\n\t}\n\n\t/// `isInProofBlock()` returns `true` when a currently open block passed\n\t/// `true` as the parameter to `openBlock`.\n\tisInProofBlock(): boolean {\n\t\tconst top = this.blocks[this.blocks.length - 1];\n\t\treturn top !== undefined && top.isProofBlock;\n\t}\n\n\tupdateLocal(local: string, newValue: ir.VariableID) {\n\t\tconst variable = this.variables[local];\n\t\tif (variable.block < this.blocks.length) {\n\t\t\tconst currentBlock = this.blocks[this.blocks.length - 1];\n\t\t\tif (currentBlock.assignments[local] === undefined) {\n\t\t\t\tcurrentBlock.assignments[local] = {\n\t\t\t\t\toriginalValue: variable.currentValue,\n\t\t\t\t\tlatestValue: newValue,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tcurrentBlock.assignments[local].latestValue = newValue;\n\t\t\t}\n\t\t}\n\t\tvariable.currentValue = newValue;\n\t}\n\n\t/// RETURNS the assignments made to Shiru local variables that live longer\n\t/// than this block.\n\tcloseBlock(): Record<string, ir.VariableID> {\n\t\tconst block = this.blocks.pop();\n\t\tif (block === undefined) throw new Error(\"block is not open\");\n\t\tconst removed = this.variableStack.splice(block.stackStart);\n\t\tfor (const r of removed) {\n\t\t\tdelete this.variables[r];\n\t\t}\n\n\t\tconst assignments: Record<string, ir.VariableID> = {};\n\t\tfor (const k in block.assignments) {\n\t\t\t// Revert the variable to its assignment before the block, but return\n\t\t\t// the current assignment (for branching).\n\t\t\tconst status = block.assignments[k];\n\t\t\tthis.variables[k].currentValue = status.originalValue;\n\t\t\tassignments[k] = status.latestValue;\n\t\t}\n\t\treturn assignments;\n\t}\n}\n\ninterface ValueInfo {\n\tvalues: ir.VariableDefinition[],\n\tlocation: ir.SourceLocation,\n}\n\nfunction compileCall(\n\tops: ir.Op[],\n\tstack: VariableStack,\n\targs: ValueInfo[],\n\tfn: FnBinding | InterfaceFnBinding,\n\n\t/// An assignment for all the signatureTypeVariables and\n\t/// entityTypeVariables/interfaceTypeVariables.\n\ttypeArgumentMapping: Map<ir.TypeVariableID, ir.Type>,\n\n\tlocation: ir.SourceLocation,\n\tconstraint: ir.ConstraintParameter | null,\n): ValueInfo {\n\tconst argValues = [];\n\tfor (const tuple of args) {\n\t\tfor (let i = 0; i < tuple.values.length; i++) {\n\t\t\targValues.push({ tuple, i });\n\t\t}\n\t}\n\n\tif (argValues.length !== fn.parameters.length) {\n\t\tthrow new diagnostics.ValueCountMismatchErr({\n\t\t\tactualCount: argValues.length,\n\t\t\tactualLocation: ir.locationsSpan(args),\n\t\t\texpectedCount: fn.parameters.length,\n\t\t\texpectedLocation: fn.parametersLocation,\n\t\t});\n\t}\n\n\tconst argumentSources = [];\n\tfor (let i = 0; i < argValues.length; i++) {\n\t\tconst value = argValues[i];\n\t\tconst valueType = value.tuple.values[value.i].type;\n\t\tconst templateType = fn.parameters[i].t;\n\n\t\tconst expectedType = ir.typeSubstitute(templateType, typeArgumentMapping);\n\n\t\tif (!ir.equalTypes(expectedType, valueType)) {\n\t\t\tthrow new diagnostics.TypeMismatchErr({\n\t\t\t\tgivenType: displayType(valueType),\n\t\t\t\tgivenLocation: value.tuple.location,\n\t\t\t\tgivenIndex: {\n\t\t\t\t\tindex0: value.i,\n\t\t\t\t\tcount: value.tuple.values.length,\n\t\t\t\t},\n\t\t\t\texpectedType: displayType(expectedType),\n\t\t\t\texpectedLocation: fn.parameters[i].nameLocation,\n\t\t\t});\n\t\t}\n\t\targumentSources.push(value.tuple.values[value.i].variable);\n\t}\n\n\tconst destinations: ir.VariableDefinition[] = [];\n\tfor (let i = 0; i < fn.returns.length; i++) {\n\t\tconst templateType = fn.returns[i].t;\n\t\tconst returnType = ir.typeSubstitute(templateType, typeArgumentMapping);\n\n\t\tconst destination = stack.uniqueID(\"fncall\" + i);\n\t\tdestinations.push({\n\t\t\tvariable: destination,\n\t\t\ttype: returnType,\n\t\t\tlocation,\n\t\t});\n\t}\n\n\n\tif (fn.tag === \"fn-binding\") {\n\t\tconst typeArgumentList = [];\n\t\tfor (const typeParameter of fn.entityTypeVariables) {\n\t\t\ttypeArgumentList.push(typeArgumentMapping.get(typeParameter)!);\n\t\t}\n\t\tfor (const typeParameter of fn.signatureTypeVariables) {\n\t\t\ttypeArgumentList.push(typeArgumentMapping.get(typeParameter)!);\n\t\t}\n\n\t\tops.push({\n\t\t\ttag: \"op-static-call\",\n\t\t\tfunction: fn.id,\n\n\t\t\targuments: argumentSources,\n\t\t\ttype_arguments: typeArgumentList,\n\t\t\tdestinations: destinations,\n\n\t\t\tdiagnostic_callsite: location,\n\t\t});\n\n\t\tif (constraint !== null) {\n\t\t\tthrow new Error(\"compileCall: expected `null` constraint for fn-binding\")\n\t\t}\n\t} else {\n\t\tif (constraint === null) {\n\t\t\tthrow new Error(\"compileCall: expected non-null constraint for vtable-binding\");\n\t\t}\n\n\t\tconst typeArgumentList = [];\n\t\tfor (const typeParameter of fn.signatureTypeVariables) {\n\t\t\ttypeArgumentList.push(typeArgumentMapping.get(typeParameter)!);\n\t\t}\n\n\t\tops.push({\n\t\t\ttag: \"op-dynamic-call\",\n\t\t\tconstraint,\n\t\t\tsignature_id: fn.signature_id,\n\n\t\t\targuments: argumentSources,\n\t\t\tsignature_type_arguments: typeArgumentList,\n\t\t\tdestinations,\n\n\t\t\tdiagnostic_callsite: location,\n\t\t});\n\t}\n\n\treturn {\n\t\tvalues: destinations,\n\t\tlocation: location,\n\t};\n}\n\nfunction compileTypeCallExpression(\n\te: grammar.ExpressionTypeCall,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext,\n): ValueInfo {\n\tconst baseType = compileType(e.t, typeScope, context.sourceContext, \"check\");\n\tif (baseType.tag !== \"type-compound\") {\n\t\tthrow new diagnostics.CallOnNonCompoundErr({\n\t\t\tbaseType: displayType(baseType),\n\t\t\tlocation: e.t.location,\n\t\t});\n\t}\n\n\tconst base = context.sourceContext.programContext.getDataEntity(baseType.base);\n\tconst fn = base.fns[e.methodName.name];\n\tif (fn === undefined) {\n\t\tthrow new diagnostics.NoSuchFnErr({\n\t\t\tbaseType: displayType(baseType),\n\t\t\tmethodName: e.methodName.name,\n\t\t\tmethodNameLocation: e.methodName.location,\n\t\t});\n\t}\n\n\tconst args = [];\n\tfor (const arg of e.arguments) {\n\t\targs.push(compileExpression(arg, ops, stack, typeScope, context));\n\t}\n\n\tconst typeArgumentMapping: Map<ir.TypeVariableID, ir.Type> = new Map();\n\tif (fn.signatureTypeVariables.length !== 0) {\n\t\tthrow new Error(\"TODO: Handle member-scoped type arguments.\");\n\t}\n\tfor (let i = 0; i < baseType.type_arguments.length; i++) {\n\t\ttypeArgumentMapping.set(fn.entityTypeVariables[i], baseType.type_arguments[i]);\n\t}\n\treturn compileCall(ops, stack, args, fn, typeArgumentMapping, e.location, null);\n}\n\nfunction compileConstraintCallExpression(\n\te: grammar.ExpressionConstraintCall,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext,\n): ValueInfo {\n\tconst subject = compileType(e.constraint.subject, typeScope, context.sourceContext, \"check\");\n\tconst constraint = compileConstraint(e.constraint.constraint, subject, context.sourceContext, typeScope, \"check\", e.constraint.location);\n\n\tcheckConstraintSatisfied(constraint, typeScope, context.sourceContext, {\n\t\tneededAt: e.constraint.location,\n\t\tconstraintDeclaredAt: null,\n\t});\n\n\tconst int = context.sourceContext.programContext.getInterface(constraint.interface);\n\tconst fn = int.fns[e.methodName.name];\n\tif (fn === undefined) {\n\t\tthrow new diagnostics.NoSuchFnErr({\n\t\t\tbaseType: displayConstraint(constraint),\n\t\t\tmethodName: e.methodName.name,\n\t\t\tmethodNameLocation: e.methodName.location,\n\t\t});\n\t}\n\n\tconst args = [];\n\tfor (const arg of e.arguments) {\n\t\targs.push(compileExpression(arg, ops, stack, typeScope, context));\n\t}\n\n\tconst typeArgumentMapping = new Map<ir.TypeVariableID, ir.Type>();\n\tfor (let i = 0; i < constraint.subjects.length; i++) {\n\t\ttypeArgumentMapping.set(fn.interfaceTypeVariables[i], constraint.subjects[i]);\n\t}\n\tif (fn.signatureTypeVariables.length !== 0) {\n\t\tthrow new Error(\"TODO: Handle member scoped dynamic type arguments\");\n\t}\n\treturn compileCall(ops, stack, args, fn, typeArgumentMapping, e.location, constraint);\n}\n\nfunction compileEnumLiteral(\n\tbaseEntity: EnumEntityDef,\n\tbaseType: ir.TypeCompound,\n\tinitializations: Record<string, ValueInfo & { fieldLocation: ir.SourceLocation }>,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\tlocation: ir.SourceLocation,\n): ValueInfo {\n\tconst variants: Record<string, ir.VariableID> = {};\n\tlet first = null;\n\tfor (let provided in initializations) {\n\t\tconst initialization = initializations[provided];\n\t\tif (first !== null) {\n\t\t\tthrow new diagnostics.MultipleVariantsErr({\n\t\t\t\tenumType: displayType(baseType),\n\t\t\t\tfirstVariant: first.name,\n\t\t\t\tfirstLocation: first.location,\n\t\t\t\tsecondVariant: provided,\n\t\t\t\tsecondLocation: initialization.fieldLocation,\n\t\t\t});\n\t\t}\n\t\tfirst = { name: provided, location: initialization.fieldLocation };\n\n\t\tvariants[provided] = initialization.values[0].variable;\n\t}\n\n\tif (first === null) {\n\t\tthrow new diagnostics.EnumLiteralMissingVariantErr({\n\t\t\tenumType: displayType(baseType),\n\t\t\tlocation,\n\t\t});\n\t}\n\n\tconst destination = {\n\t\tvariable: stack.uniqueID(\"enum\" + baseType.base),\n\t\ttype: baseType,\n\t\tlocation,\n\t};\n\n\tops.push({\n\t\ttag: \"op-new-enum\",\n\t\tenum: baseType.base as ir.EnumID,\n\t\tdestination,\n\t\tvariant: first.name,\n\t\tvariantValue: variants[first.name],\n\t});\n\n\treturn {\n\t\tvalues: [destination],\n\t\tlocation,\n\t};\n}\n\nfunction compileRecordLiteral(\n\tbaseEntity: RecordEntityDef,\n\tbaseType: ir.TypeCompound,\n\tinitializations: Record<string, ValueInfo & { fieldLocation: ir.SourceLocation }>,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\tlocation: ir.SourceLocation,\n): ValueInfo {\n\tconst fields: Record<string, ir.VariableID> = {};\n\tfor (let required in baseEntity.fields) {\n\t\tif (initializations[required] === undefined) {\n\t\t\tthrow new diagnostics.UninitializedFieldErr({\n\t\t\t\trecordType: displayType(baseType),\n\t\t\t\tmissingFieldName: required,\n\t\t\t\tdefinedLocation: baseEntity.fields[required].nameLocation,\n\t\t\t\tinitializerLocation: location,\n\t\t\t});\n\t\t}\n\t\tfields[required] = initializations[required].values[0].variable;\n\t}\n\n\tconst destination = {\n\t\tvariable: stack.uniqueID(\"record\" + baseType.base),\n\t\ttype: baseType,\n\t\tlocation,\n\t};\n\n\tops.push({\n\t\ttag: \"op-new-record\",\n\t\trecord: baseType.base as ir.RecordID,\n\t\tdestination: destination,\n\t\tfields,\n\t});\n\treturn {\n\t\tvalues: [destination],\n\t\tlocation,\n\t};\n}\n\nfunction compileCompoundLiteral(\n\te: grammar.ExpressionRecordLiteral,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext,\n): ValueInfo {\n\tconst t = compileType(e.t, typeScope, context.sourceContext, \"check\");\n\tif (t.tag !== \"type-compound\") {\n\t\tthrow new diagnostics.NonCompoundInRecordLiteralErr({\n\t\t\tt: displayType(t),\n\t\t\tlocation: e.t.location,\n\t\t});\n\t}\n\n\tconst programContext = context.sourceContext.programContext;\n\tconst baseEntity = programContext.getDataEntity(t.base);\n\n\tconst instantiation = ir.typeArgumentsMap(baseEntity.typeScope.typeVariableList, t.type_arguments);\n\tconst initializations: Record<string, ValueInfo & { fieldLocation: ir.SourceLocation }> = {};\n\tfor (let initAST of e.initializations) {\n\t\tconst fieldName = initAST.fieldName.name;\n\t\tif (initializations[fieldName] !== undefined) {\n\t\t\tthrow new diagnostics.MemberRepeatedInCompoundLiteralErr({\n\t\t\t\tkind: baseEntity.tag === \"enum\" ? \"variant\" : \"field\",\n\t\t\t\tfieldName,\n\t\t\t\tfirstLocation: initializations[fieldName].fieldLocation,\n\t\t\t\tsecondLocation: initAST.fieldName.location,\n\t\t\t});\n\t\t}\n\t\tconst fieldDefinition = baseEntity.tag === \"record\"\n\t\t\t? baseEntity.fields[fieldName]\n\t\t\t: baseEntity.variants[fieldName];\n\t\tif (fieldDefinition === undefined) {\n\t\t\tif (baseEntity.tag === \"record\") {\n\t\t\t\tthrow new diagnostics.NoSuchFieldErr({\n\t\t\t\t\tkind: \"initialization\",\n\t\t\t\t\trecordType: displayType(t),\n\t\t\t\t\tfieldName,\n\t\t\t\t\tlocation: initAST.fieldName.location,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthrow new diagnostics.NoSuchVariantErr({\n\t\t\t\t\tkind: \"initialization\",\n\t\t\t\t\tenumType: displayType(t),\n\t\t\t\t\tvariantName: fieldName,\n\t\t\t\t\tlocation: initAST.fieldName.location,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tconst value = compileExpression(initAST.value, ops, stack, typeScope, context);\n\t\tif (value.values.length !== 1) {\n\t\t\tthrow new diagnostics.MultiExpressionGroupedErr({\n\t\t\t\tlocation: value.location,\n\t\t\t\tvalueCount: value.values.length,\n\t\t\t\tgrouping: \"field-init\",\n\t\t\t});\n\t\t}\n\t\tconst givenType = value.values[0].type;\n\t\tconst expectedType = ir.typeSubstitute(fieldDefinition.t, instantiation);\n\n\t\tif (!ir.equalTypes(expectedType, givenType)) {\n\t\t\tthrow new diagnostics.TypeMismatchErr({\n\t\t\t\tgivenType: displayType(givenType),\n\t\t\t\tgivenLocation: value.location,\n\t\t\t\texpectedType: displayType(expectedType),\n\t\t\t\texpectedLocation: fieldDefinition.typeLocation,\n\t\t\t});\n\t\t}\n\n\t\tinitializations[fieldName] = {\n\t\t\t...value,\n\t\t\tfieldLocation: initAST.fieldName.location,\n\t\t};\n\t}\n\n\tif (baseEntity.tag === \"record\") {\n\t\treturn compileRecordLiteral(\n\t\t\tbaseEntity, t, initializations, ops, stack, e.location);\n\t} else {\n\t\treturn compileEnumLiteral(\n\t\t\tbaseEntity, t, initializations, ops, stack, e.location);\n\t}\n}\n\nfunction compileExpressionAtom(\n\te: grammar.ExpressionAtom,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext): ValueInfo {\n\tif (e.tag === \"iden\") {\n\t\tconst v = stack.resolve(e);\n\t\tconst destination = {\n\t\t\tvariable: stack.uniqueID(\"var\"),\n\t\t\ttype: v.t,\n\t\t\tlocation: e.location,\n\t\t};\n\t\tops.push({\n\t\t\ttag: \"op-copy\",\n\t\t\tcopies: [\n\t\t\t\t{\n\t\t\t\t\tsource: v.currentValue,\n\t\t\t\t\tdestination,\n\t\t\t\t}\n\t\t\t],\n\t\t});\n\t\treturn {\n\t\t\tvalues: [{\n\t\t\t\ttype: v.t,\n\t\t\t\tvariable: destination.variable,\n\t\t\t\tlocation: e.location,\n\t\t\t}],\n\t\t\tlocation: e.location,\n\t\t};\n\t} else if (e.tag === \"paren\") {\n\t\tconst component = compileExpression(e.expression, ops, stack, typeScope, context);\n\t\tif (component.values.length !== 1) {\n\t\t\tthrow new diagnostics.MultiExpressionGroupedErr({\n\t\t\t\tvalueCount: component.values.length,\n\t\t\t\tlocation: e.location,\n\t\t\t\tgrouping: \"parens\",\n\t\t\t});\n\t\t}\n\t\treturn component;\n\t} else if (e.tag === \"number-literal\") {\n\t\tconst destination = {\n\t\t\tvariable: stack.uniqueID(\"number\"),\n\t\t\ttype: ir.T_INT,\n\t\t\tlocation: e.location,\n\t\t};\n\t\tops.push({\n\t\t\ttag: \"op-const\",\n\t\t\tdestination,\n\t\t\ttype: \"Int\",\n\t\t\tint: e.int,\n\t\t});\n\t\treturn { values: [destination], location: e.location };\n\t} else if (e.tag === \"type-call\") {\n\t\treturn compileTypeCallExpression(e, ops, stack, typeScope, context);\n\t} else if (e.tag === \"constraint-call\") {\n\t\treturn compileConstraintCallExpression(e, ops, stack, typeScope, context);\n\t} else if (e.tag === \"keyword\") {\n\t\tif (e.keyword === \"false\" || e.keyword === \"true\") {\n\t\t\tconst destination = {\n\t\t\t\tvariable: stack.uniqueID(\"boolean\"),\n\t\t\t\ttype: ir.T_BOOLEAN,\n\t\t\t\tlocation: e.location,\n\t\t\t};\n\t\t\tops.push({\n\t\t\t\ttag: \"op-const\",\n\t\t\t\tdestination,\n\t\t\t\ttype: \"Boolean\",\n\t\t\t\tboolean: e.keyword === \"true\",\n\t\t\t});\n\t\t\treturn { values: [destination], location: e.location };\n\t\t} else if (e.keyword === \"return\") {\n\t\t\tif (context.ensuresReturnExpression === null) {\n\t\t\t\tthrow new diagnostics.ReturnExpressionUsedOutsideEnsuresErr({\n\t\t\t\t\treturnLocation: e.location,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst destinations = [];\n\t\t\tconst copies = [];\n\t\t\tfor (const source of context.ensuresReturnExpression.values) {\n\t\t\t\tconst destination = {\n\t\t\t\t\tvariable: stack.uniqueID(\"return\"),\n\t\t\t\t\ttype: source.type,\n\t\t\t\t\tlocation: e.location,\n\t\t\t\t};\n\t\t\t\tcopies.push({\n\t\t\t\t\tsource: source.variable,\n\t\t\t\t\tdestination,\n\t\t\t\t});\n\t\t\t\tdestinations.push(destination);\n\t\t\t}\n\t\t\tops.push({\n\t\t\t\ttag: \"op-copy\",\n\t\t\t\tcopies,\n\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tvalues: destinations,\n\t\t\t\tlocation: e.location,\n\t\t\t};\n\t\t} else {\n\t\t\tconst _: never = e.keyword;\n\t\t\tthrow new Error(\"compileExpressionAtom: keyword `\" + e[\"keyword\"] + \"`\");\n\t\t}\n\t} else if (e.tag === \"record-literal\") {\n\t\treturn compileCompoundLiteral(e, ops, stack, typeScope, context);\n\t} else if (e.tag === \"string-literal\") {\n\t\tconst destination = {\n\t\t\tvariable: stack.uniqueID(\"string\"),\n\t\t\ttype: ir.T_BYTES,\n\t\t\tlocation: e.location,\n\t\t};\n\t\tops.push({\n\t\t\ttag: \"op-const\",\n\t\t\tdestination,\n\t\t\ttype: \"Bytes\",\n\t\t\tbytes: e.value,\n\t\t});\n\t\treturn { values: [destination], location: e.location };\n\t}\n\n\tconst _: never = e;\n\tthrow new Error(\"compileExpressionAtom: Unhandled tag `\" + e[\"tag\"] + \"`\");\n}\n\nfunction compileFieldAccess(\n\tbase: ir.VariableDefinition,\n\taccess: grammar.ExpressionAccessField,\n\tbaseLocation: ir.SourceLocation,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\tcontext: FunctionContext,\n) {\n\tif (base.type.tag !== \"type-compound\") {\n\t\tthrow new diagnostics.FieldAccessOnNonCompoundErr({\n\t\t\taccessedType: displayType(base.type),\n\t\t\taccessedLocation: access.fieldName.location,\n\t\t});\n\t}\n\n\tconst programContext = context.sourceContext.programContext;\n\tconst baseEntity = programContext.getDataEntity(base.type.base);\n\n\tconst instantiation = ir.typeArgumentsMap(baseEntity.typeScope.typeVariableList, base.type.type_arguments);\n\n\n\tconst fieldDeclaration = baseEntity.tag === \"enum\"\n\t\t? baseEntity.variants[access.fieldName.name]\n\t\t: baseEntity.fields[access.fieldName.name];\n\tif (fieldDeclaration === undefined) {\n\t\tif (baseEntity.tag === \"enum\") {\n\t\t\tthrow new diagnostics.NoSuchVariantErr({\n\t\t\t\tenumType: displayType(base.type),\n\t\t\t\tvariantName: access.fieldName.name,\n\t\t\t\tlocation: access.fieldName.location,\n\t\t\t\tkind: \"variant access\",\n\t\t\t});\n\t\t} else {\n\t\t\tthrow new diagnostics.NoSuchFieldErr({\n\t\t\t\trecordType: displayType(base.type),\n\t\t\t\tfieldName: access.fieldName.name,\n\t\t\t\tlocation: access.fieldName.location,\n\t\t\t\tkind: \"access\",\n\t\t\t});\n\t\t}\n\t}\n\n\tconst fieldType = ir.typeSubstitute(fieldDeclaration.t, instantiation);\n\tconst location = ir.locationSpan(baseLocation, access.fieldName.location);\n\tconst destination = {\n\t\tvariable: stack.uniqueID(\"field\"),\n\t\ttype: fieldType,\n\t\tlocation,\n\t};\n\n\tif (baseEntity.tag === \"enum\") {\n\t\tops.push({\n\t\t\ttag: \"op-variant\",\n\t\t\tobject: base.variable,\n\t\t\tvariant: access.fieldName.name,\n\t\t\tdestination,\n\t\t\tdiagnostic_location: access.fieldName.location,\n\t\t});\n\t} else {\n\t\tops.push({\n\t\t\ttag: \"op-field\",\n\t\t\tobject: base.variable,\n\t\t\tfield: access.fieldName.name,\n\t\t\tdestination,\n\t\t});\n\t}\n\n\treturn {\n\t\tvalues: [destination],\n\t\tlocation,\n\t};\n}\n\nfunction compileSuffixIs(\n\tbase: ir.VariableDefinition,\n\tsuffixIs: grammar.ExpressionSuffixIs,\n\tbaseLocation: ir.SourceLocation,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\tcontext: FunctionContext,\n): ValueInfo {\n\tif (base.type.tag !== \"type-compound\") {\n\t\tthrow new diagnostics.VariantTestOnNonEnumErr({\n\t\t\ttestedType: displayType(base.type),\n\t\t\ttestLocation: suffixIs.location,\n\t\t});\n\t}\n\n\tconst programContext = context.sourceContext.programContext;\n\tconst baseEntity = programContext.getDataEntity(base.type.base);\n\tif (baseEntity.tag !== \"enum\") {\n\t\tthrow new diagnostics.VariantTestOnNonEnumErr({\n\t\t\ttestedType: displayType(base.type),\n\t\t\ttestLocation: suffixIs.location,\n\t\t});\n\t}\n\n\tconst variantDefinition = baseEntity.variants[suffixIs.variant.name];\n\tif (variantDefinition === undefined) {\n\t\tthrow new diagnostics.NoSuchVariantErr({\n\t\t\tkind: \"is test\",\n\t\t\tenumType: displayType(base.type),\n\t\t\tvariantName: suffixIs.variant.name,\n\t\t\tlocation: suffixIs.variant.location,\n\t\t});\n\t}\n\n\tconst location = ir.locationSpan(baseLocation, suffixIs.location);\n\tconst destination = {\n\t\tvariable: stack.uniqueID(\"is_\" + suffixIs.variant.name),\n\t\ttype: ir.T_BOOLEAN,\n\t\tlocation,\n\t};\n\tops.push({\n\t\ttag: \"op-is-variant\",\n\t\tbase: base.variable,\n\t\tvariant: suffixIs.variant.name,\n\t\tdestination,\n\t});\n\n\treturn { values: [destination], location };\n}\n\nfunction compileOperand(\n\te: grammar.ExpressionOperand,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext): ValueInfo {\n\tlet value = compileExpressionAtom(e.atom, ops, stack, typeScope, context);\n\tfor (const access of e.accesses) {\n\t\tif (value.values.length !== 1) {\n\t\t\tthrow new diagnostics.MultiExpressionGroupedErr({\n\t\t\t\tlocation: value.location,\n\t\t\t\tvalueCount: value.values.length,\n\t\t\t\tgrouping: access.tag,\n\t\t\t});\n\t\t}\n\t\tconst base = value.values[0];\n\n\t\tif (access.tag === \"field\") {\n\t\t\tvalue = compileFieldAccess(base, access, value.location, ops, stack, context);\n\t\t} else if (access.tag === \"method\") {\n\t\t\tif (base.type.tag !== \"type-compound\") {\n\t\t\t\t// TODO: Support method calls on type parameters.\n\t\t\t\tthrow new diagnostics.MethodAccessOnNonCompoundErr({\n\t\t\t\t\taccessedType: displayType(base.type),\n\t\t\t\t\taccessedLocation: access.methodName.location,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst programContext = context.sourceContext.programContext;\n\t\t\tconst baseEntity = programContext.getDataEntity(base.type.base);\n\t\t\tconst fn = baseEntity.fns[access.methodName.name];\n\t\t\tif (fn === undefined) {\n\t\t\t\tthrow new diagnostics.NoSuchFnErr({\n\t\t\t\t\tbaseType: displayType(base.type),\n\t\t\t\t\tmethodName: access.methodName.name,\n\t\t\t\t\tmethodNameLocation: access.methodName.location,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst location = ir.locationSpan(value.location, access.location);\n\n\t\t\tconst args = [value];\n\t\t\tfor (const arg of access.args) {\n\t\t\t\targs.push(compileExpression(arg, ops, stack, typeScope, context));\n\t\t\t}\n\n\t\t\tconst typeArgumentMapping: Map<ir.TypeVariableID, ir.Type> = new Map();\n\t\t\tfor (let i = 0; i < fn.entityTypeVariables.length; i++) {\n\t\t\t\ttypeArgumentMapping.set(fn.entityTypeVariables[i], base.type.type_arguments[i]);\n\t\t\t}\n\t\t\tif (fn.signatureTypeVariables.length !== 0) {\n\t\t\t\tthrow new Error(\"TODO: Handle member-scoped type arguments.\");\n\t\t\t}\n\n\t\t\tvalue = compileCall(ops, stack, args, fn, typeArgumentMapping, location, null);\n\t\t} else {\n\t\t\tconst _: never = access;\n\t\t\tthrow new Error(\"unhandled access tag `\" + access[\"tag\"] + \"` in compileOperand\");\n\t\t}\n\t}\n\n\tif (e.suffixIs) {\n\t\tif (value.values.length !== 1) {\n\t\t\tthrow new diagnostics.MultiExpressionGroupedErr({\n\t\t\t\tlocation: value.location,\n\t\t\t\tvalueCount: value.values.length,\n\t\t\t\tgrouping: \"is\",\n\t\t\t});\n\t\t}\n\t\tconst base = value.values[0];\n\n\t\tvalue = compileSuffixIs(base, e.suffixIs, value.location, ops, stack, context);\n\t}\n\n\treturn value;\n}\n\ntype ResolvedOperator = ResolvedOperatorForeign | ResolvedOperatorProofEquality;\n\ninterface ResolvedOperatorForeign {\n\ttag: \"foreign-op\",\n\tforeignID: ir.FunctionID,\n\twrap: null | \"negate\",\n}\n\ninterface ResolvedOperatorProofEquality {\n\ttag: \"proof-equal-op\",\n\twrap: null | \"negate\",\n}\n\nconst operatorPrecedence = {\n\tprecedences: {\n\t\t\"implies\": 10,\n\t\t\"and\": 10,\n\t\t\"or\": 10,\n\t\t\"==\": 20,\n\t\t\"<\": 20,\n\t\t\">\": 20,\n\t\t\"<=\": 20,\n\t\t\">=\": 20,\n\t\t\"!=\": 20,\n\t\t\"_default\": 30,\n\t} as Record<string, number>,\n\tassociativities: {\n\t\timplies: \"right\",\n\t\tand: \"left\",\n\t\tor: \"left\",\n\t\t\"<\": \"left\",\n\t\t\"<=\": { group: \"<\" },\n\t\t\">\": \"left\",\n\t\t\">=\": { group: \">=\" },\n\t} as Record<string, \"left\" | \"right\" | { group: string }>,\n};\n\ninterface OperatorTreeLeaf {\n\ttag: \"leaf\",\n\tleft: number,\n\tright: number,\n\n\toperand: grammar.ExpressionOperand,\n\tlocation: ir.SourceLocation,\n}\n\ninterface OperatorTreeJoin {\n\tindex: number,\n\n\topToken: lexer.OperatorToken | grammar.BinaryLogicalToken,\n\tassociativity: \"none\" | \"left\" | \"right\",\n\n\t/// Only operations with the same `associates` can associate without\n\t/// parenthesization.\n\tassociates: string,\n\n\tprecedence: number,\n}\n\ninterface OperatorTreeBranch {\n\ttag: \"branch\",\n\tleft: number,\n\tright: number,\n\n\tjoin: OperatorTreeJoin,\n\tleftBranch: OperatorTree,\n\trightBranch: OperatorTree,\n\n\tlocation: ir.SourceLocation,\n}\n\ntype OperatorTree = OperatorTreeLeaf | OperatorTreeBranch;\n\nfunction checkTreeCompatible(subtree: OperatorTree, parent: OperatorTreeJoin) {\n\tif (subtree.tag === \"leaf\") {\n\t\t// An operand is valid as a child of any operation.\n\t\treturn;\n\t} else if (subtree.join.precedence < parent.precedence) {\n\t\tthrow new Error(\"checkTreeCompatible: unreachable\");\n\t} else if (subtree.join.precedence > parent.precedence) {\n\t\t// A child with strictly greater precedence is valid.\n\t\treturn;\n\t} else if (subtree.join.associates !== parent.associates) {\n\t\t// A child with equal precedence but different associativity is invalid.\n\t\tthrow new diagnostics.OperationRequiresParenthesizationErr({\n\t\t\top1: {\n\t\t\t\tstr: subtree.join.opToken.tag === \"keyword\"\n\t\t\t\t\t? subtree.join.opToken.keyword\n\t\t\t\t\t: subtree.join.opToken.operator,\n\t\t\t\tlocation: subtree.join.opToken.location,\n\t\t\t},\n\t\t\top2: {\n\t\t\t\tstr: parent.opToken.tag === \"keyword\"\n\t\t\t\t\t? parent.opToken.keyword\n\t\t\t\t\t: parent.opToken.operator,\n\t\t\t\tlocation: parent.opToken.location,\n\t\t\t},\n\t\t\treason: \"unordered\",\n\t\t});\n\t} else if (parent.associativity === \"none\") {\n\t\tthrow new diagnostics.OperationRequiresParenthesizationErr({\n\t\t\top1: {\n\t\t\t\tstr: subtree.join.opToken.tag === \"keyword\"\n\t\t\t\t\t? subtree.join.opToken.keyword\n\t\t\t\t\t: subtree.join.opToken.operator,\n\t\t\t\tlocation: subtree.join.opToken.location,\n\t\t\t},\n\t\t\top2: {\n\t\t\t\tstr: parent.opToken.tag === \"keyword\"\n\t\t\t\t\t? parent.opToken.keyword\n\t\t\t\t\t: parent.opToken.operator,\n\t\t\t\tlocation: parent.opToken.location,\n\t\t\t},\n\t\t\treason: \"non-associative\",\n\t\t});\n\t}\n}\n\nfunction applyOrderOfOperations(\n\toperators: (lexer.OperatorToken | grammar.BinaryLogicalToken)[],\n\toperands: grammar.ExpressionOperand[],\n): OperatorTree {\n\tif (operators.length !== operands.length - 1) {\n\t\tthrow new Error();\n\t}\n\n\tlet joins: OperatorTreeJoin[] = [];\n\tfor (let i = 0; i < operators.length; i++) {\n\t\tconst operator = operators[i];\n\t\tconst opStr = operator.tag === \"keyword\" ? operator.keyword : operator.operator;\n\n\t\tlet precedence = operatorPrecedence.precedences[opStr];\n\t\tif (precedence === undefined) {\n\t\t\tprecedence = operatorPrecedence.precedences._default;\n\t\t}\n\n\t\tlet associativity: { group: string } | \"left\" | \"right\" | \"none\" = { group: opStr };\n\t\tlet associates: string = opStr;\n\t\twhile (typeof associativity !== \"string\") {\n\t\t\tassociates = associativity.group;\n\t\t\tassociativity = operatorPrecedence.associativities[associativity.group] || \"none\";\n\t\t}\n\n\t\tjoins.push({\n\t\t\tindex: i,\n\t\t\topToken: operator,\n\t\t\tassociativity, precedence, associates,\n\t\t});\n\t}\n\n\tjoins.sort((a, b) => {\n\t\tif (a.precedence !== b.precedence) {\n\t\t\treturn b.precedence - a.precedence;\n\t\t} else if (a.associativity !== b.associativity) {\n\t\t\treturn a.associativity.localeCompare(b.associativity);\n\t\t} else if (a.associativity === \"right\") {\n\t\t\treturn b.index - a.index;\n\t\t} else {\n\t\t\treturn b.index - a.index;\n\t\t}\n\t});\n\n\tconst branches: OperatorTree[] = [];\n\tfor (let i = 0; i < operands.length; i++) {\n\t\tbranches.push({\n\t\t\ttag: \"leaf\",\n\t\t\tleft: i,\n\t\t\tright: i,\n\t\t\toperand: operands[i],\n\t\t\tlocation: operands[i].location,\n\t\t});\n\t}\n\tlet branch = branches[0];\n\tfor (let join of joins) {\n\t\tconst toLeft = join.index;\n\t\tconst toRight = join.index + 1;\n\t\tconst left = branches[toLeft];\n\t\tconst right = branches[toRight];\n\t\tbranch = {\n\t\t\ttag: \"branch\",\n\t\t\tjoin,\n\t\t\tleftBranch: left, rightBranch: right,\n\t\t\tleft: left.left,\n\t\t\tright: right.right,\n\t\t\tlocation: ir.locationSpan(left.location, right.location),\n\t\t};\n\n\t\tcheckTreeCompatible(left, join);\n\t\tcheckTreeCompatible(right, join);\n\n\t\tbranches[branch.left] = branch;\n\t\tbranches[branch.right] = branch;\n\t}\n\treturn branch;\n}\n\nfunction expectOneBooleanForContract(\n\tvalues: ValueInfo,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext,\n\tcontract: \"assert\" | \"requires\" | \"ensures\"\n): ir.VariableDefinition {\n\tif (values.values.length !== 1) {\n\t\tthrow new diagnostics.MultiExpressionGroupedErr({\n\t\t\tlocation: values.location,\n\t\t\tvalueCount: values.values.length,\n\t\t\tgrouping: \"op\",\n\t\t\top: contract,\n\t\t});\n\t}\n\n\tconst value = values.values[0];\n\tif (!ir.equalTypes(ir.T_BOOLEAN, value.type)) {\n\t\tthrow new diagnostics.BooleanTypeExpectedErr({\n\t\t\tgivenType: displayType(value.type),\n\t\t\tlocation: values.location,\n\t\t\treason: \"contract\",\n\t\t\tcontract: contract,\n\t\t});\n\t}\n\treturn value;\n}\n\nfunction expectOneBooleanForLogical(\n\tvalues: ValueInfo,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext,\n\top: { opStr: string, location: ir.SourceLocation },\n): ir.VariableDefinition {\n\tif (values.values.length !== 1) {\n\t\tthrow new diagnostics.MultiExpressionGroupedErr({\n\t\t\tlocation: values.location,\n\t\t\tvalueCount: values.values.length,\n\t\t\tgrouping: \"op\",\n\t\t\top: op.opStr,\n\t\t});\n\t}\n\n\tconst value = values.values[0];\n\tif (!ir.equalTypes(ir.T_BOOLEAN, value.type)) {\n\t\tthrow new diagnostics.BooleanTypeExpectedErr({\n\t\t\tgivenType: displayType(value.type),\n\t\t\tlocation: values.location,\n\t\t\treason: \"logical-op\",\n\t\t\top: op.opStr,\n\t\t\topLocation: op.location,\n\t\t});\n\t}\n\treturn value;\n}\n\n/// compileLogicalExpressionTree compiles a binary operation like\n/// `implies` or `and`.\nfunction compileLogicalExpressionTree(\n\ttree: OperatorTreeBranch & { join: { opToken: { tag: \"keyword\" } } },\n\tops: ir.Op[],\n\tstack: VariableStack,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext,\n): ValueInfo {\n\tconst left = compileExpressionTree(tree.leftBranch, ops, stack, typeScope, context);\n\n\t// Compile a logical binary operation.\n\tconst opStr = tree.join.opToken.keyword;\n\n\tconst leftValue = expectOneBooleanForLogical(left, typeScope, context, {\n\t\topStr: tree.join.opToken.keyword,\n\t\tlocation: tree.join.opToken.location,\n\t});\n\n\tconst destination = {\n\t\tvariable: stack.uniqueID(\"logical\"),\n\t\ttype: ir.T_BOOLEAN,\n\t\tlocation: tree.location,\n\t};\n\n\tconst trueOps: ir.Op[] = [];\n\tconst falseOps: ir.Op[] = [];\n\n\tlet trueSource: { tag: \"variable\", variable: ir.VariableID };\n\tlet falseSource: { tag: \"variable\", variable: ir.VariableID };\n\n\tif (opStr === \"or\") {\n\t\ttrueSource = { tag: \"variable\", variable: leftValue.variable };\n\n\t\tstack.openBlock(false);\n\n\t\tconst right = compileExpressionTree(tree.rightBranch, falseOps, stack, typeScope, context);\n\t\tconst rightValue = expectOneBooleanForLogical(right, typeScope, context, {\n\t\t\topStr: \"or\",\n\t\t\tlocation: tree.join.opToken.location,\n\t\t});\n\t\tfalseSource = { tag: \"variable\", variable: rightValue.variable };\n\n\t\tfor (const _ in stack.closeBlock()) {\n\t\t\tthrow new Error(\"ICE: unexpected local assignment in logical\");\n\t\t}\n\t} else if (opStr === \"and\") {\n\t\tfalseSource = { tag: \"variable\", variable: leftValue.variable };\n\n\t\tstack.openBlock(false);\n\n\t\tconst right = compileExpressionTree(tree.rightBranch, trueOps, stack, typeScope, context);\n\t\tconst rightValue = expectOneBooleanForLogical(right, typeScope, context, {\n\t\t\topStr: \"and\",\n\t\t\tlocation: tree.join.opToken.location,\n\t\t});\n\t\ttrueSource = { tag: \"variable\", variable: rightValue.variable };\n\n\t\tfor (const _ in stack.closeBlock()) {\n\t\t\tthrow new Error(\"ICE: unexpected local assignment in logical\");\n\t\t}\n\t} else if (opStr === \"implies\") {\n\t\tconst trueConst = {\n\t\t\tvariable: stack.uniqueID(\"falseimplies\"),\n\t\t\ttype: ir.T_BOOLEAN,\n\t\t\tlocation: ir.NONE,\n\t\t};\n\t\tfalseOps.push({\n\t\t\ttag: \"op-const\",\n\t\t\ttype: \"Boolean\",\n\t\t\tboolean: true,\n\t\t\tdestination: trueConst,\n\t\t});\n\t\tfalseSource = { tag: \"variable\", variable: trueConst.variable };\n\n\t\tstack.openBlock(false);\n\n\t\tconst right = compileExpressionTree(tree.rightBranch, trueOps, stack, typeScope, context);\n\t\tconst rightValue = expectOneBooleanForLogical(right, typeScope, context, {\n\t\t\topStr: \"implies\",\n\t\t\tlocation: tree.join.opToken.location,\n\t\t});\n\t\ttrueSource = { tag: \"variable\", variable: rightValue.variable };\n\n\t\tfor (const _ in stack.closeBlock()) {\n\t\t\tthrow new Error(\"ICE: unexpected local assignment in logical\");\n\t\t}\n\t} else {\n\t\tconst _: never = opStr;\n\t\tthrow new Error(\"Unhandled logical operator `\" + opStr + \"`\");\n\t}\n\n\tconst branch: ir.OpBranch = {\n\t\ttag: \"op-branch\",\n\t\tcondition: leftValue.variable,\n\t\ttrueBranch: { ops: trueOps },\n\t\tfalseBranch: { ops: falseOps },\n\t\tdestinations: [\n\t\t\t{\n\t\t\t\tdestination,\n\t\t\t\ttrueSource,\n\t\t\t\tfalseSource,\n\t\t\t},\n\t\t],\n\t};\n\tops.push(branch);\n\n\treturn { values: [destination], location: tree.location };\n}\n\n/// Throws `MultiExpressionGroupedErr` if `lhs` does not have exactly 1 value.\nfunction resolveArithmeticOperator(\n\tvalue: ir.VariableDefinition,\n\toperator: lexer.OperatorToken,\n): ResolvedOperator {\n\tconst opStr = operator.operator;\n\tif (ir.equalTypes(ir.T_INT, value.type)) {\n\t\tif (opStr === \"+\") {\n\t\t\treturn { tag: \"foreign-op\", foreignID: \"Int+\" as ir.FunctionID, wrap: null };\n\t\t} else if (opStr === \"-\") {\n\t\t\treturn { tag: \"foreign-op\", foreignID: \"Int-\" as ir.FunctionID, wrap: null };\n\t\t} else if (opStr === \"==\") {\n\t\t\treturn { tag: \"foreign-op\", foreignID: \"Int==\" as ir.FunctionID, wrap: null };\n\t\t} else if (opStr === \"!=\") {\n\t\t\treturn { tag: \"foreign-op\", foreignID: \"Int==\" as ir.FunctionID, wrap: \"negate\" };\n\t\t} else if (opStr === \"<\") {\n\t\t\treturn { tag: \"foreign-op\", foreignID: \"Int<\" as ir.FunctionID, wrap: null };\n\t\t}\n\t}\n\n\tif (ir.equalTypes(ir.T_BOOLEAN, value.type)) {\n\t\tif (opStr === \"==\") {\n\t\t\treturn { tag: \"foreign-op\", foreignID: \"Boolean==\" as ir.FunctionID, wrap: null };\n\t\t} else if (opStr === \"!=\") {\n\t\t\treturn { tag: \"foreign-op\", foreignID: \"Boolean==\" as ir.FunctionID, wrap: null };\n\t\t}\n\t}\n\n\tif (opStr === \"==\") {\n\t\treturn { tag: \"proof-equal-op\", wrap: null };\n\t} else if (opStr === \"!=\") {\n\t\treturn { tag: \"proof-equal-op\", wrap: \"negate\" };\n\t}\n\n\tthrow new diagnostics.TypeDoesNotProvideOperatorErr({\n\t\tlhsType: displayType(value.type),\n\t\toperator: opStr,\n\t\toperatorLocation: operator.location,\n\t});\n}\n\nfunction compileArithmeticExpressionTree(\n\tleftBranch: OperatorTree,\n\trightBranch: OperatorTree,\n\topToken: lexer.OperatorToken,\n\tlocation: ir.SourceLocation,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext,\n): ValueInfo {\n\t// Compile an arithmetic operation.\n\tconst left = compileExpressionTree(leftBranch, ops, stack, typeScope, context);\n\tconst right = compileExpressionTree(rightBranch, ops, stack, typeScope, context);\n\tconst opStr = opToken.operator;\n\n\tif (left.values.length !== 1) {\n\t\tthrow new diagnostics.MultiExpressionGroupedErr({\n\t\t\tlocation: left.location,\n\t\t\tvalueCount: left.values.length,\n\t\t\tgrouping: \"op\",\n\t\t\top: opStr,\n\t\t});\n\t} else if (right.values.length !== 1) {\n\t\tthrow new diagnostics.MultiExpressionGroupedErr({\n\t\t\tlocation: right.location,\n\t\t\tvalueCount: right.values.length,\n\t\t\tgrouping: \"op\",\n\t\t\top: opStr,\n\t\t});\n\t}\n\n\tconst resolvedOperator = resolveArithmeticOperator(left.values[0], opToken);\n\n\tlet signatureReturnType: ir.Type;\n\tlet expectedLhsType: ir.Type;\n\tlet expectedRhsType: ir.Type;\n\tif (resolvedOperator.tag === \"foreign-op\") {\n\t\tconst signature = context.sourceContext.programContext.foreignSignatures[resolvedOperator.foreignID];\n\t\tif (signature === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t\"resolveArithmeticOperator produced a bad foreign signature (`\" + resolvedOperator\n\t\t\t\t+ \"`) for `\" + displayType(left.values[0].type)\n\t\t\t\t+ \"` `\" + opStr + \"`\");\n\t\t} else if (signature.parameters.length !== 2) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Foreign signature `\" + resolvedOperator + \"` cannot be used as\"\n\t\t\t\t+ \"an operator since it doesn't take exactly 2 parameters\");\n\t\t} else if (signature.return_types.length !== 1) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Foreign signature `\" + resolvedOperator\n\t\t\t\t+ \"` cannot be used as an operator since it produces \"\n\t\t\t\t+ signature.return_types.length + \" values\");\n\t\t}\n\n\t\texpectedLhsType = signature.parameters[0].type;\n\t\texpectedRhsType = signature.parameters[1].type;\n\t\tsignatureReturnType = signature.return_types[0];\n\t} else if (resolvedOperator.tag === \"proof-equal-op\") {\n\t\texpectedLhsType = left.values[0].type;\n\t\texpectedRhsType = expectedLhsType;\n\t\tsignatureReturnType = ir.T_BOOLEAN;\n\n\t\tif (!stack.isInProofBlock()) {\n\t\t\tthrow new diagnostics.ProofMemberUsedOutsideProofContextErr({\n\t\t\t\toperation: opToken.operator,\n\t\t\t\tlocation: opToken.location,\n\t\t\t});\n\t\t}\n\t} else {\n\t\tconst _: never = resolvedOperator;\n\t\tthrow new Error(\"compileArithmeticExpressionTree: unhandled operator type\");\n\t}\n\n\tif (!ir.equalTypes(expectedRhsType, right.values[0].type)) {\n\t\tthrow new diagnostics.OperatorTypeMismatchErr({\n\t\t\tlhsType: displayType(left.values[0].type),\n\t\t\toperator: opStr,\n\t\t\tgivenRhsType: displayType(right.values[0].type),\n\t\t\texpectedRhsType: displayType(expectedRhsType),\n\t\t\trhsLocation: right.location,\n\t\t});\n\t}\n\n\tlet operatorResult = {\n\t\tvariable: stack.uniqueID(\"arithmetic\"),\n\t\ttype: signatureReturnType,\n\t\tlocation,\n\t};\n\n\tif (resolvedOperator.tag === \"foreign-op\") {\n\t\tops.push({\n\t\t\ttag: \"op-foreign\",\n\t\t\toperation: resolvedOperator.foreignID,\n\t\t\targuments: [left.values[0].variable, right.values[0].variable],\n\t\t\tdestinations: [operatorResult],\n\t\t});\n\t} else if (resolvedOperator.tag === \"proof-equal-op\") {\n\t\tops.push({\n\t\t\ttag: \"op-proof-eq\",\n\t\t\tleft: left.values[0].variable,\n\t\t\tright: right.values[0].variable,\n\t\t\tdestination: operatorResult,\n\t\t});\n\t} else {\n\t\tconst _: never = resolvedOperator;\n\t\tthrow new Error(\"TODO\");\n\t}\n\n\tif (resolvedOperator.wrap === \"negate\") {\n\t\tconst negatedResult = {\n\t\t\tvariable: stack.uniqueID(\"negatearithmetic\"),\n\t\t\ttype: ir.T_BOOLEAN,\n\t\t\tlocation,\n\t\t};\n\t\tconst booleanConstant = {\n\t\t\tvariable: stack.uniqueID(\"negatearithmetic\"),\n\t\t\ttype: ir.T_BOOLEAN,\n\t\t\tlocation,\n\t\t};\n\t\tops.push({\n\t\t\ttag: \"op-branch\",\n\t\t\tcondition: operatorResult.variable,\n\t\t\ttrueBranch: {\n\t\t\t\tops: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttag: \"op-const\",\n\t\t\t\t\t\tdestination: booleanConstant,\n\t\t\t\t\t\ttype: \"Boolean\",\n\t\t\t\t\t\tboolean: false,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t\tfalseBranch: {\n\t\t\t\tops: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttag: \"op-const\",\n\t\t\t\t\t\tdestination: booleanConstant,\n\t\t\t\t\t\ttype: \"Boolean\",\n\t\t\t\t\t\tboolean: true,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t\tdestinations: [\n\t\t\t\t{\n\t\t\t\t\tdestination: negatedResult,\n\t\t\t\t\ttrueSource: { tag: \"variable\", variable: booleanConstant.variable },\n\t\t\t\t\tfalseSource: { tag: \"variable\", variable: booleanConstant.variable },\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\n\t\toperatorResult = negatedResult;\n\t}\n\n\treturn {\n\t\tvalues: [operatorResult],\n\t\tlocation,\n\t};\n}\n\nfunction compileExpressionTree(\n\ttree: OperatorTree,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext,\n): ValueInfo {\n\tif (tree.tag === \"leaf\") {\n\t\treturn compileOperand(tree.operand, ops, stack, typeScope, context);\n\t} else if (tree.join.opToken.tag === \"keyword\") {\n\t\treturn compileLogicalExpressionTree(tree as any, ops, stack, typeScope, context);\n\t} else {\n\t\treturn compileArithmeticExpressionTree(\n\t\t\ttree.leftBranch, tree.rightBranch, tree.join.opToken, tree.location, ops, stack, typeScope, context);\n\t}\n}\n\nfunction compileExpression(\n\te: grammar.Expression,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext,\n): ValueInfo {\n\tconst operands = [e.left, ...e.operations.map(x => x.right)];\n\tconst operators = e.operations.map(x => x.operator);\n\tconst tree = applyOrderOfOperations(operators, operands);\n\treturn compileExpressionTree(tree, ops, stack, typeScope, context);\n}\n\n/// `displayType` formats the given IR `Type` as a string of (fully qualified)\n/// Shiru code.\nexport function displayType(t: ir.Type): string {\n\tif (t.tag === \"type-compound\") {\n\t\tconst base = t.base;\n\t\tconst args = t.type_arguments.map(displayType);\n\t\tif (args.length === 0) {\n\t\t\treturn base;\n\t\t} else {\n\t\t\treturn base + \"[\" + args.join(\", \") + \"]\";\n\t\t}\n\t} else if (t.tag === \"type-primitive\") {\n\t\t// TODO: Text vs String vs Bytes?\n\t\treturn t.primitive;\n\t} else if (t.tag == \"type-variable\") {\n\t\treturn \"#\" + t.id;\n\t} else if (t.tag === \"type-any\") {\n\t\treturn \"Any\";\n\t} else {\n\t\tconst _: never = t;\n\t\tthrow new Error(\"displayType: unhandled tag `\" + t[\"tag\"] + \"`\");\n\t}\n}\n\n/// `displayConstraint` formats the given IR constraint as a string, potentially\n/// formatted for the given `SourceContext` (considering import aliases and\n/// such).\nexport function displayConstraint(c: ir.ConstraintParameter): string {\n\tconst base = c.interface;\n\tif (c.subjects.length === 0) {\n\t\tthrow new Error(\"ICE: Invalid constraint `\" + base + \"`\");\n\t}\n\n\tconst lhs = displayType(c.subjects[0]);\n\tconst rhs = c.subjects.slice(1).map(t => displayType(t));\n\tif (rhs.length === 0) {\n\t\treturn `${lhs} is ${base}`;\n\t} else {\n\t\treturn `${lhs} is ${base}[${rhs.join(\", \")}]`;\n\t}\n}\n\nexport function displayTypeScope(c: TypeScope, opt: { space: boolean }) {\n\tif (c.typeVariableList.length === 0) {\n\t\treturn \"\";\n\t} else {\n\t\treturn \"[\" + c.typeVariableList.map(x => \"#\" + x).join(\", \") + \"]\" +\n\t\t\t(opt.space ? \" \" : \"\");\n\t}\n}\n\nfunction compileVarSt(\n\tstatement: grammar.VarSt,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext) {\n\tconst values = [];\n\tfor (const e of statement.initialization) {\n\t\tconst tuple = compileExpression(e, ops, stack, typeScope, context);\n\t\tfor (let i = 0; i < tuple.values.length; i++) {\n\t\t\tvalues.push({ tuple, i });\n\t\t}\n\t}\n\n\tif (values.length !== statement.variables.length) {\n\t\tthrow new diagnostics.ValueCountMismatchErr({\n\t\t\tactualCount: values.length,\n\t\t\tactualLocation: ir.locationsSpan(statement.initialization),\n\t\t\texpectedCount: statement.variables.length,\n\t\t\texpectedLocation: ir.locationsSpan(statement.variables),\n\t\t});\n\t}\n\n\tfor (let i = 0; i < statement.variables.length; i++) {\n\t\tconst v = statement.variables[i];\n\t\tconst t = compileType(v.t, typeScope, context.sourceContext, \"check\");\n\n\t\tconst pair = values[i];\n\t\tconst value = pair.tuple.values[pair.i];\n\n\t\tif (!ir.equalTypes(value.type, t)) {\n\t\t\tthrow new diagnostics.TypeMismatchErr({\n\t\t\t\tgivenType: displayType(value.type),\n\t\t\t\tgivenLocation: pair.tuple.location,\n\t\t\t\tgivenIndex: { index0: pair.i, count: pair.tuple.values.length },\n\t\t\t\texpectedType: displayType(t),\n\t\t\t\texpectedLocation: v.t.location,\n\t\t\t});\n\t\t}\n\n\t\tstack.defineLocal(v.variable.name, t, v.variable.location, value.variable);\n\t}\n}\n\nfunction compileAssertSt(\n\tstatement: grammar.AssertSt,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext,\n) {\n\tconst proof: ir.OpProof = {\n\t\ttag: \"op-proof\",\n\t\tbody: {\n\t\t\tops: [],\n\t\t},\n\t};\n\t// Compile the asserted expression in a proof context.\n\tstack.openBlock(true);\n\tconst conditionTuple = compileExpression(statement.expression, proof.body.ops, stack, typeScope, context);\n\tstack.closeBlock();\n\n\tconst asserted = expectOneBooleanForContract(conditionTuple, typeScope, context, \"assert\");\n\tproof.body.ops.push({\n\t\ttag: \"op-branch\",\n\t\tcondition: asserted.variable,\n\t\ttrueBranch: { ops: [] },\n\t\tfalseBranch: {\n\t\t\tops: [\n\t\t\t\t{\n\t\t\t\t\ttag: \"op-unreachable\",\n\t\t\t\t\tdiagnostic_kind: \"contract\",\n\t\t\t\t\tdiagnostic_location: statement.location,\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\tdestinations: [],\n\t});\n\tops.push(proof);\n}\n\nfunction compileReturnSt(\n\tstatement: grammar.ReturnSt,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext) {\n\tconst values = [];\n\tfor (const e of statement.values) {\n\t\tconst tuple = compileExpression(e, ops, stack, typeScope, context);\n\t\tfor (let i = 0; i < tuple.values.length; i++) {\n\t\t\tvalues.push({ tuple, i });\n\t\t}\n\t}\n\n\tif (values.length === 0) {\n\t\tthrow new Error(\"ICE: return must take at least 1 value\");\n\t}\n\n\tif (values.length !== context.returnsTo.length) {\n\t\tconst signatureReturn = ir.locationsSpan(context.returnsTo);\n\t\tthrow new diagnostics.ValueCountMismatchErr({\n\t\t\tactualCount: values.length,\n\t\t\tactualLocation: ir.locationsSpan(statement.values),\n\t\t\texpectedCount: context.returnsTo.length,\n\t\t\texpectedLocation: signatureReturn,\n\t\t});\n\t}\n\tlet op: ir.OpReturn = {\n\t\ttag: \"op-return\",\n\t\tsources: [],\n\t\tdiagnostic_return_site: statement.location,\n\t};\n\tfor (let i = 0; i < values.length; i++) {\n\t\tconst v = values[i];\n\t\tconst source = v.tuple.values[v.i];\n\t\top.sources.push(source.variable);\n\n\t\tconst destination = context.returnsTo[i];\n\t\tif (!ir.equalTypes(source.type, destination.t)) {\n\t\t\tthrow new diagnostics.TypeMismatchErr({\n\t\t\t\tgivenType: displayType(source.type),\n\t\t\t\tgivenLocation: v.tuple.location,\n\t\t\t\tgivenIndex: { index0: v.i, count: v.tuple.values.length },\n\t\t\t\texpectedType: displayType(destination.t),\n\t\t\t\texpectedLocation: destination.location,\n\t\t\t});\n\t\t}\n\t}\n\tops.push(op);\n}\n\nfunction compileIfClause(\n\tclause: grammar.ElseIfClause,\n\trest: grammar.ElseIfClause[],\n\trestIndex: number,\n\telseClause: grammar.ElseClause | null,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext) {\n\tconst condition = compileExpression(clause.condition, ops, stack, typeScope, context);\n\tif (condition.values.length !== 1) {\n\t\tthrow new diagnostics.MultiExpressionGroupedErr({\n\t\t\tlocation: clause.condition.location,\n\t\t\tvalueCount: condition.values.length,\n\t\t\tgrouping: \"if\",\n\t\t});\n\t}\n\tconst conditionValue = condition.values[0];\n\tif (!ir.equalTypes(ir.T_BOOLEAN, conditionValue.type)) {\n\t\tthrow new diagnostics.BooleanTypeExpectedErr({\n\t\t\tgivenType: displayType(conditionValue.type),\n\t\t\tlocation: clause.condition.location,\n\t\t\treason: \"if\",\n\t\t});\n\t}\n\n\tlet trueAssignments: Record<string, ir.VariableID> = {};\n\tconst trueBranch: ir.OpBlock = compileBlock(clause.body, stack, typeScope, context, (assignments) => {\n\t\ttrueAssignments = assignments;\n\t});\n\n\tstack.openBlock(false);\n\tlet falseBranch: ir.OpBlock = { ops: [] };\n\tif (restIndex >= rest.length) {\n\t\t// Reached else clause.\n\t\tif (elseClause !== null) {\n\t\t\tfalseBranch = compileBlock(elseClause.body, stack, typeScope, context);\n\t\t}\n\t} else {\n\t\tcompileIfClause(rest[restIndex], rest, restIndex + 1, elseClause,\n\t\t\tfalseBranch.ops, stack, typeScope, context);\n\t}\n\tconst falseAssignments = stack.closeBlock();\n\n\tconst destinations: ir.BranchPhi[] = [];\n\tfor (const key in trueAssignments) {\n\t\tthrow new Error(\"TODO\");\n\t}\n\tfor (const key in falseAssignments) {\n\t\tthrow new Error(\"TODO\");\n\t}\n\n\n\tops.push({\n\t\ttag: \"op-branch\",\n\t\tcondition: conditionValue.variable,\n\t\ttrueBranch,\n\t\tfalseBranch,\n\t\tdestinations,\n\t});\n}\n\nfunction compileIfSt(\n\tstatement: grammar.IfSt,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext) {\n\tcompileIfClause(statement, statement.elseIfClauses, 0, statement.elseClause,\n\t\tops, stack, typeScope, context);\n}\n\nfunction compileStatement(\n\tstatement: grammar.Statement,\n\tops: ir.Op[],\n\tstack: VariableStack,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext) {\n\tif (statement.tag === \"var\") {\n\t\tcompileVarSt(statement, ops, stack, typeScope, context);\n\t\treturn;\n\t} else if (statement.tag === \"return\") {\n\t\tcompileReturnSt(statement, ops, stack, typeScope, context);\n\t\treturn;\n\t} else if (statement.tag === \"if\") {\n\t\tcompileIfSt(statement, ops, stack, typeScope, context);\n\t\treturn;\n\t} else if (statement.tag === \"assert\") {\n\t\tcompileAssertSt(statement, ops, stack, typeScope, context);\n\t\treturn;\n\t} else if (statement.tag === \"unreachable\") {\n\t\tops.push({\n\t\t\ttag: \"op-unreachable\",\n\t\t\tdiagnostic_kind: \"unreachable\",\n\t\t\tdiagnostic_location: statement.location,\n\t\t});\n\t\treturn;\n\t}\n\n\tconst _: never = statement;\n\tthrow new Error(\"Unhandled tag in compileStatement `\" + statement[\"tag\"] + \"`\");\n}\n\nfunction compileBlock(\n\tblock: grammar.Block,\n\tstack: VariableStack,\n\ttypeScope: TypeScope,\n\tcontext: FunctionContext,\n\tcallback?: (assignments: Record<string, ir.VariableID>) => void,\n): ir.OpBlock {\n\tconst ops: ir.Op[] = [];\n\tstack.openBlock(false);\n\n\tfor (const s of block.statements) {\n\t\tcompileStatement(s, ops, stack, typeScope, context);\n\t}\n\n\n\tconst assignments = stack.closeBlock();\n\tif (callback !== undefined) {\n\t\tcallback(assignments);\n\t}\n\treturn {\n\t\tops: ops,\n\t};\n}\n\nfunction compileFunctionSignature(\n\tsignatureAST: grammar.FnSignature,\n\ttypeScope: TypeScope,\n\ttypeVariablesArePreBound: boolean,\n\tsourceContext: SourceContext,\n): {\n\tsignature: ir.FunctionSignature,\n\tstack: VariableStack,\n\tcontext: FunctionContext,\n} {\n\tconst typeVariables = typeVariablesArePreBound\n\t\t? []\n\t\t: typeScope.typeVariableList.slice(0);\n\tconst signature: ir.FunctionSignature = {\n\t\ttype_parameters: typeVariables,\n\t\tconstraint_parameters: typeScope.constraints.map(c => c.constraint),\n\n\t\tparameters: [],\n\t\treturn_types: [],\n\n\t\tpreconditions: [],\n\t\tpostconditions: [],\n\t};\n\n\tconst stack = new VariableStack();\n\tfor (const parameterAST of signatureAST.parameters.list) {\n\t\tconst t = compileType(parameterAST.t, typeScope, sourceContext, \"check\");\n\t\tconst parameterVariableID = parameterAST.name.name as ir.VariableID;\n\t\tstack.defineLocal(parameterAST.name.name, t, parameterAST.name.location, parameterVariableID);\n\t\tsignature.parameters.push({\n\t\t\tvariable: parameterVariableID,\n\t\t\ttype: t,\n\t\t\tlocation: parameterAST.name.location,\n\t\t});\n\t}\n\n\tconst context: FunctionContext = {\n\t\treturnsTo: [],\n\t\tsourceContext,\n\t\tensuresReturnExpression: null,\n\t};\n\tfor (const r of signatureAST.returns) {\n\t\tconst t = compileType(r, typeScope, sourceContext, \"check\");\n\t\tsignature.return_types.push(t);\n\t\tcontext.returnsTo.push({ t, location: r.location });\n\t}\n\n\tfor (let precondition of signatureAST.requires) {\n\t\tconst block: ir.OpBlock = { ops: [] };\n\n\t\t// Compile the precondition in a proof context.\n\t\tstack.openBlock(true);\n\t\tconst result = compileExpression(precondition.expression, block.ops, stack, typeScope, context);\n\t\tconst asserted = expectOneBooleanForContract(result, typeScope, context, \"requires\");\n\t\tstack.closeBlock();\n\n\t\tsignature.preconditions.push({\n\t\t\tblock,\n\t\t\tprecondition: asserted.variable,\n\t\t\tlocation: precondition.expression.location,\n\t\t});\n\t}\n\n\tif (signatureAST.ensures.length !== 0) {\n\t\t// Compile the postcondition in a proof context.\n\t\tstack.openBlock(true);\n\n\t\t// The variables in a \"return\" expression are treated as \"parameter\"\n\t\t// variables for the ensures block.\n\t\tconst ensuresReturnExpression: ValueInfo = {\n\t\t\tlocation: ir.locationsSpan(signatureAST.returns),\n\t\t\tvalues: [],\n\t\t};\n\t\tfor (let i = 0; i < signature.return_types.length; i++) {\n\t\t\tensuresReturnExpression.values.push({\n\t\t\t\tvariable: stack.uniqueID(\"return\" + i),\n\t\t\t\ttype: signature.return_types[i],\n\t\t\t\t// TODO:\n\t\t\t\tlocation: ir.NONE,\n\t\t\t});\n\t\t}\n\n\t\tfor (let postcondition of signatureAST.ensures) {\n\t\t\tconst block: ir.OpBlock = { ops: [] };\n\n\t\t\tstack.openBlock(true);\n\t\t\tconst result = compileExpression(postcondition.expression, block.ops, stack, typeScope, {\n\t\t\t\t...context,\n\t\t\t\tensuresReturnExpression,\n\t\t\t});\n\t\t\tconst asserted = expectOneBooleanForContract(result, typeScope, context, \"ensures\");\n\t\t\tstack.closeBlock();\n\n\t\t\tsignature.postconditions.push({\n\t\t\t\tblock,\n\t\t\t\treturnedValues: ensuresReturnExpression.values,\n\t\t\t\tpostcondition: asserted.variable,\n\t\t\t\tlocation: postcondition.expression.location,\n\t\t\t});\n\t\t}\n\t\tstack.closeBlock();\n\t}\n\n\treturn { signature, stack, context };\n}\n\nfunction compileMemberFunction(\n\tprogram: ir.Program,\n\tdef: FnBinding,\n\tfName: string,\n\tsourceContext: SourceContext,\n\ttypeScope: TypeScope) {\n\n\tconst { signature, stack, context } = compileFunctionSignature(\n\t\tdef.ast.signature, typeScope, false, sourceContext);\n\tconst body = compileBlock(def.ast.body, stack, typeScope, context);\n\n\t// Make the verifier prove that this function definitely does not exit\n\t// without returning.\n\tif (body.ops.length === 0 || !ir.opTerminates(body.ops[body.ops.length - 1])) {\n\t\tbody.ops.push({\n\t\t\ttag: \"op-unreachable\",\n\t\t\tdiagnostic_kind: \"return\",\n\t\t\tdiagnostic_location: def.ast.body.closing,\n\t\t});\n\t}\n\n\tprogram.functions[fName] = { signature, body };\n}\n\nfunction checkImplMemberConformance(\n\tint: InterfaceEntityDef,\n\tfnName: { name: string, location: ir.SourceLocation },\n\tconstraint: ir.ConstraintParameter,\n\tsignature: ir.FunctionSignature,\n\tsignatureAST: grammar.FnSignature,\n): void {\n\tconst corresponding = int.fns[fnName.name];\n\n\t// Check that a corresponding member exists.\n\tif (corresponding === undefined) {\n\t\tthrow new diagnostics.ImplMemberDoesNotExistOnInterface({\n\t\t\timpl: displayConstraint(constraint),\n\t\t\tmember: fnName.name,\n\t\t\tmemberLocation: fnName.location,\n\t\t\tinterface: constraint.interface,\n\t\t\tinterfaceLocation: int.bindingLocation,\n\t\t});\n\t}\n\n\t// Determine the expected signatures.\n\tif (corresponding.signatureTypeVariables.length !== 0) {\n\t\tthrow new Error(\"TODO: interface member with type parameters\");\n\t}\n\tconst instantiation = ir.typeArgumentsMap(corresponding.interfaceTypeVariables, constraint.subjects);\n\n\t// Check the parameter types.\n\tif (corresponding.parameters.length !== signature.parameters.length) {\n\t\tthrow new diagnostics.ImplParameterCountMismatch({\n\t\t\timpl: displayConstraint(constraint),\n\t\t\tmember: fnName.name,\n\t\t\timplCount: signature.parameters.length,\n\t\t\tinterfaceCount: corresponding.parameters.length,\n\t\t\timplLocation: signatureAST.parameters.location,\n\t\t\tinterfaceLocation: corresponding.parametersLocation,\n\t\t});\n\t}\n\tfor (let i = 0; i < corresponding.parameters.length; i++) {\n\t\tconst expected = ir.typeSubstitute(corresponding.parameters[i].t, instantiation);\n\t\tif (!ir.equalTypes(expected, signature.parameters[i].type)) {\n\t\t\tthrow new diagnostics.ImplParameterTypeMismatch({\n\t\t\t\timpl: displayConstraint(constraint),\n\t\t\t\tparameterIndex0: i,\n\t\t\t\tmemberName: fnName.name,\n\t\t\t\timplType: displayType(signature.parameters[i].type),\n\t\t\t\tinterfaceType: displayType(expected),\n\t\t\t\timplLocation: signatureAST.parameters.list[i].t.location,\n\t\t\t\tinterfaceLocation: corresponding.parameters[i].typeLocation,\n\t\t\t});\n\t\t}\n\t}\n\n\t// Check the return types.\n\tif (corresponding.returns.length !== signature.return_types.length) {\n\t\tthrow new diagnostics.ImplReturnCountMismatch({\n\t\t\timpl: displayConstraint(constraint),\n\t\t\tmember: fnName.name,\n\t\t\timplCount: signature.return_types.length,\n\t\t\tinterfaceCount: corresponding.returns.length,\n\t\t\timplLocation: ir.locationsSpan(signatureAST.returns),\n\t\t\tinterfaceLocation: ir.locationsSpan(corresponding.returns.map(x => ({ location: x.typeLocation }))),\n\t\t});\n\t}\n\tfor (let i = 0; i < corresponding.returns.length; i++) {\n\t\tconst expected = ir.typeSubstitute(corresponding.returns[i].t, instantiation);\n\t\tif (!ir.equalTypes(expected, signature.return_types[i])) {\n\t\t\tthrow new diagnostics.ImplReturnTypeMismatch({\n\t\t\t\timpl: displayConstraint(constraint),\n\t\t\t\treturnIndex0: i,\n\t\t\t\tmemberName: fnName.name,\n\t\t\t\timplType: displayType(signature.return_types[i]),\n\t\t\t\tinterfaceType: displayType(expected),\n\t\t\t\timplLocation: signatureAST.returns[i].location,\n\t\t\t\tinterfaceLocation: corresponding.returns[i].typeLocation,\n\t\t\t});\n\t\t}\n\t}\n\n\tif (signature.preconditions.length !== 0) {\n\t\tthrow new diagnostics.ImplMayNotHavePreconditionErr({\n\t\t\timpl: displayConstraint(constraint),\n\t\t\tmemberName: fnName.name,\n\t\t\tpreconditionLocation: signature.preconditions[0].location,\n\t\t});\n\t}\n}\n\nfunction compileImpl(\n\tprogram: ir.Program,\n\timpl: ImplEntityDef,\n\tnamingInterface: ir.InterfaceID,\n\tnamingRecord: string,\n\tnamingCount: string,\n\tprogramContext: ProgramContext,\n) {\n\tconst sourceContext = programContext.sourceContexts[impl.sourceID];\n\tconst int = programContext.getInterface(impl.constraint.interface);\n\n\tconst vtable: ir.VTableFactory = {\n\t\tfor_any: impl.typeScope.typeVariableList,\n\t\tprovides: impl.constraint,\n\t\tentries: {},\n\t};\n\n\tconst canonicalImplName = `impl__${namingInterface}__${namingRecord}__${namingCount}`;\n\n\tconst memberBindings = new Map<string, ir.SourceLocation>();\n\tfor (const fnAST of impl.ast.fns) {\n\t\tconst fnName = fnAST.signature.name;\n\t\tconst existingBinding = memberBindings.get(fnName.name);\n\t\tif (existingBinding !== undefined) {\n\t\t\tthrow new diagnostics.MemberRedefinedErr({\n\t\t\t\tmemberName: fnName.name,\n\t\t\t\tfirstBinding: existingBinding,\n\t\t\t\tsecondBinding: fnName.location,\n\t\t\t});\n\t\t}\n\t\tmemberBindings.set(fnName.name, fnName.location);\n\t\tconst { signature, stack, context } = compileFunctionSignature(\n\t\t\tfnAST.signature, impl.typeScope, false, sourceContext);\n\n\t\tcheckImplMemberConformance(int, fnName, impl.constraint, signature, fnAST.signature);\n\n\t\tconst body = compileBlock(fnAST.body, stack, int.typeScope, context);\n\n\t\t// Make the verifier prove that this function definitely does not exit\n\t\t// without returning.\n\t\tif (body.ops.length === 0 || !ir.opTerminates(body.ops[body.ops.length - 1])) {\n\t\t\tbody.ops.push({\n\t\t\t\ttag: \"op-unreachable\",\n\t\t\t\tdiagnostic_kind: \"return\",\n\t\t\t\tdiagnostic_location: fnAST.body.closing,\n\t\t\t});\n\t\t}\n\n\t\t// TODO: Handle signature type constraints.\n\t\tconst closureConstraints = impl.typeScope.constraints.map(x => x.constraint);\n\t\tconst canonicalMemberName = `${canonicalImplName}__${fnName.name}`;\n\t\tprogram.functions[canonicalMemberName] = { signature, body };\n\t\tvtable.entries[fnName.name] = {\n\t\t\timplementation: canonicalMemberName as ir.FunctionID,\n\t\t\tconstraint_parameters: closureConstraints,\n\t\t};\n\t}\n\n\tfor (const expected in int.fns) {\n\t\tif (memberBindings.get(expected) === undefined) {\n\t\t\tthrow new diagnostics.ImplMissingInterfaceMember({\n\t\t\t\timpl: displayConstraint(impl.constraint),\n\t\t\t\tmember: expected,\n\t\t\t\timplLocation: impl.headLocation,\n\t\t\t\tinterface: impl.constraint.interface,\n\t\t\t\tmemberLocation: int.fns[expected].nameLocation,\n\t\t\t});\n\t\t}\n\t}\n\n\tprogram.globalVTableFactories[canonicalImplName] = vtable;\n}\n\nfunction compileInterfaceEntity(\n\tprogram: ir.Program,\n\tentity: InterfaceEntityDef,\n\tentityName: string,\n\tprogramContext: ProgramContext,\n) {\n\tconst compiled: ir.IRInterface = {\n\t\ttype_parameters: entity.typeScope.typeVariableList,\n\t\tsignatures: {},\n\t};\n\tconst sourceContext = programContext.sourceContexts[entity.sourceID];\n\tfor (const fnName in entity.fns) {\n\t\tconst fn = entity.fns[fnName];\n\t\tconst signature = compileFunctionSignature(\n\t\t\tfn.ast.signature, entity.typeScope, true, sourceContext);\n\t\tcompiled.signatures[fnName] = signature.signature;\n\t}\n\n\tprogram.interfaces[entityName] = compiled;\n}\n\nfunction compileRecordEntity(\n\tprogram: ir.Program,\n\tentity: RecordEntityDef,\n\tentityName: string,\n\tprogramContext: ProgramContext,\n) {\n\t// Layout storage for this record.\n\tprogram.records[entityName] = {\n\t\ttype_parameters: entity.typeScope.typeVariableList,\n\t\tfields: {},\n\t};\n\tfor (const fieldName in entity.fields) {\n\t\tprogram.records[entityName].fields[fieldName] = entity.fields[fieldName].t;\n\t}\n\n\t// Compile member functions.\n\tfor (const f in entity.fns) {\n\t\tconst def = entity.fns[f];\n\t\tconst fName = def.id;\n\t\tcompileMemberFunction(program, def, fName,\n\t\t\tprogramContext.sourceContexts[entity.sourceID], entity.typeScope);\n\t}\n\n\t// Compile impls.\n\tfor (const [interfaceID, impls] of entity.implsByInterface) {\n\t\tfor (let i = 0; i < impls.length; i++) {\n\t\t\tcompileImpl(program, impls[i], interfaceID, entityName, i + \"\", programContext);\n\t\t}\n\t}\n}\n\nfunction compileEnumEntity(\n\tprogram: ir.Program,\n\tentity: EnumEntityDef,\n\tentityName: string,\n\tprogramContext: ProgramContext,\n): void {\n\tprogram.enums[entityName] = {\n\t\ttype_parameters: entity.typeScope.typeVariableList,\n\t\tvariants: {},\n\t};\n\n\tfor (const variantName in entity.variants) {\n\t\tprogram.enums[entityName].variants[variantName] = entity.variants[variantName].t;\n\t}\n\n\t// Compile member functions.\n\tfor (const f in entity.fns) {\n\t\tconst def = entity.fns[f];\n\t\tconst fName = def.id;\n\t\tcompileMemberFunction(program, def, fName,\n\t\t\tprogramContext.sourceContexts[entity.sourceID], entity.typeScope);\n\t}\n\n\t// Compile impls.\n\tfor (const [interfaceID, impls] of entity.implsByInterface) {\n\t\tfor (let i = 0; i < impls.length; i++) {\n\t\t\tcompileImpl(program, impls[i], interfaceID, entityName, i + \"\", programContext);\n\t\t}\n\t}\n}\n\n/// `compileEntity` compiles the indicated entity into records, functions,\n/// interfaces, vtable-factories, etc in the given `program`.\n/// THROWS `SemanticError` if a type-error is discovered within the\n/// implementation of this entity.\nfunction compileEntity(\n\tprogram: ir.Program,\n\tprogramContext: ProgramContext,\n\tentityName: string,\n\tentity: NamedEntityDef,\n): void {\n\tif (entity.tag === \"record\") {\n\t\treturn compileRecordEntity(program, entity, entityName, programContext);\n\t} else if (entity.tag === \"enum\") {\n\t\treturn compileEnumEntity(program, entity, entityName, programContext);\n\t} else if (entity.tag === \"interface\") {\n\t\treturn compileInterfaceEntity(program, entity, entityName, programContext);\n\t}\n\n\tconst _: never = entity;\n\tthrow new Error(\"compileEntity: unhandled tag `\" + entity[\"tag\"] + \"`\");\n}\n\nfunction getBasicForeign(): Record<string, ir.FunctionSignature> {\n\treturn {\n\t\t\"Int==\": {\n\t\t\t// Equality\n\t\t\tparameters: [\n\t\t\t\t{\n\t\t\t\t\tvariable: \"left\" as ir.VariableID,\n\t\t\t\t\ttype: ir.T_INT,\n\t\t\t\t\tlocation: ir.NONE,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tvariable: \"right\" as ir.VariableID,\n\t\t\t\t\ttype: ir.T_INT,\n\t\t\t\t\tlocation: ir.NONE,\n\t\t\t\t},\n\t\t\t],\n\t\t\treturn_types: [ir.T_BOOLEAN],\n\t\t\ttype_parameters: [],\n\t\t\tconstraint_parameters: [],\n\t\t\tpreconditions: [],\n\t\t\tpostconditions: [],\n\t\t\tsemantics: {\n\t\t\t\teq: true,\n\t\t\t},\n\t\t},\n\t\t\"Boolean==\": {\n\t\t\t// Equality\n\t\t\tparameters: [\n\t\t\t\t{\n\t\t\t\t\tvariable: \"left\" as ir.VariableID,\n\t\t\t\t\ttype: ir.T_BOOLEAN,\n\t\t\t\t\tlocation: ir.NONE,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tvariable: \"right\" as ir.VariableID,\n\t\t\t\t\ttype: ir.T_BOOLEAN,\n\t\t\t\t\tlocation: ir.NONE,\n\t\t\t\t},\n\t\t\t],\n\t\t\treturn_types: [ir.T_BOOLEAN],\n\t\t\ttype_parameters: [],\n\t\t\tconstraint_parameters: [],\n\t\t\tpreconditions: [],\n\t\t\tpostconditions: [],\n\t\t\tsemantics: {\n\t\t\t\teq: true,\n\t\t\t},\n\t\t},\n\t\t\"Int<\": {\n\t\t\tparameters: [\n\t\t\t\t{\n\t\t\t\t\tvariable: \"left\" as ir.VariableID,\n\t\t\t\t\ttype: ir.T_INT,\n\t\t\t\t\tlocation: ir.NONE,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tvariable: \"right\" as ir.VariableID,\n\t\t\t\t\ttype: ir.T_INT,\n\t\t\t\t\tlocation: ir.NONE,\n\t\t\t\t},\n\t\t\t],\n\t\t\treturn_types: [ir.T_BOOLEAN],\n\t\t\ttype_parameters: [],\n\t\t\tconstraint_parameters: [],\n\t\t\tpreconditions: [],\n\t\t\tpostconditions: [],\n\t\t\tsemantics: {},\n\t\t},\n\t\t\"Int+\": {\n\t\t\t// Addition\n\t\t\tparameters: [\n\t\t\t\t{\n\t\t\t\t\tvariable: \"left\" as ir.VariableID,\n\t\t\t\t\ttype: ir.T_INT,\n\t\t\t\t\tlocation: ir.NONE,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tvariable: \"right\" as ir.VariableID,\n\t\t\t\t\ttype: ir.T_INT,\n\t\t\t\t\tlocation: ir.NONE,\n\t\t\t\t},\n\t\t\t],\n\t\t\treturn_types: [ir.T_INT],\n\t\t\ttype_parameters: [],\n\t\t\tconstraint_parameters: [],\n\t\t\tpreconditions: [],\n\t\t\tpostconditions: [],\n\t\t},\n\t\t\"Int-\": {\n\t\t\t// Subtract\n\t\t\tparameters: [\n\t\t\t\t{\n\t\t\t\t\tvariable: \"left\" as ir.VariableID,\n\t\t\t\t\ttype: ir.T_INT,\n\t\t\t\t\tlocation: ir.NONE,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tvariable: \"right\" as ir.VariableID,\n\t\t\t\t\ttype: ir.T_INT,\n\t\t\t\t\tlocation: ir.NONE,\n\t\t\t\t},\n\t\t\t],\n\t\t\treturn_types: [ir.T_INT],\n\t\t\ttype_parameters: [],\n\t\t\tconstraint_parameters: [],\n\t\t\tpreconditions: [],\n\t\t\tpostconditions: [],\n\t\t},\n\t};\n}\n\nfunction associateImplWithBase(\n\trecord: RecordEntityDef | EnumEntityDef,\n\tconstraint: ir.ConstraintParameter,\n\tsourceID: string,\n\ttypeScope: TypeScopeI<null>,\n\timplAST: grammar.ImplDefinition,\n): void {\n\n\tconst headLocation = ir.locationSpan(implAST.impl.location, implAST.constraint.location);\n\n\t// Check if an existing impl conflicts with this one.\n\tconst existingImpls = record.implsByInterface.get(constraint.interface);\n\tfor (const candidate of existingImpls) {\n\t\tconst unifier = ir.unifyTypes(\n\t\t\tcandidate.typeScope.typeVariableList,\n\t\t\tcandidate.constraint.subjects,\n\t\t\ttypeScope.typeVariableList,\n\t\t\tconstraint.subjects,\n\t\t);\n\t\tif (unifier !== null) {\n\t\t\tconst firstImpl =\n\t\t\t\tdisplayTypeScope(candidate.typeScope, { space: true }) +\n\t\t\t\tdisplayConstraint(candidate.constraint);\n\t\t\tconst secondImpl =\n\t\t\t\tdisplayTypeScope(typeScope, { space: true }) +\n\t\t\t\tdisplayConstraint(constraint);\n\t\t\tthrow new diagnostics.OverlappingImplsErr({\n\t\t\t\tfirstImpl,\n\t\t\t\tfirstLocation: candidate.headLocation,\n\t\t\t\tsecondImpl,\n\t\t\t\tsecondLocation: headLocation,\n\t\t\t});\n\t\t}\n\t}\n\n\t// TODO: Check for \"orphan\" instances.\n\n\t// Record this impl.\n\trecord.implsByInterface.get(constraint.interface).push({\n\t\ttag: \"impl\",\n\t\tast: implAST,\n\t\theadLocation,\n\t\tsourceID,\n\t\ttypeScope,\n\t\tconstraint,\n\t});\n}\n\n/// `compileSources` transforms the ASTs making up a Shiru program into a\n/// `ir.Program`.\n/// THROWS `SemanticError` if a type-error is discovered within the given source\n/// files.\nexport function compileSources(sources: Record<string, grammar.Source>): ir.Program {\n\tconst programContext = collectAllEntities(sources);\n\n\t// Collect all entities and source contexts.\n\tfor (const sourceID in sources) {\n\t\tresolveSourceContext(sourceID, sources[sourceID], programContext);\n\t}\n\n\t// Resolve type scopes and constraints.\n\tfor (let [_, entity] of programContext.namedEntities()) {\n\t\tresolveAvailableTypes(programContext, entity);\n\t}\n\n\t// Resolve all impl blocks.\n\tfor (const sourceID in programContext.sourceContexts) {\n\t\tconst sourceContext = programContext.sourceContexts[sourceID];\n\t\tfor (const implAST of sourceContext.implASTs) {\n\t\t\tconst typeScope: TypeScopeI<null> = {\n\t\t\t\tthisType: null,\n\t\t\t\ttypeVariables: new Map(),\n\t\t\t\ttypeVariableList: [],\n\t\t\t\tconstraints: [],\n\t\t\t};\n\t\t\tcollectTypeScope(sourceContext, typeScope, implAST.typeParameters);\n\n\t\t\tconst baseType = compileType(implAST.base, typeScope, sourceContext, \"skip\");\n\t\t\tif (baseType.tag !== \"type-compound\") {\n\t\t\t\tthrow new Error(\"compileSources: ICE\");\n\t\t\t}\n\t\t\tconst baseEntity = programContext.getDataEntity(baseType.base);\n\t\t\tconst constraint = compileConstraint(implAST.constraint, baseType, sourceContext, typeScope, \"skip\",\n\t\t\t\tir.locationSpan(implAST.base.location, implAST.constraint.location));\n\n\t\t\t// Associate the impl with its base record type.\n\t\t\tassociateImplWithBase(baseEntity, constraint, sourceID, typeScope, implAST);\n\t\t}\n\t}\n\n\t// Recheck all the unchecked types & constraints found in the above step:\n\tconst uncheckedTypes = programContext.uncheckedTypes!;\n\tconst uncheckedConstraints = programContext.uncheckedConstraints!;\n\tprogramContext.uncheckedTypes = [];\n\tprogramContext.uncheckedConstraints = [];\n\tfor (const { t, scope, sourceContext } of uncheckedTypes) {\n\t\tcompileType(t, scope, sourceContext, \"check\");\n\t}\n\tfor (const { c, methodSubject, sourceContext, scope, constraintLocation } of uncheckedConstraints) {\n\t\tcompileConstraint(c, methodSubject, sourceContext, scope, \"check\",\n\t\t\tconstraintLocation);\n\t}\n\n\t// Resolve members of entities. Type arguments must be validated based on\n\t// collected constraints.\n\tfor (const [canonicalEntityName, entity] of programContext.namedEntities()) {\n\t\tresolveMemberSignatures(programContext, canonicalEntityName, entity);\n\t}\n\n\tconst program: ir.Program = {\n\t\tfunctions: {},\n\t\tinterfaces: {},\n\t\trecords: {},\n\t\tenums: {},\n\t\tforeign: programContext.foreignSignatures,\n\t\tglobalVTableFactories: {},\n\t};\n\n\tfor (let [canonicalEntityName, entity] of programContext.namedEntities()) {\n\t\tcompileEntity(program, programContext, canonicalEntityName, entity);\n\t}\n\treturn program;\n}\n","import { DefaultMap, DisjointSet, TrieMap } from \"./data\";\n\nexport type EObject = symbol & { __brand: \"EObject\" };\n\nexport type EClassDescription<Term> = {\n\tmembers: { id: EObject, term: Term, operands: EObject[] }[]\n};\n\n/// An \"equivalence-graph\", loosely inspired by \"egg (e-graphs good)\".\nexport class EGraph<Term, Tag, Reason> {\n\t/// `tagged.get(tag).get(rep)` is the set of IDs tagged with `tag` that are\n\t/// equal to representative `rep`.\n\tprivate tagged = new DefaultMap<Tag, DefaultMap<EObject, Set<EObject>>>(t => new DefaultMap(r => new Set()));\n\tprivate taggedDef = new Map<EObject, { term: Term, operands: EObject[], tag: Tag }>();\n\n\tprivate tuples: TrieMap<[Term, ...EObject[]], EObject> = new TrieMap();\n\tprivate ds: DisjointSet<EObject, Set<Reason>> = new DisjointSet();\n\n\treset(): void {\n\t\tthis.ds.reset();\n\t\tfor (const [_, map] of this.tagged) {\n\t\t\tfor (const [id, set] of map) {\n\t\t\t\tconst has = set.has(id);\n\t\t\t\tset.clear();\n\t\t\t\tif (has) {\n\t\t\t\t\tset.add(id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgetTagged(tag: Tag, id: EObject): Array<{ id: EObject, term: Term, operands: EObject[] }> {\n\t\tconst out = [];\n\t\tconst representative = this.ds.representative(id);\n\t\tfor (const tagged of this.tagged.get(tag).get(representative)) {\n\t\t\tconst def = this.taggedDef.get(tagged)!;\n\t\t\tout.push({ id: tagged, term: def.term, operands: def.operands });\n\t\t}\n\t\treturn out;\n\t}\n\n\tadd(term: Term, operands: EObject[], tag?: Tag, hint?: string): EObject {\n\t\tconst tuple: [Term, ...EObject[]] = [term, ...operands];\n\t\tconst existing = this.tuples.get(tuple);\n\t\tif (existing) {\n\t\t\treturn existing;\n\t\t} else {\n\t\t\tconst id: EObject = Symbol(\"egraph-term(\" + hint + \")\") as EObject;\n\t\t\tthis.tuples.put(tuple, id);\n\t\t\tif (tag !== undefined) {\n\t\t\t\tthis.tagged.get(tag).get(id).add(id);\n\t\t\t\tthis.taggedDef.set(id, { term, operands, tag });\n\t\t\t}\n\t\t\treturn id;\n\t\t}\n\t}\n\n\t/// `reason` is a conjunction of `Reason`s.\n\t/// merge(a, b, reason) returns false when this fact was already present in\n\t/// this egrahp.\n\tmerge(a: EObject, b: EObject, reason: Set<Reason>): boolean {\n\t\tconst arep = this.ds.representative(a);\n\t\tconst brep = this.ds.representative(b);\n\t\tif (arep === brep) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Merge a and b specifically (and not their representatives) so that\n\t\t// the reason is precisely tracked.\n\t\tthis.ds.union(a, b, reason);\n\n\t\tconst parent = this.ds.representative(arep);\n\t\tif (parent !== arep && parent !== brep) {\n\t\t\tthrow new Error(\"EGraph.merge: unexpected new representative\");\n\t\t}\n\t\tconst child = arep === parent ? brep : arep;\n\t\tfor (const [tag, map] of this.tagged) {\n\t\t\tconst parentSet = this.tagged.get(tag).get(parent);\n\t\t\tfor (const e of map.get(child)) {\n\t\t\t\tparentSet.add(e);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate updateCongruenceStep(): boolean {\n\t\t// The keys of `canonical` are representatives.\n\t\t// The `id` is the symbol of the original (non-canonicalized) object;\n\t\t// the `reason` is the union of reasons for why the canonicalized\n\t\t// version is equal to the original version.\n\t\tconst canonical = new TrieMap<[Term, ...EObject[]], { id: EObject, reason: Set<Reason> }[]>();\n\t\tfor (const [[term, ...operands], id] of this.tuples) {\n\t\t\tconst representatives = operands.map(x => this.ds.representative(x));\n\t\t\tconst reason = new Set<Reason>();\n\t\t\tfor (let i = 0; i < representatives.length; i++) {\n\t\t\t\tconst representative = representatives[i];\n\t\t\t\tconst original = operands[i];\n\t\t\t\tconst explanation = this.query(representative, original)!;\n\t\t\t\tfor (const r of explanation) {\n\t\t\t\t\treason.add(r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst key: [Term, ...EObject[]] = [term, ...representatives];\n\t\t\tlet group = canonical.get(key);\n\t\t\tif (group === undefined) {\n\t\t\t\tgroup = [];\n\t\t\t\tcanonical.put(key, group);\n\t\t\t}\n\t\t\tgroup.push({ id, reason });\n\t\t}\n\n\t\tlet madeChanges = false;\n\t\tfor (const [_, members] of canonical) {\n\t\t\tif (members.length < 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst first = members[0];\n\t\t\tfor (let i = 1; i < members.length; i++) {\n\t\t\t\tconst second = members[1];\n\t\t\t\tif (this.ds.representative(first.id) === this.ds.representative(second.id)) {\n\t\t\t\t\t// They're already equal.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst reason = new Set([...first.reason, ...second.reason]);\n\t\t\t\tthis.merge(first.id, second.id, reason);\n\t\t\t\tmadeChanges = true;\n\t\t\t}\n\t\t}\n\t\treturn madeChanges;\n\t}\n\n\tupdateCongruence(): boolean {\n\t\tlet madeChanges = false;\n\t\twhile (this.updateCongruenceStep()) { madeChanges = true; }\n\t\treturn madeChanges;\n\t}\n\n\tquery(a: EObject, b: EObject): null | Set<Reason> {\n\t\tif (!this.ds.compareEqual(a, b)) {\n\t\t\treturn null;\n\t\t}\n\t\tconst seq = this.ds.explainEquality(a, b);\n\t\tconst all = new Set<Reason>();\n\t\tfor (const list of seq) {\n\t\t\tfor (const el of list) {\n\t\t\t\tall.add(el);\n\t\t\t}\n\t\t}\n\t\treturn all;\n\t}\n\n\t/// getRepresentative(obj) returns a \"representative\" element of obj's\n\t/// equivalence class, such that any two objects that are equal have the\n\t/// same representative, and any objects that are not equal have different\n\t/// representatives.\n\tgetRepresentative(obj: EObject): EObject {\n\t\treturn this.ds.representative(obj);\n\t}\n\n\tgetClasses(duplicate?: boolean): Map<EObject, EClassDescription<Term>> {\n\t\tconst mapping: Map<EObject, EClassDescription<Term>> = new Map();\n\t\tfor (const [k, id] of this.tuples) {\n\t\t\tconst representative = this.ds.representative(id);\n\t\t\tlet eclass = mapping.get(representative);\n\t\t\tif (eclass === undefined) {\n\t\t\t\teclass = { members: [] };\n\t\t\t\tmapping.set(representative, eclass);\n\t\t\t}\n\t\t\tif (duplicate) {\n\t\t\t\tmapping.set(id, eclass);\n\t\t\t}\n\t\t\tconst term = k[0];\n\t\t\tconst operands = k.slice(1) as EObject[];\n\t\t\teclass.members.push({ id, term, operands });\n\t\t}\n\t\treturn mapping;\n\t}\n}\n","\n/// `Literal` represents a Boolean literal. A `Literal` is a non-zero integer.\n/// The positive integer `a` is satisfied by an assignment of `true` to variable\n/// `a`; a negative integer `-b` is satisfied by an assignment of `false` to\n/// variable `b`.\nexport type Literal = number;\n\n/// `ClauseID` represents an index into the `clauses` field of a `SATSolver`.\ntype ClauseID = number;\n\nfunction swap<T>(array: T[], a: number, b: number) {\n\tconst t = array[a];\n\tarray[a] = array[b];\n\tarray[b] = t;\n}\n\n/// `SATResult` represents the result of sat-solving.\n/// `\"unsatisfiable\"`: This instance has no satisfying assignment.\n/// `Literal[]`: A partial assignment that satisfies this instance.\nexport type SATResult = \"unsatisfiable\" | Literal[];\n\n\n/// `UnitLiteralQueue` is a helper data structure to maintain a queue of unit\n/// literals.\nclass UnitLiteralQueue {\n\tprivate unitLiterals: Map<number, [Literal, ClauseID]> = new Map();\n\n\t/// Adds a literal, with a given antecedent, to this queue.\n\t/// RETURNS a `ClauseID` when this proposed unit literal is in conflict with\n\t/// another unit literal in this mapping.\n\tpushOrFindConflict(literal: Literal, antecedent: ClauseID): ClauseID | null {\n\t\tconst term = literal > 0 ? literal : -literal;\n\t\tconst existing = this.unitLiterals.get(term);\n\t\tif (existing !== undefined && existing[0] !== literal) {\n\t\t\t// This contradicts a unit-literal.\n\t\t\treturn existing[1];\n\t\t} else if (!existing) {\n\t\t\tthis.unitLiterals.set(term, [literal, antecedent]);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/// N.B.: Iterating over this map clears entries from it!\n\t*[Symbol.iterator]() {\n\t\tfor (let key of this.unitLiterals.keys()) {\n\t\t\tconst value = this.unitLiterals.get(key) as [Literal, ClauseID];\n\t\t\tthis.unitLiterals.delete(key);\n\t\t\tyield value;\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tthis.unitLiterals.clear();\n\t}\n\n\tsize(): number {\n\t\treturn this.unitLiterals.size;\n\t}\n}\n\n/// `SATSolver` solves the satisfiability problem on Boolean formulas in\n/// conjunctive-normal-form (an \"and of ors\").\nexport class SATSolver {\n\tprivate clauses: number[][] = [];\n\n\t/// `watchedPositive[n]` is the `ClauseID`s that are \"watching\" the literal\n\t/// `+n`.\n\t/// A satisfied clauses watches two arbitrary literals within the clause.\n\t/// An unsatisfied clauses watches two unfalsified literals within the\n\t/// clause.\n\t/// Each clause array is continually re-ordered so that a watched literal is\n\t/// always one of the first two literals in the clause.\n\tprivate watchedPositive: ClauseID[][] = [];\n\n\t/// `watchedNegative[n]`: see `watchedPositive`.\n\tprivate watchedNegative: ClauseID[][] = [];\n\n\t/// `assignments[n]` is the assignment of term `n`.\n\t/// `0`: the term is unassigned.\n\t/// `1`: the term is assigned \"true\".\n\t/// `-1`: the term is assigned \"false\".\n\tprivate assignments: (-1 | 0 | 1)[] = [];\n\n\t/// `assignmentStack` is a stack of literals that have been assigned.\n\tprivate assignmentStack: Literal[] = [];\n\n\t/// `assignmentStackPosition[t]` is the index of where to find an assignment\n\t/// to term `t` in `assignmentStack`, or `-1` for unassigned variables.\n\tprivate assignmentStackPosition: number[] = [];\n\n\t/// `decisionLevel` is one more than the number of \"free\" assignments that\n\t/// have been made.\n\tprivate decisionLevel: number = 0;\n\n\t/// `termDecisionLevel[t]` is the decision level at the time term `t` was\n\t/// given an assignment.\n\t/// (It is not-defined for unassigned terms)\n\tprivate termDecisionLevel: number[] = [];\n\n\t/// `antecedentClause[n]` is a `ClauseID` which became a unit-clause\n\t/// \"forcing\" the assignment of this term (the \"antecedent\" clause).\n\t/// For an unassigned term `n`, `antecedentClause[n]` is not-defined.\n\t/// For a term assigned \"freely\" (rather than as a result of BCP), the value\n\t/// is `-1`.\n\tprivate antecedentClause: (ClauseID | -1)[] = [];\n\n\t/// Initializes the internal data-structures for terms 1, 2, ..., `term`\n\t/// (if not already initialized).\n\t/// Terms must be initialized before being used in clauses passed to\n\t/// `addClause`.\n\tinitTerms(term: number) {\n\t\tfor (let i = this.assignments.length; i <= term; i++) {\n\t\t\tthis.assignments[i] = 0;\n\t\t\tthis.assignmentStackPosition[i] = -1;\n\t\t\tthis.antecedentClause[i] = 0;\n\t\t\tthis.watchedPositive[i] = [];\n\t\t\tthis.watchedNegative[i] = [];\n\t\t}\n\t}\n\n\t/// RETURNS the current assignment stack.\n\tgetAssignment() {\n\t\treturn this.assignmentStack.slice(0);\n\t}\n\n\t/// solve solves this instance.\n\tsolve(): SATResult {\n\t\tif (this.decisionLevel > 0) {\n\t\t\tthrow new Error(\"SATSolver.solve() requires decision level must be at 0\");\n\t\t} else if (this.assignments.length === 0) {\n\t\t\tthrow new Error(\"SATSolver.solve() requires at least one term\");\n\t\t} else if (this.assignmentStack.length !== 0) {\n\t\t\tthrow new Error(\"SATSolver.solve() requires no assignments have been made.\");\n\t\t}\n\n\t\t// Find initial unit clauses (and later, pure literals).\n\t\tlet unitLiterals = new UnitLiteralQueue();\n\t\tfor (let i = 0; i < this.clauses.length; i++) {\n\t\t\tconst clause = this.clauses[i];\n\t\t\tif (clause.length === 1) {\n\t\t\t\tconst literal = clause[0];\n\t\t\t\tconst conflict = unitLiterals.pushOrFindConflict(literal, i);\n\t\t\t\tif (conflict !== null) {\n\t\t\t\t\t// There are two contradicting unit-clauses.\n\t\t\t\t\treturn \"unsatisfiable\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.decisionLevel = 0;\n\t\tconst initialConflict = this.propagate(unitLiterals);\n\t\tif (initialConflict !== null) {\n\t\t\treturn \"unsatisfiable\";\n\t\t}\n\n\t\t// Define an initial ordering for the terms. A consistent ordering of\n\t\t// terms means larger benefits from learned clauses.\n\t\tlet ordering = [];\n\t\tfor (let i = 1; i < this.assignments.length; i++) {\n\t\t\tordering[i - 1] = i;\n\t\t}\n\n\t\t// Set up state for cVSIDS variable ordering heuristic.\n\t\t// (See \"Understanding VSIDS Branching Heuristics in Conict-Driven\n\t\t// Clause-Learning SAT Solvers\")\n\t\tlet termWeights: number[] = [];\n\t\tfor (let i = 0; i < this.assignmentStackPosition.length; i++) {\n\t\t\ttermWeights.push(0);\n\t\t}\n\t\tfor (let clause of this.clauses) {\n\t\t\tif (clause.length < 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// The initial number of occurrences of a variable is a very rough\n\t\t\t// indication of the \"centrality\" of the variable.\n\t\t\tfor (let literal of clause) {\n\t\t\t\tlet term = literal > 0 ? literal : -literal;\n\t\t\t\ttermWeights[term] += 1;\n\t\t\t}\n\t\t}\n\n\t\tconst termWeightComparator = (termA: number, termB: number) => {\n\t\t\treturn termWeights[termB] - termWeights[termA];\n\t\t};\n\t\tordering.sort(termWeightComparator);\n\n\t\t// Start the main CDCL loop.\n\t\t// Repeat assignments until an assigment has been made to every term.\n\t\tlet cursor = 0;\n\t\tconst termCount = this.assignments.length - 1;\n\t\twhile (this.assignmentStack.length < termCount) {\n\t\t\tconst decisionTerm = ordering[cursor];\n\t\t\tcursor += 1;\n\t\t\tcursor %= ordering.length;\n\n\t\t\tif (this.assignments[decisionTerm] !== 0) {\n\t\t\t\t// This variable has already been assigned.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (unitLiterals.size() !== 0) {\n\t\t\t\tthrow new Error(\"invariant violation\");\n\t\t\t}\n\n\t\t\t// Enqueue a free decision.\n\t\t\tthis.decisionLevel += 1;\n\t\t\tconst expectNull = unitLiterals.pushOrFindConflict(+decisionTerm, -1);\n\t\t\tif (expectNull !== null) {\n\t\t\t\tthrow new Error(\"invariant violation: expected no conflict when no unit literals were found\");\n\t\t\t}\n\n\t\t\t// Propagate unit consequences of that free decision.\n\t\t\twhile (true) {\n\t\t\t\tconst conflict = this.propagate(unitLiterals);\n\t\t\t\tif (conflict === null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst conflictClause = this.diagnoseConflict(conflict);\n\t\t\t\tlet maxDecisionLevel = 0;\n\t\t\t\tlet conflictClauseTermSet = [];\n\t\t\t\tfor (let i = 0; i < conflictClause.length; i++) {\n\t\t\t\t\tconst conflictLiteral = conflictClause[i];\n\t\t\t\t\tconst conflictTerm = conflictLiteral > 0 ? conflictLiteral : -conflictLiteral;\n\t\t\t\t\tmaxDecisionLevel = Math.max(maxDecisionLevel, this.termDecisionLevel[conflictTerm]);\n\t\t\t\t\tconflictClauseTermSet[conflictTerm] = true;\n\t\t\t\t}\n\t\t\t\tif (maxDecisionLevel == 0) {\n\t\t\t\t\t// If the conflict-clause is all of terms prior to the\n\t\t\t\t\t// first decision (including an empty conflict clause),\n\t\t\t\t\t// this instance has been refuted.\n\t\t\t\t\treturn \"unsatisfiable\";\n\t\t\t\t}\n\n\t\t\t\t// Find the earliest decision level at which the conflict\n\t\t\t\t// clause becomes a unit clause.\n\t\t\t\tlet countUnfalsified = conflictClause.length;\n\t\t\t\tlet decisionLevelBecomingUnit = 0;\n\t\t\t\tfor (let i = 0; i < this.assignmentStack.length; i++) {\n\t\t\t\t\tconst literal = this.assignmentStack[i];\n\t\t\t\t\tconst term = literal > 0 ? literal : -literal;\n\t\t\t\t\tif (conflictClauseTermSet[term]) {\n\t\t\t\t\t\tcountUnfalsified -= 1;\n\t\t\t\t\t\tif (countUnfalsified === 1) {\n\t\t\t\t\t\t\t// UNIT CLAUSE.\n\t\t\t\t\t\t\tdecisionLevelBecomingUnit = this.termDecisionLevel[term];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Rewind at least one decision in the conflict clause.\n\t\t\t\tthis.rollbackToDecisionLevel(decisionLevelBecomingUnit);\n\n\t\t\t\t// Then, add the clause, bearing in mind it SHOULD be a unit\n\t\t\t\t// clause (asserting clause), which should expand\n\t\t\t\t// propagation within a PREVIOUS decision level.\n\t\t\t\tconst conflictClauseID = this.addClause(conflictClause);\n\n\t\t\t\t// Find the unit literal in the conflict clause.\n\t\t\t\tlet assertingLiteral = null;\n\t\t\t\tfor (let conflictLiteral of conflictClause) {\n\t\t\t\t\tconst conflictTerm = conflictLiteral > 0 ? conflictLiteral : -conflictLiteral;\n\t\t\t\t\tconst sign = this.assignments[conflictTerm];\n\t\t\t\t\tif (sign * conflictLiteral > 0) {\n\t\t\t\t\t\tthrow new Error(\"invariant violation: conflictClause is satisfied by the current assignment\");\n\t\t\t\t\t} else if (sign === 0) {\n\t\t\t\t\t\t// Unassigned literal.\n\t\t\t\t\t\tif (assertingLiteral === null) {\n\t\t\t\t\t\t\tassertingLiteral = conflictLiteral;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error(\"invariant violation: conflictClause is not an asserting clause (too many unassigned literals)\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (assertingLiteral === null) {\n\t\t\t\t\tthrow new Error(\"invariant violation: conflictClause is not an asserting clause (contradiction)\");\n\t\t\t\t}\n\n\t\t\t\tunitLiterals.clear();\n\t\t\t\tunitLiterals.pushOrFindConflict(assertingLiteral, conflictClauseID);\n\n\t\t\t\t// Use \"cVSIDS\" strategy for clause ordering.\n\t\t\t\tfor (let term = 0; term < termWeights.length; term++) {\n\t\t\t\t\tif (conflictClauseTermSet[term]) {\n\t\t\t\t\t\ttermWeights[term] += 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttermWeights[term] *= 0.99;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tordering.sort(termWeightComparator);\n\n\t\t\t\t// Ensure that variables are assigned in the same order.\n\t\t\t\t// This means that subsequent conflicts are in the same\n\t\t\t\t// \"area\" of the search space, and compound on each other.\n\t\t\t\tcursor = 0;\n\n\t\t\t\t// Continue in the unit-propagation loop.\n\t\t\t}\n\t\t}\n\n\t\treturn this.getAssignment();\n\t}\n\n\t/// Adds a clause to this CNF-SAT instance.\n\t/// The array `clause` is interpreted as a conjunction (\"and\") of its\n\t/// contained literals.\n\t/// A clause is satisfied when at least one of its literals is satisfied.\n\taddClause(clause: Literal[]): ClauseID {\n\t\tlet hasUnassigned = false;\n\t\tfor (let literal of clause) {\n\t\t\tconst term = literal > 0 ? literal : -literal;\n\t\t\tif (this.assignments[term] === 0) {\n\t\t\t\thasUnassigned = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!hasUnassigned) {\n\t\t\tthrow new Error(\"SATSolver.addClause() requires at least one unassigned literal\");\n\t\t}\n\n\t\tlet termFirstLiteral: Record<number, number> = {};\n\t\tfor (let i = 0; i < clause.length; i++) {\n\t\t\tconst literal = clause[i];\n\t\t\tconst term = literal > 0 ? +literal : -literal;\n\t\t\tif (term in termFirstLiteral && termFirstLiteral[term] !== literal) {\n\t\t\t\t// This clause is a tautology.\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\ttermFirstLiteral[term] = literal;\n\t\t}\n\n\t\tconst clauseID = this.clauses.length;\n\t\tthis.clauses.push(clause);\n\n\t\t// Push unassigned literals to the front of the clause, with more\n\t\t// recently assigned literals after that, to reduce unnecessary watches.\n\t\tclause.sort((literalA: Literal, literalB: Literal) => {\n\t\t\tconst termA = literalA > 0 ? literalA : -literalA;\n\t\t\tconst termB = literalB > 0 ? literalB : -literalB;\n\n\t\t\tlet rankA = this.assignmentStackPosition[termA];\n\t\t\tlet rankB = this.assignmentStackPosition[termB];\n\n\t\t\tif (rankA < 0) {\n\t\t\t\trankA = this.assignmentStackPosition.length + 1;\n\t\t\t}\n\t\t\tif (rankB < 0) {\n\t\t\t\trankB = this.assignmentStackPosition.length + 1;\n\t\t\t}\n\t\t\treturn rankB - rankA;\n\t\t});\n\n\t\t// Watch (up to) the first two literals.\n\t\tfor (let i = 0; i < 2 && i < clause.length; i++) {\n\t\t\tconst literal = clause[i];\n\t\t\tif (literal > 0) {\n\t\t\t\tthis.watchedPositive[literal].push(clauseID);\n\t\t\t} else {\n\t\t\t\tthis.watchedNegative[-literal].push(clauseID);\n\t\t\t}\n\t\t}\n\n\t\treturn clauseID;\n\t}\n\n\t/// Validates that certain internal invariants hold. Useful for debugging.\n\t_validateWatches() {\n\t\tconst happyLiterals = this.assignments.map((v, i) => v * i);\n\t\tconst watches: number[][] = this.clauses.map(x => []);\n\t\tfor (let i = 1; i < this.watchedNegative.length; i++) {\n\t\t\tfor (let clauseID of this.watchedNegative[i]) {\n\t\t\t\twatches[clauseID].push(-i);\n\t\t\t}\n\t\t\tfor (let clauseID of this.watchedPositive[i]) {\n\t\t\t\twatches[clauseID].push(+i);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < this.clauses.length; i++) {\n\t\t\tconst clause = this.clauses[i];\n\n\t\t\tlet satisfied = false;\n\t\t\tconst unfalsifiedLiterals = [];\n\t\t\tfor (let literal of clause) {\n\t\t\t\tif (happyLiterals.includes(literal)) {\n\t\t\t\t\tsatisfied = true;\n\t\t\t\t} else if (this.assignments[Math.abs(literal)] === 0) {\n\t\t\t\t\tunfalsifiedLiterals.push(literal);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tconst w = watches[i];\n\t\t\tif (!satisfied) {\n\t\t\t\tconst unwatchedUnfalsified = unfalsifiedLiterals.filter(x => w.indexOf(x) < 0);\n\t\t\t\tfor (let watcher of w) {\n\t\t\t\t\tconst term = Math.abs(watcher);\n\t\t\t\t\tif (this.assignments[term] * watcher < 0 && unwatchedUnfalsified.length >= 1) {\n\t\t\t\t\t\tthrow new Error(`Watched term ${term} in unsatisfied clause #${i} [${clause}] has been assigned ${this.assignments[term]}, and ${unwatchedUnfalsified} are available.`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w.length > 2) {\n\t\t\t\tthrow new Error(\"Too many watched literals in this clause!\");\n\t\t\t} else if (w.length < 2 && w.length < clause.length) {\n\t\t\t\tthrow new Error(`Too few watched literals in clause #${i} ${clause} watched only by ${w}`);\n\t\t\t} else if (w[0] !== clause[0] && w[0] !== clause[1]) {\n\t\t\t\tthrow new Error(\"First watched literal \" + w[0] + \" is not one of first two literals!\");\n\t\t\t} else if (w[1] !== clause[0] && w[1] !== clause[1]) {\n\t\t\t\tthrow new Error(\"Second watched literal \" + w[1] + \" is not one of first two literals!\");\n\t\t\t}\n\n\t\t\tif (!satisfied) {\n\t\t\t\tif (unfalsifiedLiterals.length >= 2) {\n\t\t\t\t\tfor (let k of w) {\n\t\t\t\t\t\tif (!unfalsifiedLiterals.includes(k)) {\n\t\t\t\t\t\t\tthrow new Error(\"Watched literal `\" + k + \"` has been falsified!\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (w.length === 0) {\n\t\t\t\t\tthrow new Error(\"Clause \" + clause + \" is not being watched by any literals, but isn't satisfied!\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Assigns the literals in the `unitLiterals` queue, and then performs\n\t/// boolean-constraint-propagation, resulting in more assignments\n\t/// to newly created unit clauses.\n\t/// RETURNS a conflict when boolean-constraint-propagation results in a\n\t/// conflict: see `UnitLiteralQueue.pushOrFindConflict`.\n\t/// RETURNS `null` when the queue was completely drained without\n\t/// encountering a conflict.\n\tpropagate(\n\t\tunitLiterals: UnitLiteralQueue,\n\t): { literal: Literal, literalAntecedent: ClauseID, negativeLiteralAntecedent: ClauseID } | null {\n\t\tfor (let [unitLiteral, antecedent] of unitLiterals) {\n\t\t\t// Invariant: the literal \"not unitLiteral\" is not in\n\t\t\t// `unitLiterals`.\n\t\t\tconst [newUnitLiterals, newAntecedents] = this.assign(unitLiteral, antecedent);\n\t\t\tfor (let i = 0; i < newUnitLiterals.length; i++) {\n\t\t\t\tconst conflict = unitLiterals.pushOrFindConflict(newUnitLiterals[i], newAntecedents[i]);\n\t\t\t\tif (conflict !== null) {\n\t\t\t\t\t// There are two contradicting unit-clauses; we are still\n\t\t\t\t\t// prior to any decisions, so the formula overall must be\n\t\t\t\t\t// unsatisfiable.\n\t\t\t\t\treturn {\n\t\t\t\t\t\tliteral: newUnitLiterals[i],\n\t\t\t\t\t\tliteralAntecedent: newAntecedents[i],\n\t\t\t\t\t\tnegativeLiteralAntecedent: conflict,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/// REQUIRES the given term is currently unassigned.\n\t/// REQUIRES that this assignment doesn't result in any falsified clauses.\n\t/// MODIFIES the data for this term to reflect the new assignment.\n\t/// RETURNS newly created unit-clauses following this assignment.\n\tprivate assign(assignedLiteral: Literal, causingClause: ClauseID | -1): [Literal[], ClauseID[]] {\n\t\tconst discoveredUnitLiterals: Literal[] = [];\n\t\tconst discoveredAntecedents: ClauseID[] = [];\n\n\t\tconst assignedTerm = assignedLiteral > 0 ? assignedLiteral : -assignedLiteral;\n\t\tif (this.assignments[assignedTerm] !== 0) {\n\t\t\tthrow new Error(\"SATSolver.assign() requires literal is not already assigned\");\n\t\t}\n\n\t\tconst watchers = assignedLiteral > 0 ? this.watchedNegative[assignedTerm] : this.watchedPositive[assignedTerm];\n\t\tlet watchersKeepIndex = 0;\n\t\tfor (let wi = 0; wi < watchers.length; wi++) {\n\t\t\tconst watchingClauseID = watchers[wi];\n\t\t\tconst watchingClause = this.clauses[watchingClauseID];\n\n\t\t\tlet satisfiedIndex = -1;\n\t\t\tlet unfalsfiedCount = 0;\n\t\t\tlet latestUnfalsfiedLiteralIndex = -1;\n\t\t\tfor (let i = 0; i < watchingClause.length; i++) {\n\t\t\t\tconst l = watchingClause[i];\n\t\t\t\tconst t = l > 0 ? l : -l;\n\t\t\t\tconst a = this.assignments[t];\n\t\t\t\tconst satisfyiedBy = l > 0 ? +1 : -1;\n\t\t\t\tif (a === satisfyiedBy) {\n\t\t\t\t\tsatisfiedIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (a === 0) {\n\t\t\t\t\tunfalsfiedCount += 1;\n\t\t\t\t\t// N.B.: since watched literals are pushed to the front of\n\t\t\t\t\t// the watchingClause array, if there are any unwatched\n\t\t\t\t\t// unfalsified literals, they will be the result of this\n\t\t\t\t\t// loop.\n\t\t\t\t\tlatestUnfalsfiedLiteralIndex = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Either find a new literal to watch,\n\t\t\t// or recognize that this `watchingClause` is now a unit clause.\n\t\t\tconst destination = watchingClause[0] === -assignedLiteral ? 0 : 1;\n\n\t\t\t// As an optimization, try to prevent more useless wake-ups by\n\t\t\t// swapping this watch with an earlier assigned that satisfied the\n\t\t\t// clause.\n\t\t\tif (satisfiedIndex >= 0) {\n\t\t\t\tif (satisfiedIndex <= 1) {\n\t\t\t\t\t// There are no unwatched satisfied literals in this clause,\n\t\t\t\t\t// so this literal will remain the watcher.\n\t\t\t\t\t// N.B.: without this, this watcher would be cleared at the\n\t\t\t\t\t// end of this loop.\n\t\t\t\t\twatchers[watchersKeepIndex] = watchingClauseID;\n\t\t\t\t\twatchersKeepIndex += 1;\n\t\t\t\t} else {\n\t\t\t\t\t// This clause is already satisfied, and does not require\n\t\t\t\t\t// any further updates or inspection.\n\t\t\t\t\tconst satisfiedLiteral = watchingClause[satisfiedIndex];\n\t\t\t\t\tswap(watchingClause, destination, satisfiedIndex);\n\t\t\t\t\tif (satisfiedLiteral > 0) {\n\t\t\t\t\t\t// Positive\n\t\t\t\t\t\tthis.watchedPositive[satisfiedLiteral].push(watchingClauseID);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Negative\n\t\t\t\t\t\tthis.watchedNegative[-satisfiedLiteral].push(watchingClauseID);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (unfalsfiedCount == 1) {\n\t\t\t\t// `this.assignments` is not yet updated; thus the only\n\t\t\t\t// falsified literal is the one being deleted; so this is a\n\t\t\t\t// conflicting unit-clause.\n\t\t\t\tthrow new Error(`This assignment falsifies the clause #${watchingClauseID}.`\n\t\t\t\t\t+ `\\n(adding assignment ${assignedLiteral} to stack [${this.assignmentStack}];`\n\t\t\t\t\t+ `\\nwatchingClause =#${watchingClauseID} ${watchingClause})`);\n\t\t\t} else if (unfalsfiedCount == 2) {\n\t\t\t\t// `watchingClause` is not yet satisfied, and has no unfalsified\n\t\t\t\t// literals other than its two watched literals.\n\t\t\t\t// Thus, this is becoming a unit clause of only the other\n\t\t\t\t// watched literal.\n\t\t\t\tdiscoveredUnitLiterals.push(watchingClause[1 - destination]);\n\t\t\t\tdiscoveredAntecedents.push(watchingClauseID);\n\n\t\t\t\t// Keep the literal watched, since there isn't another literal\n\t\t\t\t// to watch it.\n\t\t\t\twatchers[watchersKeepIndex] = watchingClauseID;\n\t\t\t\twatchersKeepIndex += 1;\n\t\t\t} else {\n\t\t\t\t// There remains an unfalsified literal, other than the two\n\t\t\t\t// watched literals, in this unsatisfied watchingClause.\n\t\t\t\tconst newWatchedLiteral = watchingClause[latestUnfalsfiedLiteralIndex];\n\t\t\t\tif (newWatchedLiteral > 0) {\n\t\t\t\t\tthis.watchedPositive[newWatchedLiteral].push(watchingClauseID);\n\t\t\t\t} else {\n\t\t\t\t\tthis.watchedNegative[-newWatchedLiteral].push(watchingClauseID);\n\t\t\t\t}\n\n\t\t\t\tswap(watchingClause, destination, latestUnfalsfiedLiteralIndex);\n\t\t\t}\n\t\t}\n\t\twatchers.length = watchersKeepIndex;\n\n\t\tthis.assignments[assignedTerm] = assignedLiteral > 0 ? +1 : -1;\n\t\tthis.assignmentStackPosition[assignedTerm] = this.assignmentStack.length;\n\t\tthis.assignmentStack.push(assignedLiteral);\n\t\tthis.antecedentClause[assignedTerm] = causingClause;\n\t\tthis.termDecisionLevel[assignedTerm] = this.decisionLevel;\n\n\t\treturn [\n\t\t\tdiscoveredUnitLiterals,\n\t\t\tdiscoveredAntecedents,\n\t\t];\n\t}\n\n\tprivate diagnoseConflict(\n\t\tconflict: {\n\t\t\tliteral: Literal,\n\t\t\tliteralAntecedent: ClauseID,\n\t\t\tnegativeLiteralAntecedent: ClauseID,\n\t\t},\n\t): Literal[] {\n\t\t// This method is called when a \"conflict\" is detected:\n\t\t// boolean-constraint-propagation results in a unit clause \"literal\"\n\t\t// and \"not literal\".\n\t\t// `literalAntecedent` indicates the clause within which \"literal\" is a\n\t\t// unit clause; `negativeLiteralAntecedent` indicates the same for\n\t\t// \"not literal\".\n\n\t\t// This method must \"diagnose\" the conflict, producing a new clause\n\t\t// which rejects previous \"decisions\".\n\n\t\t// The simplest diagnosis is to reject the entire set of decision\n\t\t// currently in the assignment stack. However, some of those decisions\n\t\t// may not be relevant to this particular conflict; generating a more\n\t\t// general conflict clause will prune more of the remaining search\n\t\t// space.\n\n\t\t// The `antecedentClause` mapping can be used to generate an\n\t\t// \"implication graph\". The vertices of the graph are literals.\n\t\t// For non-decision variables, an edge exists for the negation of each\n\t\t// other literal in the vertex's selected antecedent clause.\n\n\t\t// This implication graph structure indicates that a vertex is _implied_\n\t\t// by the conjunction of all predecessor vertices. A vertex with no\n\t\t// precedessors is a \"decision variable\", and had a truth value selected\n\t\t// arbitrarily.\n\n\t\t// The problem of \"diagnosing\" a conflict is determing a set of vertices\n\t\t// which transitively imply the conflicting the two conflicting\n\t\t// literals.\n\n\t\t// To drive backtracking solely by conflict clauses, the conflict clause\n\t\t// should be an \"asserting clause\" -- one which will be a unit clause\n\t\t// after unassigning all decisions mentioned in the conflict. This means\n\t\t// it must have only one literal from the latest decision level.\n\n\t\t// The simplest method is \"rel_sat\": resolve all literals in the current\n\t\t// decision level except the decision variable:\n\t\tlet conflictClause = [];\n\t\tlet seen = new Set();\n\n\t\tlet q = [conflict.literal, -conflict.literal];\n\t\tfor (let i = 0; i < q.length; i++) {\n\t\t\tconst literal = q[i];\n\t\t\tconst term = literal > 0 ? literal : -literal;\n\n\t\t\tlet antecedent: ClauseID;\n\t\t\tif (literal == conflict.literal) {\n\t\t\t\tantecedent = conflict.literalAntecedent;\n\t\t\t} else if (literal == -conflict.literal) {\n\t\t\t\tantecedent = conflict.negativeLiteralAntecedent;\n\t\t\t} else {\n\t\t\t\tantecedent = this.antecedentClause[term];\n\t\t\t}\n\n\t\t\tif (antecedent < 0 || (this.termDecisionLevel[term] < this.decisionLevel && literal !== conflict.literal && literal !== -conflict.literal)) {\n\t\t\t\tconflictClause.push(literal);\n\t\t\t} else {\n\t\t\t\tconst clause = this.clauses[antecedent];\n\t\t\t\tfor (let other of clause) {\n\t\t\t\t\tif (other !== literal && !seen.has(other)) {\n\t\t\t\t\t\tseen.add(other);\n\t\t\t\t\t\tq.push(other);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn conflictClause;\n\t}\n\n\trollbackToDecisionLevel(level: number) {\n\t\twhile (this.decisionLevel > level && this.assignmentStack.length > 0) {\n\t\t\tthis.popAssignment();\n\t\t}\n\t\tif (this.assignmentStack.length === 0) {\n\t\t\tif (level > 0) {\n\t\t\t\tthrow new Error(`bad level argument ${level}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tpopAssignment() {\n\t\t// N.B.: The two-watched-literal scheme requires no bookkeeping updates\n\t\t// upon unassignment.\n\t\tconst literal = this.assignmentStack.pop();\n\t\tif (!literal) throw new Error(\"cannot pop when empty\");\n\t\tconst term = literal > 0 ? literal : -literal;\n\t\tthis.assignments[term] = 0;\n\t\tthis.assignmentStackPosition[term] = -1;\n\t\tif (this.antecedentClause[term] < 0) {\n\t\t\tthis.decisionLevel -= 1;\n\t\t}\n\t}\n};\n","import * as sat from \"./sat\";\n\n/// SMTSolver represents an \"satisfiability modulo theories\" instance, with\n/// support for quantifier instantiation.\n/// With respect to refutation, SMTSolver is sound but not complete -- some\n/// returned \"satisfactions\" do not actually satisfy the instance, but all\n/// refutation results definitely refute the instance.\nexport abstract class SMTSolver<E, Counterexample> {\n\tprotected clauses: sat.Literal[][] = [];\n\tprotected unscopedClauses: sat.Literal[][] = [];\n\tprivate scopes: { clauseCount: number }[] = [];\n\n\taddConstraint(constraint: E) {\n\t\tfor (let clause of this.clausify(constraint)) {\n\t\t\tthis.addClausified(clause, this.clauses);\n\t\t}\n\t}\n\n\taddUnscopedConstraint(constraint: E) {\n\t\tfor (const clause of this.clausify(constraint)) {\n\t\t\tthis.addClausified(clause, this.unscopedClauses);\n\t\t}\n\t}\n\n\tprotected addClausified(clause: sat.Literal[], target: sat.Literal[][]) {\n\t\tlet maxTerm = 0;\n\t\tfor (let literal of clause) {\n\t\t\tconst term = literal > 0 ? literal : -literal;\n\t\t\tmaxTerm = Math.max(maxTerm, term);\n\t\t}\n\t\ttarget.push(clause);\n\t}\n\n\tpushScope() {\n\t\tthis.scopes.push({\n\t\t\tclauseCount: this.clauses.length,\n\t\t});\n\t}\n\n\tpopScope() {\n\t\tconst scope = this.scopes.pop();\n\t\tif (scope === undefined) {\n\t\t\tthrow new Error(\"SMTSolver.popScope\");\n\t\t}\n\n\t\tthis.clauses.splice(scope.clauseCount);\n\t}\n\n\t/// RETURNS \"refuted\" when the given constraints can provably not be\n\t/// satisfied.\n\t/// RETURNS a counter example (satisfaction) when refutation fails; this may\n\t/// not be a truly realizable counter-examples, as instantiation and the\n\t/// theory solver may be incomplete.\n\tattemptRefutation(): \"refuted\" | Counterexample {\n\t\tconst solver = new sat.SATSolver();\n\n\t\tfor (const clause of this.unscopedClauses) {\n\t\t\tif (clause.length === 0) {\n\t\t\t\treturn \"refuted\";\n\t\t\t}\n\t\t\tconst maxTerm = Math.max(...clause.map(x => x > 0 ? x : -x));\n\t\t\tsolver.initTerms(maxTerm);\n\t\t\tsolver.addClause(clause);\n\t\t}\n\n\t\tlet progress = 0;\n\n\t\twhile (true) {\n\t\t\twhile (progress < this.clauses.length) {\n\t\t\t\tconst clause = this.clauses[progress];\n\t\t\t\tif (clause.length === 0) {\n\t\t\t\t\treturn \"refuted\";\n\t\t\t\t}\n\t\t\t\tconst maxTerm = Math.max(...clause.map(x => x > 0 ? x : -x));\n\t\t\t\tsolver.initTerms(maxTerm);\n\t\t\t\tsolver.addClause(clause);\n\t\t\t\tprogress += 1;\n\t\t\t}\n\n\t\t\tconst booleanModel = solver.solve();\n\t\t\tif (booleanModel === \"unsatisfiable\") {\n\t\t\t\treturn \"refuted\";\n\t\t\t} else {\n\t\t\t\t// Clausal proof adds additional constraints to the formula, which\n\t\t\t\t// preserve satisfiablity (but not necessarily logical equivalence).\n\t\t\t\t// These are useful in subsequent runs of the solver; HOWEVER,\n\t\t\t\t// clauses which merely preserve satisfiability and not logical\n\t\t\t\t// equivalence must be pruned.\n\t\t\t\t// TODO: Remove (and attempt to re-add) any non-implied clauses.\n\t\t\t\tconst theoryClause = this.rejectModel(booleanModel);\n\t\t\t\tif (Array.isArray(theoryClause)) {\n\t\t\t\t\t// Completely undo the assignment.\n\t\t\t\t\t// TODO: theoryClause should be an asserting clause, so the\n\t\t\t\t\t// logic in backtracking should be able to replace this.\n\t\t\t\t\tsolver.rollbackToDecisionLevel(-1);\n\t\t\t\t\tif (theoryClause.length === 0) {\n\t\t\t\t\t\tthrow new Error(\"TODO: loop zero\");\n\t\t\t\t\t}\n\t\t\t\t\tsolver.addClause(theoryClause);\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: Instantiation may need to take place here.\n\t\t\t\t\t// The SAT+SMT solver has failed to refute the formula.\n\t\t\t\t\tsolver.rollbackToDecisionLevel(-1);\n\t\t\t\t\treturn theoryClause;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/// rejectModel returns a new clause to add to the SAT solver which\n\t/// rejects this concrete assignment.\n\t/// The returned clause should be an asserting clause in reference to the\n\t/// concrete assignment.\n\tprotected abstract rejectModel(concrete: sat.Literal[]): Counterexample | sat.Literal[];\n\n\t/// clausify returns a set of clauses to add to the underlying SAT solver.\n\t/// This modifies state, associating literals (and other internal variables)\n\t/// with the pieces of this constraint, possibly for instantiation.\n\tprotected abstract clausify(constraint: E): sat.Literal[][];\n\n\t/// TODO: Instantiation of quantifiers, which is sometimes done in the place\n\t/// of making decisions in the SATSolver.\n}\n","import { DefaultMap } from \"./data\";\nimport * as egraph from \"./egraph\";\nimport * as ir from \"./ir\";\nimport * as smt from \"./smt\";\n\nexport interface UFCounterexample { }\n\ntype VarID = symbol & { __brand: \"uf-var\" };\nexport type FnID = symbol & { __brand: \"uf-fn\" };\n\ntype Value = VarValue | AppValue | ConstantValue;\n\ninterface VarValue {\n\ttag: \"var\",\n\tvar: VarID,\n}\n\ninterface AppValue {\n\ttag: \"app\",\n\tfn: FnID,\n\targs: ValueID[],\n}\n\ninterface ConstantValue {\n\ttag: \"constant\",\n\tconstant: unknown,\n}\n\n// A (boolean) variable ID.\ntype ReasonSatLiteral = number;\n\nexport type ValueID = egraph.EObject & { __uf: \"uf.ValueID\" };\n\nexport interface Semantics {\n\t/// An `eq` function respects congruence: a == b implies f(a) == f(b).\n\teq?: true,\n\n\tnot?: true,\n\n\t/// A `transitive` function respects transitivity:\n\t/// f(a, b) and f(b, a) implies f(a, c).\n\t/// (This need not be specified for `eq` functions)\n\ttransitive?: true,\n\n\t/// A `transitiveAcyclic` function is a `transitive` function which does not\n\t/// admit cycles (a < b < c < d < ... < a). This implies that the relation\n\t/// is anti-reflexive.\n\ttransitiveAcyclic?: true,\n\n\tinterpreter?: {\n\t\tf(...args: (unknown | null)[]): unknown | null,\n\t},\n}\n\nfunction transitivitySearch<Reason>(\n\tdigraphOutEdges: DefaultMap<symbol, { reason: Set<Reason>, target: symbol }[]>,\n\tsource: symbol,\n\ttarget: symbol,\n): Set<Reason> | null {\n\tconst reached = new Set<symbol>();\n\tconst frontier = [{ source, reason: new Set<Reason>() }];\n\n\twhile (frontier.length !== 0) {\n\t\tconst top = frontier.pop()!;\n\t\tconst outEdges = digraphOutEdges.get(top.source);\n\t\tfor (const outEdge of outEdges) {\n\t\t\tif (!reached.has(outEdge.target)) {\n\t\t\t\tconst reason = new Set([...top.reason, ...outEdge.reason]);\n\t\t\t\tif (outEdge.target === target) {\n\t\t\t\t\treturn reason;\n\t\t\t\t}\n\t\t\t\treached.add(outEdge.target);\n\t\t\t\tfrontier.push({\n\t\t\t\t\tsource: outEdge.target,\n\t\t\t\t\treason,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n\nexport interface Assumption<Reason> {\n\tconstraint: ValueID,\n\tassignment: boolean,\n\treason: Reason,\n};\n\ninterface UFInconsistency<Reason> {\n\ttag: \"inconsistent\",\n\tinconsistent: Set<Reason>,\n}\n\nexport class UFSolver<Reason> {\n\tprivate values = new Map<ValueID, Value>();\n\tprivate fns = new Map<FnID, Semantics>();\n\tprivate egraph = new egraph.EGraph<VarID | FnID, \"constant\", Reason>();\n\n\tprivate constants = new DefaultMap<unknown, ValueID>(constant => {\n\t\tconst varID = Symbol(\"uf-constant\") as VarID;\n\t\tconst object = this.egraph.add(varID, [], \"constant\", String(constant)) as ValueID;\n\t\tthis.values.set(object, { tag: \"constant\", constant });\n\t\treturn object;\n\t});\n\n\tcreateVariable(hint?: string): ValueID {\n\t\tconst varID = Symbol(\"uf-var\") as VarID;\n\t\tconst object = this.egraph.add(varID, [], undefined, hint) as ValueID;\n\t\tthis.values.set(object, { tag: \"var\", var: Symbol(\"uf-var\") as VarID });\n\t\treturn object;\n\t}\n\n\tcreateFn(semantics: Semantics): FnID {\n\t\tconst fnID = Symbol(\"uf-fn\") as FnID;\n\t\tif (semantics.transitiveAcyclic && !semantics.transitive) {\n\t\t\tthrow new Error(\"UFSolver.createFn: semantics.transitiveAcyclic requires semantics.transitive\");\n\t\t}\n\t\tthis.fns.set(fnID, semantics);\n\t\treturn fnID;\n\t}\n\n\tcreateApplication(fn: FnID, args: ValueID[]): ValueID {\n\t\tconst object = this.egraph.add(fn, args) as ValueID;\n\t\tthis.values.set(object, { tag: \"app\", fn, args });\n\t\treturn object;\n\t}\n\n\tcreateConstant(literal: unknown): ValueID {\n\t\treturn this.constants.get(literal);\n\t}\n\n\tgetDefinition(valueID: ValueID): Value {\n\t\tconst value = this.values.get(valueID);\n\t\tif (value === undefined) {\n\t\t\tthrow new Error(\"UFSolver.getDefinition: no such value\");\n\t\t}\n\t\treturn value;\n\t}\n\n\tgetFnSemantics(fnID: FnID): Semantics {\n\t\tconst semantics = this.fns.get(fnID);\n\t\tif (semantics === undefined) {\n\t\t\tthrow new Error(\"UFSolver.getFnSemantics: no such fn\");\n\t\t}\n\t\treturn semantics;\n\t}\n\n\t// Create symbolic constants for the two boolean values.\n\ttrueObject = this.createConstant(true);\n\tfalseObject = this.createConstant(false);\n\n\t/// refuteAssumptions(assumptions) returns a set of facts which the solver\n\t/// has determined are inconsistent, or a model (\"counterexample\") when the\n\t/// facts appear to be consistent.\n\t/// refuteAssumptions() is _sound_ with respect to refutation; when\n\t/// \"inconsistent\" is returned, the assumptions are definitely inconsistent.\n\trefuteAssumptions(\n\t\tassumptions: Assumption<Reason>[],\n\t): UFInconsistency<Reason> | { tag: \"model\", model: UFCounterexample } {\n\t\tthis.egraph.reset();\n\n\t\tfor (const assumption of assumptions) {\n\t\t\tconst truthObject = assumption.assignment\n\t\t\t\t? this.trueObject\n\t\t\t\t: this.falseObject;\n\t\t\tthis.egraph.merge(truthObject, assumption.constraint, new Set([assumption.reason]));\n\t\t}\n\n\t\tlet progress = true;\n\t\twhile (progress) {\n\t\t\tprogress = false;\n\n\t\t\tconst classes = this.egraph.getClasses(true);\n\n\t\t\t// Iterate over all true constraints (those equal to the true\n\t\t\t// object).\n\t\t\tconst trueClass = classes.get(this.trueObject)!;\n\t\t\tfor (const trueMember of trueClass.members) {\n\t\t\t\tconst reasonTrue = this.egraph.query(this.trueObject, trueMember.id)!;\n\t\t\t\tconst handled = this.handleTrueMember(trueMember.term, trueMember.operands as ValueID[], reasonTrue);\n\t\t\t\tif (handled === \"change\") {\n\t\t\t\t\tprogress = true;\n\t\t\t\t} else if (handled !== \"no-change\") {\n\t\t\t\t\treturn handled;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Iterate over all false constraints (those equal to the false\n\t\t\t// object).\n\t\t\tconst falseClass = classes.get(this.falseObject)!;\n\t\t\tfor (const falseMember of falseClass.members) {\n\t\t\t\tconst reasonFalse = this.egraph.query(this.falseObject, falseMember.id)!;\n\t\t\t\tconst handled = this.handleFalseMember(falseMember.term, falseMember.operands as ValueID[], reasonFalse);\n\t\t\t\tif (handled === \"change\") {\n\t\t\t\t\tprogress = true;\n\t\t\t\t} else if (handled !== \"no-change\") {\n\t\t\t\t\treturn handled;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.egraph.updateCongruence()) {\n\t\t\t\tprogress = true;\n\t\t\t}\n\n\t\t\tif (this.propagateFnInterpreters() === \"change\") {\n\t\t\t\tprogress = true;\n\t\t\t}\n\n\t\t\tconst inconsistency = this.findInconsistentConstants()\n\t\t\t\t|| this.findTransitivityContradictions();\n\t\t\tif (inconsistency !== null) {\n\t\t\t\treturn {\n\t\t\t\t\ttag: \"inconsistent\",\n\t\t\t\t\tinconsistent: inconsistency,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// The UFSolver has failed to show that the given assumptions are\n\t\t// inconsistent.\n\t\treturn {\n\t\t\ttag: \"model\",\n\t\t\tmodel: {},\n\t\t};\n\t}\n\n\tprivate handleTrueMember(\n\t\tterm: FnID | VarID,\n\t\toperands: ValueID[],\n\t\treasonTrue: Set<Reason>,\n\t): \"change\" | \"no-change\" | UFInconsistency<Reason> {\n\t\tconst semantics = this.fns.get(term as FnID);\n\t\tif (semantics !== undefined) {\n\t\t\tif (semantics.eq) {\n\t\t\t\tconst newKnowledge = this.egraph.merge(operands[0], operands[1], reasonTrue);\n\t\t\t\tif (newKnowledge) {\n\t\t\t\t\treturn \"change\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"no-change\";\n\t}\n\n\tprivate handleFalseMember(\n\t\tterm: FnID | VarID,\n\t\toperands: ValueID[],\n\t\treasonFalse: Set<Reason>,\n\t): \"change\" | \"no-change\" | UFInconsistency<Reason> {\n\t\tconst semantics = this.fns.get(term as FnID)\n\t\tif (semantics !== undefined) {\n\t\t\tif (semantics.eq) {\n\t\t\t\tconst query = this.egraph.query(operands[0], operands[1]);\n\t\t\t\tif (query !== null) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttag: \"inconsistent\",\n\t\t\t\t\t\tinconsistent: new Set([...query, ...reasonFalse]),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"no-change\";\n\t}\n\n\t/// `evaluateConstant` returns a constant (as it was passed to\n\t/// `createConstant`) that is equal to the given value under the current\n\t/// constraints.\n\tprivate evaluateConstant(value: ValueID): { constant: unknown, reason: Set<Reason> } | null {\n\t\tconst constants = this.egraph.getTagged(\"constant\", value);\n\t\tif (constants.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst id = constants[0].id;\n\t\tconst valueDefinition = this.values.get(id as ValueID);\n\t\tif (valueDefinition?.tag !== \"constant\") {\n\t\t\tthrow new Error(\"UFSolver.evaluateConstant: non-literal tagged\");\n\t\t}\n\t\treturn {\n\t\t\tconstant: valueDefinition.constant,\n\t\t\treason: this.egraph.query(value, id)!,\n\t\t};\n\t}\n\n\t/// `propagateFnInterpreters()` adds additional constants and equalities by\n\t/// using the `interpreter` semantics of functions.\n\tprivate propagateFnInterpreters(): \"change\" | \"no-change\" {\n\t\tlet madeChanges = false;\n\t\twhile (true) {\n\t\t\tlet iterationMadeChanges = false;\n\t\t\tfor (const [eclass, { members }] of this.egraph.getClasses()) {\n\t\t\t\tfor (const member of members) {\n\t\t\t\t\tconst semantics = this.fns.get(member.term as FnID);\n\t\t\t\t\tif (semantics !== undefined) {\n\t\t\t\t\t\tconst interpreter = semantics.interpreter;\n\t\t\t\t\t\tif (interpreter !== undefined) {\n\t\t\t\t\t\t\tconst reason = new Set<Reason>();\n\t\t\t\t\t\t\tconst args = [];\n\t\t\t\t\t\t\tfor (const operand of member.operands) {\n\t\t\t\t\t\t\t\tconst ec = this.evaluateConstant(operand as ValueID);\n\t\t\t\t\t\t\t\tif (ec !== null) {\n\t\t\t\t\t\t\t\t\targs.push(ec.constant);\n\t\t\t\t\t\t\t\t\tfor (const s of ec.reason) {\n\t\t\t\t\t\t\t\t\t\treason.add(s);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\targs.push(null);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst r = interpreter.f(...args);\n\t\t\t\t\t\t\tif (r !== null) {\n\t\t\t\t\t\t\t\tconst constant = this.createConstant(r);\n\t\t\t\t\t\t\t\tconst changed = this.egraph.merge(constant, eclass, reason);\n\t\t\t\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t\t\t\titerationMadeChanges = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!iterationMadeChanges) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmadeChanges = true;\n\t\t}\n\t\treturn madeChanges ? \"change\" : \"no-change\";\n\t}\n\n\tprivate findTransitivityContradictions(): null | Set<Reason> {\n\t\t// A directed graph for each transitive function.\n\t\tconst digraphs = new DefaultMap<FnID, DefaultMap<symbol, { reason: Set<Reason>, target: symbol }[]>>(f => {\n\t\t\treturn new DefaultMap(k => []);\n\t\t});\n\n\t\t// Retrieve the true/false constraints.\n\t\tconst classes = this.egraph.getClasses(true);\n\t\tconst trueClass = classes.get(this.trueObject);\n\t\tconst falseClass = classes.get(this.falseObject);\n\t\tif (trueClass === undefined) {\n\t\t\tthrow new Error(\"findTransitivityContradictions: ICE\");\n\t\t} else if (falseClass === undefined) {\n\t\t\tthrow new Error(\"findTransitivityContradictions: ICE\");\n\t\t}\n\n\t\t// For each transitive function, build a directed graph for each\n\t\t// application in the \"true\" equality class.\n\t\tfor (const app of trueClass.members) {\n\t\t\tconst semantics = this.fns.get(app.term as FnID);\n\t\t\tif (semantics !== undefined && semantics.transitive === true) {\n\t\t\t\tif (app.operands.length !== 2) {\n\t\t\t\t\tthrow new Error(\"findTransitivityContradictions: ICE\");\n\t\t\t\t}\n\n\t\t\t\tconst source = app.operands[0];\n\t\t\t\tconst target = app.operands[1];\n\t\t\t\tconst sourceRep = this.egraph.getRepresentative(source);\n\t\t\t\tconst targetRep = this.egraph.getRepresentative(target);\n\n\t\t\t\tconst reason = new Set([\n\t\t\t\t\t...this.egraph.query(this.trueObject, app.id)!,\n\t\t\t\t\t...this.egraph.query(source, sourceRep)!,\n\t\t\t\t\t...this.egraph.query(target, targetRep)!,\n\t\t\t\t]);\n\t\t\t\tdigraphs.get(app.term as FnID).get(sourceRep).push({\n\t\t\t\t\treason: reason,\n\t\t\t\t\ttarget: targetRep,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Find each negative transitive constraint.\n\t\tfor (const app of falseClass.members) {\n\t\t\tconst semantics = this.fns.get(app.term as FnID);\n\t\t\tif (semantics !== undefined && semantics.transitive === true) {\n\t\t\t\tif (app.operands.length !== 2) {\n\t\t\t\t\tthrow new Error(\"findTransitivityContradictions: ICE\");\n\t\t\t\t}\n\t\t\t\tconst source = app.operands[0];\n\t\t\t\tconst target = app.operands[1];\n\t\t\t\tconst sourceRep = this.egraph.getRepresentative(source);\n\t\t\t\tconst targetRep = this.egraph.getRepresentative(target);\n\n\t\t\t\t// Naively performs a DFS on the set of `<` edges, searching for\n\t\t\t\t// a contradiction.\n\t\t\t\tconst transitiveChain = transitivitySearch(digraphs.get(app.term as FnID), sourceRep, targetRep);\n\t\t\t\tif (transitiveChain !== null) {\n\t\t\t\t\treturn new Set([\n\t\t\t\t\t\t...this.egraph.query(source, sourceRep)!,\n\t\t\t\t\t\t...this.egraph.query(target, targetRep)!,\n\t\t\t\t\t\t...transitiveChain,\n\t\t\t\t\t\t...this.egraph.query(app.id, this.falseObject)!,\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Find violations of transitive-acyclic semantics.\n\t\tfor (const [id] of classes) {\n\t\t\tif (this.egraph.getRepresentative(id) !== id) {\n\t\t\t\t// Only consider e-class representatives.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Search for a path from the group to itself.\n\t\t\tfor (const [fnID, digraph] of digraphs) {\n\t\t\t\tconst semantics = this.fns.get(fnID)!;\n\t\t\t\tif (semantics.transitiveAcyclic === true) {\n\t\t\t\t\tconst transitiveChain = transitivitySearch(digraph, id, id);\n\t\t\t\t\tif (transitiveChain !== null) {\n\t\t\t\t\t\treturn transitiveChain;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/// findInconsistentConstants() returns a set of reasons which are\n\t/// inconsistent because they imply that two distinct constants are equal.\n\tprivate findInconsistentConstants(): null | Set<Reason> {\n\t\tfor (const [id, _group] of this.egraph.getClasses()) {\n\t\t\tconst constants = this.egraph.getTagged(\"constant\", id);\n\t\t\tif (constants.length > 1) {\n\t\t\t\t// Two distinct constants are in the same equality class.\n\t\t\t\treturn new Set([...this.egraph.query(constants[0].id, constants[1].id)!]);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n\n/// UFTheory implements the \"theory of uninterpreted functions\".\n/// This theory understands the properties of equality\n/// (symmetric, reflexive, and transitive)\n/// as well as the \"congruence\" of function application:\n/// a == b implies f(a) == f(b)\nexport class UFTheory extends smt.SMTSolver<ValueID[], UFCounterexample> {\n\t// The UF-theory solver that solves Boolean assignments to theory\n\t// constraints.\n\tprivate solver: UFSolver<ReasonSatLiteral> = new UFSolver();\n\n\t// The next SAT term to vend in clausification.\n\tprivate nextSatTerm = 1;\n\n\t// The SAT term associated with a given Boolean-typed object tracked by the\n\t// solver.\n\tprivate termByObject = new DefaultMap<ValueID, number>(object => {\n\t\tconst term = this.nextSatTerm;\n\t\tthis.nextSatTerm += 1;\n\t\tthis.objectByTerm.set(term, object);\n\t\treturn term;\n\t});\n\n\t// The Boolean-typed object associated with the given SAT term.\n\tprivate objectByTerm = new Map<number, ValueID>();\n\n\tcreateVariable(type: ir.Type): ValueID {\n\t\tconst v = this.solver.createVariable();\n\t\tif (ir.equalTypes(ir.T_BOOLEAN, type)) {\n\t\t\t// Boolean-typed variables must be equal to either true or false.\n\t\t\t// This constraint ensures that the sat solver will commit the\n\t\t\t// variable to a particular assignment.\n\t\t\tthis.addUnscopedConstraint([\n\t\t\t\tthis.createApplication(this.eqFn, [this.solver.trueObject, v]),\n\t\t\t\tthis.createApplication(this.eqFn, [this.solver.falseObject, v]),\n\t\t\t]);\n\t\t}\n\t\treturn v;\n\t}\n\n\tcreateConstant(t: ir.Type, c: unknown): ValueID {\n\t\tif (c === null || c === undefined) {\n\t\t\tthrow new Error(\"createConstant: cannot use `\" + c + \"` as constant\");\n\t\t}\n\t\treturn this.solver.createConstant(c);\n\t}\n\n\tcreateFunction(returnType: ir.Type, semantics: Semantics): FnID {\n\t\treturn this.solver.createFn(semantics);\n\t}\n\n\tprivate eqFn = this.createFunction(ir.T_BOOLEAN, { eq: true });\n\n\tcreateApplication(fnID: FnID, args: ValueID[]): ValueID {\n\t\treturn this.solver.createApplication(fnID, args);\n\t}\n\n\tprivate toSatLiteral(valueID: ValueID): number {\n\t\tconst value = this.solver.getDefinition(valueID);\n\t\tif (value.tag === \"app\") {\n\t\t\tconst semantics = this.solver.getFnSemantics(value.fn);\n\t\t\tif (semantics.not === true) {\n\t\t\t\treturn -this.toSatLiteral(value.args[0]);\n\t\t\t}\n\t\t}\n\t\treturn this.termByObject.get(valueID);\n\t}\n\n\tclausify(disjunction: ValueID[]): number[][] {\n\t\tconst clause = [];\n\t\tfor (const value of disjunction) {\n\t\t\tclause.push(this.toSatLiteral(value));\n\t\t}\n\n\t\treturn [clause];\n\t}\n\n\trejectModel(literals: number[]): UFCounterexample | number[] {\n\t\tconst assumptions: Assumption<ReasonSatLiteral>[] = [];\n\t\tfor (const literal of literals) {\n\t\t\tconst term = literal > 0 ? +literal : -literal;\n\t\t\tconst object = this.objectByTerm.get(term)!;\n\t\t\tassumptions.push({\n\t\t\t\tconstraint: object,\n\t\t\t\tassignment: literal > 0,\n\t\t\t\treason: literal,\n\t\t\t});\n\t\t}\n\t\tconst result = this.solver.refuteAssumptions(assumptions);\n\t\tif (result.tag === \"inconsistent\") {\n\t\t\tconst learnedClause = [];\n\t\t\tfor (const element of result.inconsistent) {\n\t\t\t\tlearnedClause.push(-element);\n\t\t\t}\n\t\t\treturn learnedClause;\n\t\t}\n\t\treturn result.model;\n\t}\n}\n","import { DefaultMap } from \"./data\";\nimport * as diagnostics from \"./diagnostics\";\nimport * as ir from \"./ir\";\nimport { displayType } from \"./semantics\";\nimport * as uf from \"./uf\";\n\nexport function verifyProgram(\n\tprogram: ir.Program,\n): FailedVerification[] {\n\tconst problems = [];\n\n\t// Index impls by their interface signatures.\n\tconst interfaceSignaturesByImplFn = indexInterfaceSignaturesByImplFn(program);\n\n\t// Verify each interface signature.\n\tfor (const i in program.interfaces) {\n\t\tproblems.push(...verifyInterface(program, i, interfaceSignaturesByImplFn));\n\t}\n\n\t// Verify each function body.\n\tfor (let f in program.functions) {\n\t\tproblems.push(...verifyFunction(program, f, interfaceSignaturesByImplFn));\n\t}\n\n\treturn problems;\n}\n\nfunction verifyInterface(\n\tprogram: ir.Program,\n\tinterfaceName: string,\n\tinterfaceSignaturesByImplFn: DefaultMap<ir.FunctionID, IndexedImpl[]>,\n): FailedVerification[] {\n\tconst state = new VerificationState(program, foreignInterpeters, interfaceSignaturesByImplFn);\n\tconst trait = program.interfaces[interfaceName];\n\n\t// Create the type scope for the interface's subjects.\n\tconst interfaceTypeScope = new Map<ir.TypeVariableID, uf.ValueID>();\n\tfor (let i = 0; i < trait.type_parameters.length; i++) {\n\t\tconst typeVariable = trait.type_parameters[i];\n\t\tconst typeID = state.smt.createVariable(ir.T_ANY);\n\t\tinterfaceTypeScope.set(typeVariable, typeID);\n\t}\n\tstate.pushTypeScope(interfaceTypeScope);\n\n\t// Validate that the interface's contracts are well-formed, in that\n\t// they explicitly guarantee their internal preconditions.\n\tfor (const member in trait.signatures) {\n\t\tconst signature = trait.signatures[member];\n\n\t\t// Create the type scope for this member's type parameters.\n\t\tconst signatureTypeScope = new Map<ir.TypeVariableID, uf.ValueID>();\n\t\tfor (let i = 0; i < signature.type_parameters.length; i++) {\n\t\t\tconst typeVariable = signature.type_parameters[i];\n\t\t\tconst typeID = state.smt.createVariable(ir.T_ANY);\n\t\t\tsignatureTypeScope.set(typeVariable, typeID);\n\t\t}\n\n\t\tstate.pushTypeScope(signatureTypeScope);\n\t\tconst functionScope = state.pushVariableScope(true);\n\n\t\t// Create symbolic values for the arguments.\n\t\tfor (const parameter of signature.parameters) {\n\t\t\tstate.defineVariable(parameter, state.smt.createVariable(parameter.type));\n\t\t}\n\n\t\t// Verify that preconditions explicitly state their own preconditions,\n\t\t// and assume that they hold for postconditions.\n\t\tfor (const precondition of signature.preconditions) {\n\t\t\ttraverseBlock(program, new Map(), precondition.block, state, {\n\t\t\t\t// Return ops within a precondition don't have their own\n\t\t\t\t// postconditions.\n\t\t\t\tverifyAtReturn: [],\n\t\t\t}, () => {\n\t\t\t\tstate.assumeGuaranteedInPath(precondition.precondition);\n\t\t\t});\n\t\t}\n\n\t\t// Create symbolic values for the returns.\n\t\tconst symbolicReturned = [];\n\t\tfor (const r of signature.return_types) {\n\t\t\tsymbolicReturned.push(state.smt.createVariable(r));\n\t\t}\n\n\t\tfor (const postcondition of signature.postconditions) {\n\t\t\tconst local = new Map<ir.VariableDefinition, uf.ValueID>();\n\t\t\tfor (let i = 0; i < symbolicReturned.length; i++) {\n\t\t\t\tlocal.set(postcondition.returnedValues[i], symbolicReturned[i]);\n\t\t\t}\n\t\t\ttraverseBlock(program, local, postcondition.block, state, {\n\t\t\t\t// Return ops within a postcondition don't have their own\n\t\t\t\t// postconditions.\n\t\t\t\tverifyAtReturn: [],\n\t\t\t}, () => {\n\t\t\t\tstate.assumeGuaranteedInPath(postcondition.postcondition);\n\t\t\t});\n\t\t}\n\n\t\tstate.popVariableScope(functionScope);\n\t\tstate.popTypeScope();\n\t}\n\n\tstate.popTypeScope();\n\n\treturn state.failedVerifications;\n}\n\ninterface IndexedImpl {\n\timplID: string,\n\tmemberID: string,\n}\n\nfunction indexInterfaceSignaturesByImplFn(\n\tprogram: ir.Program,\n): DefaultMap<ir.FunctionID, IndexedImpl[]> {\n\tconst map = new DefaultMap<ir.FunctionID, IndexedImpl[]>(_ => []);\n\n\t// Add each implementation to the map.\n\tfor (const implID in program.globalVTableFactories) {\n\t\tconst impl = program.globalVTableFactories[implID];\n\t\tfor (const memberID in impl.entries) {\n\t\t\tconst implMember = impl.entries[memberID];\n\t\t\tmap.get(implMember.implementation).push({ implID, memberID });\n\t\t}\n\t}\n\treturn map;\n}\n\nconst foreignInterpeters = {\n\t\"Int+\": {\n\t\tf(a: unknown | null, b: unknown | null): unknown | null {\n\t\t\tif (a === null || b === null) {\n\t\t\t\treturn null;\n\t\t\t} else if (typeof a !== \"bigint\") {\n\t\t\t\tthrow new Error(\"foreignInterpreters['Int+']: got non bigint `\" + a + \"`\");\n\t\t\t} else if (typeof b !== \"bigint\") {\n\t\t\t\tthrow new Error(\"foreignInterpreters['Int+']: got non bigint `\" + b + \"`\");\n\t\t\t}\n\t\t\treturn (a as bigint) + (b as bigint);\n\t\t},\n\t},\n};\n\nfunction assumeStaticPreconditions(\n\tprogram: ir.Program,\n\tsignature: ir.FunctionSignature,\n\tvalueArguments: uf.ValueID[],\n\ttypeArguments: uf.ValueID[],\n\tstate: VerificationState,\n): void {\n\tif (signature.type_parameters.length !== typeArguments.length) {\n\t\tthrow new Error(\"ICE: type argument count mismatch\");\n\t} else if (signature.parameters.length !== valueArguments.length) {\n\t\tthrow new Error(\"ICE: value argument count mismatch\");\n\t}\n\n\tconst typeScope = new Map<ir.TypeVariableID, uf.ValueID>();\n\tfor (let i = 0; i < signature.type_parameters.length; i++) {\n\t\ttypeScope.set(signature.type_parameters[i], typeArguments[i]);\n\t}\n\n\tconst valueScope = new Map<ir.VariableDefinition, uf.ValueID>();\n\tfor (let i = 0; i < signature.parameters.length; i++) {\n\t\tvalueScope.set(signature.parameters[i], valueArguments[i]);\n\t}\n\n\tconst hidingTypeScope = state.pushHidingTypeScope();\n\tstate.pushTypeScope(typeScope);\n\tconst variableScope = state.pushVariableScope(true);\n\n\tfor (let i = 0; i < signature.preconditions.length; i++) {\n\t\tconst precondition = signature.preconditions[i];\n\t\ttraverseBlock(program, valueScope, precondition.block, state, {\n\t\t\t// Return ops within a precondition block do not have their own\n\t\t\t// postconditions.\n\t\t\tverifyAtReturn: [],\n\t\t}, () => {\n\t\t\tstate.assumeGuaranteedInPath(precondition.precondition);\n\t\t});\n\t}\n\n\tstate.popVariableScope(variableScope);\n\tstate.popTypeScope();\n\tstate.popHidingTypeScope(hidingTypeScope);\n}\n\n/// implFnTypeArguments: The arguments to the impl fn. These are the impl's\n/// \"for_any\" type parameters, followed by the interface-signature's type\n/// parameters.\nfunction assumeConstraintPreconditions(\n\tprogram: ir.Program,\n\tvalueArguments: uf.ValueID[],\n\timplFnTypeArguments: uf.ValueID[],\n\timplementing: IndexedImpl,\n\tstate: VerificationState,\n): void {\n\tconst impl = program.globalVTableFactories[implementing.implID];\n\tconst interfaceEntity = program.interfaces[impl.provides.interface];\n\tconst interfaceSignature = interfaceEntity.signatures[implementing.memberID];\n\n\tif (implFnTypeArguments.length !== impl.for_any.length + interfaceSignature.type_parameters.length) {\n\t\tthrow new Error(\"ICE: mismatching implFnTypeArguments.length\");\n\t}\n\n\tconst typeScope = new Map<ir.TypeVariableID, uf.ValueID>();\n\tfor (let i = 0; i < interfaceEntity.type_parameters.length; i++) {\n\t\tconst typeParameter = interfaceEntity.type_parameters[i];\n\t\tconst typeArgument = state.getTypeID(impl.provides.subjects[i]);\n\t\ttypeScope.set(typeParameter, typeArgument);\n\t}\n\tfor (let i = 0; i < interfaceSignature.type_parameters.length; i++) {\n\t\tconst typeParameter = interfaceSignature.type_parameters[i];\n\t\tconst typeArgument = implFnTypeArguments[impl.for_any.length + i];\n\t\ttypeScope.set(typeParameter, typeArgument);\n\t}\n\n\tconst variableScope = new Map<ir.VariableDefinition, uf.ValueID>();\n\tfor (let i = 0; i < valueArguments.length; i++) {\n\t\tvariableScope.set(interfaceSignature.parameters[i], valueArguments[i]);\n\t}\n\n\tconst hidingTypeScope = state.pushHidingTypeScope();\n\tstate.pushTypeScope(typeScope);\n\tconst hidingVariableScope = state.pushVariableScope(true);\n\n\tfor (const precondition of interfaceSignature.preconditions) {\n\t\ttraverseBlock(program, variableScope, precondition.block, state, {\n\t\t\tverifyAtReturn: [],\n\t\t}, () => {\n\t\t\tstate.assumeGuaranteedInPath(precondition.precondition);\n\t\t});\n\t}\n\n\tstate.popVariableScope(hidingVariableScope);\n\tstate.popTypeScope();\n\tstate.popHidingTypeScope(hidingTypeScope);\n}\n\nfunction generateToVerifyFromConstraint(\n\tprogram: ir.Program,\n\tvalueArguments: uf.ValueID[],\n\timplFnTypeArguments: uf.ValueID[],\n\timplementing: IndexedImpl,\n\tstate: VerificationState,\n): VerifyAtReturn[] {\n\tconst impl = program.globalVTableFactories[implementing.implID];\n\tconst interfaceEntity = program.interfaces[impl.provides.interface];\n\tconst interfaceSignature = interfaceEntity.signatures[implementing.memberID];\n\n\tif (implFnTypeArguments.length !== impl.for_any.length + interfaceSignature.type_parameters.length) {\n\t\tthrow new Error(\"ICE: mismatching implFnTypeArguments.length\");\n\t}\n\n\tconst typeScope = new Map<ir.TypeVariableID, uf.ValueID>();\n\tfor (let i = 0; i < interfaceEntity.type_parameters.length; i++) {\n\t\tconst typeParameter = interfaceEntity.type_parameters[i];\n\t\tconst typeArgument = state.getTypeID(impl.provides.subjects[i]);\n\t\ttypeScope.set(typeParameter, typeArgument);\n\t}\n\tfor (let i = 0; i < interfaceSignature.type_parameters.length; i++) {\n\t\tconst typeParameter = interfaceSignature.type_parameters[i];\n\t\tconst typeArgument = implFnTypeArguments[impl.for_any.length + i];\n\t\ttypeScope.set(typeParameter, typeArgument);\n\t}\n\n\tconst out: VerifyAtReturn[] = [];\n\tfor (const postcondition of interfaceSignature.postconditions) {\n\t\tconst variableScope = new Map<ir.VariableDefinition, VerifyAtReturnSource>();\n\t\tfor (let i = 0; i < valueArguments.length; i++) {\n\t\t\tvariableScope.set(interfaceSignature.parameters[i], { tag: \"symbolic\", symbolic: valueArguments[i] });\n\t\t}\n\t\tfor (let i = 0; i < postcondition.returnedValues.length; i++) {\n\t\t\tvariableScope.set(postcondition.returnedValues[i], { tag: \"returned\", returnedIndex: i });\n\t\t}\n\n\t\tout.push({\n\t\t\tpostcondition,\n\t\t\tvariableScope,\n\t\t\ttypeIDScope: typeScope,\n\t\t});\n\t}\n\treturn out;\n}\n\nfunction generateToVerifyFromStatic(\n\tsignature: ir.FunctionSignature,\n\tvalueArguments: uf.ValueID[],\n\ttypeArguments: uf.ValueID[],\n): VerifyAtReturn[] {\n\tif (signature.type_parameters.length !== typeArguments.length) {\n\t\tthrow new Error(\"ICE: type argument count mismatch\");\n\t} else if (signature.parameters.length !== valueArguments.length) {\n\t\tthrow new Error(\"ICE: value argument count mismatch\");\n\t}\n\n\tconst typeScope = new Map<ir.TypeVariableID, uf.ValueID>();\n\tfor (let i = 0; i < signature.type_parameters.length; i++) {\n\t\ttypeScope.set(signature.type_parameters[i], typeArguments[i]);\n\t}\n\n\tconst out: VerifyAtReturn[] = [];\n\tfor (const postcondition of signature.postconditions) {\n\t\t// Setup verify-at-return for this postcondition.\n\t\tconst variableScope = new Map<ir.VariableDefinition, VerifyAtReturnSource>();\n\t\tfor (let i = 0; i < signature.parameters.length; i++) {\n\t\t\tvariableScope.set(signature.parameters[i], { tag: \"symbolic\", symbolic: valueArguments[i] });\n\t\t}\n\t\tfor (let i = 0; i < postcondition.returnedValues.length; i++) {\n\t\t\tvariableScope.set(postcondition.returnedValues[i], { tag: \"returned\", returnedIndex: i });\n\t\t}\n\t\tout.push({\n\t\t\tpostcondition,\n\t\t\tvariableScope,\n\t\t\ttypeIDScope: typeScope,\n\t\t});\n\t}\n\treturn out;\n}\n\nfunction verifyPostconditionWellFormedness(\n\tprogram: ir.Program,\n\tsignature: ir.FunctionSignature,\n\tstate: VerificationState,\n\tverifyAtReturns: VerifyAtReturn[],\n): void {\n\tstate.smt.pushScope();\n\tlet symbolicReturned = [];\n\tfor (const r of signature.return_types) {\n\t\tsymbolicReturned.push(state.smt.createVariable(r));\n\t}\n\tfor (const verifyAtReturn of verifyAtReturns) {\n\t\tconst valueArgs = new Map<ir.VariableDefinition, uf.ValueID>();\n\t\tfor (const [k, v] of verifyAtReturn.variableScope) {\n\t\t\tif (v.tag === \"returned\") {\n\t\t\t\tvalueArgs.set(k, symbolicReturned[v.returnedIndex]);\n\t\t\t} else {\n\t\t\t\tvalueArgs.set(k, v.symbolic);\n\t\t\t}\n\t\t}\n\t\tassumePostcondition(program, valueArgs, verifyAtReturn.typeIDScope, verifyAtReturn.postcondition, state);\n\t}\n\tstate.smt.popScope();\n}\n\n/// interfaceSignaturesByImplFn: Explains which interface signatures each fn\n/// implements. Any preconditions from the indicated interfaces should be\n/// automatically assumed, and any postconditions should be automatically\n/// checked.\nfunction verifyFunction(\n\tprogram: ir.Program,\n\tfName: string,\n\tinterfaceSignaturesByImplFn: DefaultMap<ir.FunctionID, IndexedImpl[]>,\n): FailedVerification[] {\n\tconst interfaceSignatures = interfaceSignaturesByImplFn.get(fName as ir.FunctionID);\n\tconst state = new VerificationState(program, foreignInterpeters, interfaceSignaturesByImplFn);\n\n\tconst f = program.functions[fName];\n\n\t// Create the initial type scope, which maps each type parameter to an\n\t// unknown symbolic type ID constant.\n\tconst typeScope = new Map<ir.TypeVariableID, uf.ValueID>();\n\tconst typeArguments = [];\n\tfor (let i = 0; i < f.signature.type_parameters.length; i++) {\n\t\tconst typeParameter = f.signature.type_parameters[i];\n\t\tconst typeArgument = state.smt.createVariable(ir.T_ANY);\n\t\ttypeArguments.push(typeArgument);\n\t\ttypeScope.set(typeParameter, typeArgument);\n\t}\n\tstate.pushTypeScope(typeScope);\n\n\t// Initialize the function's arguments.\n\tconst symbolicArguments = [];\n\tfor (let i = 0; i < f.signature.parameters.length; i++) {\n\t\tconst parameter = f.signature.parameters[i];\n\n\t\t// Create a symbolic constant for the initial value of the parameter.\n\t\tconst symbolic = state.smt.createVariable(parameter.type);\n\t\tstate.defineVariable(parameter, symbolic);\n\t\tsymbolicArguments.push(symbolic);\n\t}\n\n\t// Execute and validate the function's preconditions.\n\tassumeStaticPreconditions(program, f.signature, symbolicArguments, typeArguments, state);\n\n\tconst verifyAtReturns: VerifyAtReturn[] = [];\n\n\t// Collect postconditions from an impl fn.\n\tfor (const interfaceSignatureReference of interfaceSignatures) {\n\t\tif (f.signature.preconditions.length !== 0) {\n\t\t\tthrow new Error(\"impl function `\" + fName + \"` must not impose explicit preconditions\");\n\t\t}\n\n\t\tassumeConstraintPreconditions(program, symbolicArguments, typeArguments, interfaceSignatureReference, state);\n\t\tverifyAtReturns.push(...generateToVerifyFromConstraint(program, symbolicArguments, typeArguments, interfaceSignatureReference, state));\n\t}\n\n\t// Collect explicit postconditions from a fn.\n\tverifyAtReturns.push(...generateToVerifyFromStatic(f.signature, symbolicArguments, typeArguments));\n\n\t// Validate that the function's postconditions are well-formed, in that they\n\t// explicitly guarantee their internal preconditions.\n\tverifyPostconditionWellFormedness(program, f.signature, state, verifyAtReturns);\n\n\t// Check the function's body (including that each return op guarantees the\n\t// ensured postconditions).\n\ttraverseBlock(program, new Map(), f.body, state, {\n\t\tverifyAtReturn: verifyAtReturns,\n\t});\n\n\tconst lastOp = f.body.ops[f.body.ops.length - 1];\n\tif (!ir.opTerminates(lastOp)) {\n\t\tthrow new Error(\"ICE: verifyFunction invoked on a function which does not obviously terminate\");\n\t}\n\n\treturn state.failedVerifications;\n}\n\n/// Describes what value to bind to a parameter of a postcondition block.\n// \"symbolic\" values are used to supply the original arguments to the\n// postcondition; these can be stored as a \"closure\".\n// \"returned\" values are used to supply the operands of the op-return to the\n// postcondition.\ntype VerifyAtReturnSource =\n\t{ tag: \"symbolic\", symbolic: uf.ValueID }\n\t| { tag: \"returned\", returnedIndex: number };\n\ninterface VerifyAtReturn {\n\tpostcondition: ir.Postcondition,\n\n\t// The full (hiding) scope to use when executing the postcondition body.\n\tvariableScope: Map<ir.VariableDefinition, VerifyAtReturnSource>,\n\n\t// The full (hiding) scope to use when determining the type-ID of a type\n\t// parameter that appears within the postcondition body.\n\ttypeIDScope: Map<ir.TypeVariableID, uf.ValueID>,\n}\n\ninterface VerificationContext {\n\t/// The post-conditions to verify at a ReturnStatement.\n\tverifyAtReturn: VerifyAtReturn[],\n}\n\nexport type FailedVerification = FailedPreconditionVerification\n\t| FailedAssertVerification\n\t| FailedReturnVerification\n\t| FailedPostconditionValidation\n\t| FailedVariantVerification;\n\nexport interface FailedPreconditionVerification {\n\ttag: \"failed-precondition\",\n\tcallLocation: ir.SourceLocation,\n\tpreconditionLocation: ir.SourceLocation,\n}\n\nexport interface FailedPostconditionValidation {\n\ttag: \"failed-postcondition\",\n\treturnLocation: ir.SourceLocation,\n\tpostconditionLocation: ir.SourceLocation,\n}\n\nexport interface FailedAssertVerification {\n\ttag: \"failed-assert\",\n\tassertLocation: ir.SourceLocation,\n}\n\nexport interface FailedReturnVerification {\n\ttag: \"failed-return\",\n\tblockEndLocation?: ir.SourceLocation,\n}\n\nexport interface FailedVariantVerification {\n\ttag: \"failed-variant\",\n\tvariant: string,\n\tenumType: string,\n\taccessLocation: ir.SourceLocation,\n}\n\ninterface SignatureSet {\n\tblockedFunctions: Record<string, boolean>,\n\tblockedInterfaces: Record<string, Record<string, string>>,\n}\n\ninterface VerificationScope {\n\ttoken: symbol,\n\tvariableHiding: boolean,\n\tvariables: Map<ir.VariableID, { type: ir.Type, value: uf.ValueID }>,\n}\n\nclass DynamicFunctionMap {\n\tprivate map = new DefaultMap<ir.InterfaceID, DefaultMap<ir.FunctionID, uf.FnID[]>>(\n\t\ti => new DefaultMap(s => {\n\t\t\tconst interfaceIR = this.program.interfaces[i];\n\t\t\tconst signature = interfaceIR.signatures[s];\n\n\t\t\tconst typeParameters = interfaceIR.type_parameters.concat(signature.type_parameters);\n\t\t\tconst anys = [];\n\t\t\tfor (let i = 0; i < typeParameters.length; i++) {\n\t\t\t\tanys.push(ir.T_ANY);\n\t\t\t}\n\t\t\tconst map = ir.typeArgumentsMap(typeParameters, anys);\n\t\t\tconst rs = signature.return_types.map(r => ir.typeSubstitute(r, map));\n\t\t\treturn rs.map(r => this.smt.createFunction(r, { eq: signature.semantics?.eq }));\n\t\t}));\n\n\tconstructor(private program: ir.Program, private smt: uf.UFTheory) { }\n\n\t/// Retrieves the single function identity across all implementations of the\n\t/// interface.\n\t/// Invocations of the function in the SMT engine take\n\t/// value arguments ++ interface type arguments ++ signature type arguments.\n\tget(interfaceID: ir.InterfaceID, signatureID: ir.FunctionID) {\n\t\treturn this.map.get(interfaceID).get(signatureID);\n\t}\n}\n\ninterface RecordFns {\n\tconstructor: uf.FnID,\n\tfields: Record<string, uf.FnID>,\n\n\t// A function that takes in type arguments (as type IDs) and returns the\n\t// type ID for the \"type application\".\n\ttypeID: uf.FnID,\n}\n\nclass RecordMap {\n\tprivate map = new DefaultMap<ir.RecordID, RecordFns>(r => {\n\t\tconst record = this.program.records[r];\n\t\tconst fields: Record<string, uf.FnID> = {};\n\t\tfor (const k in record.fields) {\n\t\t\tfields[k] = this.smt.createFunction(record.fields[k], {});\n\t\t}\n\n\t\tconst recordType: ir.TypeCompound = {\n\t\t\ttag: \"type-compound\",\n\t\t\tbase: r,\n\t\t\ttype_arguments: record.type_parameters.map(x => ({ tag: \"type-any\" })),\n\t\t};\n\t\treturn {\n\t\t\tconstructor: this.smt.createFunction(recordType, {}),\n\t\t\tfields,\n\t\t\ttypeID: this.smt.createFunction(ir.T_INT, {}),\n\t\t};\n\t});\n\n\tconstructor(private program: ir.Program, private smt: uf.UFTheory) { }\n\n\tconstruct(recordID: ir.RecordID, initialization: Record<string, uf.ValueID>): uf.ValueID {\n\t\tconst info = this.map.get(recordID);\n\t\tconst f = info.constructor;\n\t\tconst args = [];\n\t\tfor (const field in info.fields) {\n\t\t\targs.push(initialization[field]);\n\t\t}\n\t\treturn this.smt.createApplication(f, args);\n\t}\n\n\textractField(recordID: ir.RecordID, field: string, obj: uf.ValueID): uf.ValueID {\n\t\tconst f = this.map.get(recordID).fields[field];\n\t\treturn this.smt.createApplication(f, [obj]);\n\t}\n\n\ttypeID(recordID: ir.RecordID, typeArgumentTypeIDs: uf.ValueID[]): uf.ValueID {\n\t\tconst info = this.map.get(recordID);\n\t\treturn this.smt.createApplication(info.typeID, typeArgumentTypeIDs);\n\t}\n}\n\ninterface EnumVariantFns {\n\textractTag: uf.FnID,\n\tconstructors: Record<string, uf.FnID>,\n\tdestructors: Record<string, uf.FnID>,\n\ttagValues: Record<string, uf.ValueID>,\n\n\t// A function that takes in type arguments (as type IDs) and returns the\n\t// type ID for the \"type application\".\n\ttypeID: uf.FnID,\n};\n\nclass EnumMap {\n\tprivate map = new DefaultMap<ir.EnumID, EnumVariantFns>(enumID => {\n\n\t\tconst constructors: Record<string, uf.FnID> = {};\n\t\tconst destructors: Record<string, uf.FnID> = {};\n\t\tconst tagValues: Record<string, uf.ValueID> = {};\n\n\t\tconst enumEntity = this.program.enums[enumID];\n\n\t\tconst instantiation = new Map<ir.TypeVariableID, ir.Type>();\n\t\tconst enumType: ir.TypeCompound = {\n\t\t\ttag: \"type-compound\",\n\t\t\tbase: enumID,\n\t\t\ttype_arguments: [],\n\t\t};\n\t\tfor (const parameter of enumEntity.type_parameters) {\n\t\t\tinstantiation.set(parameter, ir.T_ANY);\n\t\t\tenumType.type_arguments.push(ir.T_ANY);\n\t\t}\n\n\t\tlet tagIndex = 0;\n\t\tfor (const variant in enumEntity.variants) {\n\t\t\tconst variantType = ir.typeSubstitute(enumEntity.variants[variant], instantiation);\n\t\t\tconstructors[variant] = this.smt.createFunction(enumType, {});\n\t\t\tdestructors[variant] = this.smt.createFunction(variantType, {});\n\t\t\ttagValues[variant] = this.smt.createConstant(ir.T_INT, tagIndex);\n\t\t\ttagIndex += 1;\n\t\t}\n\n\t\treturn {\n\t\t\textractTag: this.smt.createFunction(ir.T_INT, {}),\n\t\t\tconstructors,\n\t\t\tdestructors,\n\t\t\ttagValues,\n\t\t\ttypeID: this.smt.createFunction(ir.T_INT, {}),\n\t\t};\n\t});\n\n\tconstructor(\n\t\tprivate program: ir.Program,\n\t\tprivate smt: uf.UFTheory,\n\t) { }\n\n\thasTag(\n\t\tenumID: ir.EnumID,\n\t\tenumValue: uf.ValueID,\n\t\tvariant: string,\n\t\teq: { eq(a: uf.ValueID, b: uf.ValueID): uf.ValueID },\n\t) {\n\t\tconst info = this.map.get(enumID);\n\t\tconst symbolicTag = this.smt.createApplication(info.extractTag, [enumValue]);\n\t\tconst testTag = info.tagValues[variant];\n\n\t\t// Add a constraint that the tag takes on one of a small number of values.\n\t\tconst finiteAlternativesClause = [];\n\t\tfor (const variant in info.tagValues) {\n\t\t\tconst tagConstant = info.tagValues[variant];\n\t\t\tfiniteAlternativesClause.push(eq.eq(symbolicTag, tagConstant));\n\t\t}\n\n\t\treturn {\n\t\t\ttestResult: eq.eq(symbolicTag, testTag),\n\t\t\tfiniteAlternativesClause,\n\t\t};\n\t}\n\n\tconstruct(\n\t\tenumID: ir.EnumID,\n\t\tvariantValue: uf.ValueID,\n\t\tvariant: string,\n\t): uf.ValueID {\n\t\tconst info = this.map.get(enumID);\n\t\treturn this.smt.createApplication(info.constructors[variant], [variantValue]);\n\t}\n\n\tdestruct(\n\t\tenumID: ir.EnumID,\n\t\tenumValue: uf.ValueID,\n\t\tvariant: string,\n\t): uf.ValueID {\n\t\tconst info = this.map.get(enumID);\n\t\treturn this.smt.createApplication(info.destructors[variant], [enumValue]);\n\t}\n\n\ttypeID(enumID: ir.EnumID, typeArgumentTypeIDs: uf.ValueID[]): uf.ValueID {\n\t\tconst info = this.map.get(enumID);\n\t\treturn this.smt.createApplication(info.typeID, typeArgumentTypeIDs);\n\t}\n}\n\nclass VerificationState {\n\tprivate program: ir.Program;\n\tprivate foreignInterpreters: Record<string, uf.Semantics[\"interpreter\"]>;\n\n\tsmt: uf.UFTheory = new uf.UFTheory();\n\tnotF = this.smt.createFunction(ir.T_BOOLEAN, { not: true });\n\teqF = this.smt.createFunction(ir.T_BOOLEAN, { eq: true });\n\tcontainsF = this.smt.createFunction(ir.T_BOOLEAN, { transitive: true, transitiveAcyclic: true });\n\n\t/// Generates a SMT function for each return of each Shiru fn.\n\t/// The first parameters are the type arguments (type id).\n\tfunctions: DefaultMap<ir.FunctionID, uf.FnID[]> = new DefaultMap(fnID => {\n\t\tconst fn = this.program.functions[fnID];\n\t\tif (fn === undefined) {\n\t\t\tthrow new Error(\"VerificationState.functions.get: undefined `\" + fnID + \"`\");\n\t\t}\n\t\tconst instantiation = new Map<ir.TypeVariableID, ir.Type>();\n\t\tfor (let i = 0; i < fn.signature.type_parameters.length; i++) {\n\t\t\tinstantiation.set(fn.signature.type_parameters[i], ir.T_ANY);\n\t\t}\n\n\t\tconst out = [];\n\t\tfor (const r of fn.signature.return_types) {\n\t\t\t// Use a more generic \"Any\" type.\n\t\t\tconst resultType = ir.typeSubstitute(r, instantiation);\n\t\t\tout.push(this.smt.createFunction(resultType, { eq: fn.signature.semantics?.eq }));\n\t\t}\n\t\treturn out;\n\t});\n\n\tforeign = new DefaultMap<string, uf.FnID[]>(op => {\n\t\tconst fn = this.program.foreign[op];\n\t\tif (fn === undefined) {\n\t\t\tthrow new Error(\"VerificationState.foreign.get: undefined `\" + op + \"`\");\n\t\t}\n\t\tconst out = [];\n\t\tfor (const r of fn.return_types) {\n\t\t\tout.push(this.smt.createFunction(r, {\n\t\t\t\teq: fn.semantics?.eq,\n\t\t\t\tinterpreter: this.foreignInterpreters[op],\n\t\t\t}));\n\t\t}\n\t\treturn out;\n\t});\n\n\tdynamicFunctions: DynamicFunctionMap;\n\trecordMap: RecordMap;\n\tenumMap: EnumMap;\n\n\trecursivePreconditions: SignatureSet = {\n\t\tblockedFunctions: {},\n\t\tblockedInterfaces: {},\n\t};\n\n\trecursivePostconditions: SignatureSet = {\n\t\tblockedFunctions: {},\n\t\tblockedInterfaces: {},\n\t};\n\n\t/// `varScopes` is a stack of variable mappings. SSA variables aren't\n\t/// reassigned, but can be shadowed (including within the same block).\n\tprivate varScopes: Array<VerificationScope> = [\n\t\t{\n\t\t\ttoken: Symbol(\"root-scope\"),\n\t\t\tvariableHiding: true,\n\t\t\tvariables: new Map(),\n\t\t}\n\t];\n\n\t/// `typeScopes` is a stack of type parameter --> TypeID values.\n\tprivate typeScopes: Array<Map<ir.TypeVariableID, uf.ValueID> | symbol> = [];\n\n\t/// Pushing a hiding scope hides all previous associations, allowing errors\n\t/// to be noticed more easily.\n\tpushHidingTypeScope(): symbol {\n\t\tconst token = Symbol(\"hiding-type-scope\");\n\t\tthis.typeScopes.push(token);\n\t\treturn token;\n\t}\n\n\tpushTypeScope(scope: Map<ir.TypeVariableID, uf.ValueID>) {\n\t\tthis.typeScopes.push(scope);\n\t}\n\n\tpopTypeScope() {\n\t\tconst top = this.typeScopes.pop();\n\t\tif (top === undefined) {\n\t\t\tthrow new Error(\"popTypeScope: no scope open\");\n\t\t} else if (!(top instanceof Map)) {\n\t\t\tthrow new Error(\"popTypeScope: hiding scope open; expected call to popHidingTypeScope().\");\n\t\t}\n\t}\n\n\tpopHidingTypeScope(expected: symbol) {\n\t\tconst top = this.typeScopes.pop();\n\t\tif (top !== expected) {\n\t\t\tthrow new Error(\"popHidingTypeScope: did not find expected hiding type scope\");\n\t\t}\n\t}\n\n\tprivate unitTypeID = this.smt.createConstant(ir.T_INT, 21);\n\tprivate booleanTypeID = this.smt.createConstant(ir.T_INT, 22);\n\tprivate intTypeID = this.smt.createConstant(ir.T_INT, 23);\n\tprivate bytesTypeID = this.smt.createConstant(ir.T_INT, 24);\n\tprivate anyTypeID = this.smt.createConstant(ir.T_INT, 25);\n\n\t/// `getTypeID` generates a symbolic constant representing the given type.\n\tgetTypeID(t: ir.Type): uf.ValueID {\n\t\tif (t.tag === \"type-any\") {\n\t\t\treturn this.anyTypeID;\n\t\t} else if (t.tag === \"type-primitive\") {\n\t\t\tif (t.primitive === \"Unit\") {\n\t\t\t\treturn this.unitTypeID;\n\t\t\t} else if (t.primitive === \"Boolean\") {\n\t\t\t\treturn this.booleanTypeID;\n\t\t\t} else if (t.primitive === \"Int\") {\n\t\t\t\treturn this.intTypeID;\n\t\t\t} else if (t.primitive === \"Bytes\") {\n\t\t\t\treturn this.bytesTypeID;\n\t\t\t} else {\n\t\t\t\tconst un: never = t.primitive;\n\t\t\t\tthrow new Error(\"getTypeID: unhandled primitive `\" + un + \"`\");\n\t\t\t}\n\t\t} else if (t.tag === \"type-variable\") {\n\t\t\tfor (let i = this.typeScopes.length - 1; i >= 0; i--) {\n\t\t\t\tconst scope = this.typeScopes[i];\n\t\t\t\tif (typeof scope === \"symbol\") {\n\t\t\t\t\tthrow new Error(\"getTypeID: unmapped type-variable within hiding scope: `\" + t.id + \"`\");\n\t\t\t\t}\n\t\t\t\tconst mapping = scope.get(t.id);\n\t\t\t\tif (mapping !== undefined) {\n\t\t\t\t\treturn mapping;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new Error(\"getTypeID: unmapped type-variable `\" + t.id + \"`\");\n\t\t} else if (t.tag === \"type-compound\") {\n\t\t\tconst args = t.type_arguments.map(x => this.getTypeID(x));\n\t\t\tconst base = t.base;\n\t\t\tif (this.program.records[base] !== undefined) {\n\t\t\t\treturn this.recordMap.typeID(base as ir.RecordID, args);\n\t\t\t} else {\n\t\t\t\treturn this.enumMap.typeID(base as ir.EnumID, args);\n\t\t\t}\n\t\t} else {\n\t\t\tconst un: never = t;\n\t\t\tthrow new Error(\"getTypeID: unhandled type tag `\" + un[\"tag\"] + \"`\");\n\t\t}\n\t}\n\n\t/// `pathConstraints` is the stack of conditional constraints that must be\n\t/// true to reach a position in the program.\n\tprivate pathConstraints: uf.ValueID[] = [];\n\n\t// Verification adds failure messages to this stack as they are encountered.\n\t// Multiple failures can be returned.\n\tfailedVerifications: FailedVerification[] = [];\n\n\tinterfaceSignaturesByImplFn: DefaultMap<ir.FunctionID, IndexedImpl[]>;\n\n\tconstructor(\n\t\tprogram: ir.Program,\n\t\tforeignInterpeters: Record<string, uf.Semantics[\"interpreter\"]>,\n\t\tinterfaceSignaturesByImplFn: DefaultMap<ir.FunctionID, IndexedImpl[]>,\n\t) {\n\t\tthis.program = program;\n\t\tthis.foreignInterpreters = foreignInterpeters;\n\t\tthis.dynamicFunctions = new DynamicFunctionMap(this.program, this.smt);\n\t\tthis.recordMap = new RecordMap(this.program, this.smt);\n\t\tthis.enumMap = new EnumMap(this.program, this.smt);\n\t\tthis.interfaceSignaturesByImplFn = interfaceSignaturesByImplFn;\n\n\t\t// SMT requires at least one constraint.\n\t\tthis.smt.addConstraint([\n\t\t\tthis.smt.createConstant(ir.T_BOOLEAN, true),\n\t\t]);\n\t}\n\n\tnegate(bool: uf.ValueID): uf.ValueID {\n\t\treturn this.smt.createApplication(this.notF, [bool]);\n\t}\n\n\teq(left: uf.ValueID, right: uf.ValueID): uf.ValueID {\n\t\treturn this.smt.createApplication(this.eqF, [left, right]);\n\t}\n\n\n\tisSmallerThan(left: uf.ValueID, right: uf.ValueID): uf.ValueID {\n\t\treturn this.smt.createApplication(this.containsF, [left, right]);\n\t}\n\n\tpushVariableScope(variableHiding: boolean): symbol {\n\t\tconst token = Symbol(\"variable-scope\");\n\t\tthis.varScopes.push({\n\t\t\ttoken,\n\t\t\tvariableHiding,\n\t\t\tvariables: new Map(),\n\t\t});\n\t\treturn token;\n\t}\n\n\tpopVariableScope(expected: symbol): void {\n\t\tconst top = this.varScopes.pop();\n\t\tif (!top || top.token !== expected) {\n\t\t\tthrow new Error(\"popVariableScope: did not find expected scope\");\n\t\t}\n\t}\n\n\t/// Modifies this state so that it assumes the given condition is always\n\t/// true when at this path in the program.\n\tassumeGuaranteedInPath(condition: ir.VariableID): void {\n\t\tthis.pushPathConstraint(this.negate(this.getValue(condition).value));\n\t\tthis.markPathUnreachable();\n\t\tthis.popPathConstraint();\n\t}\n\n\tpushPathConstraint(c: uf.ValueID) {\n\t\tthis.pathConstraints.push(c);\n\t}\n\n\tpopPathConstraint() {\n\t\tthis.pathConstraints.pop();\n\t}\n\n\t/// Determines whether or not the given condition is possibly false given\n\t/// the current path constraints.\n\t/// Returns `\"refuted\"` when it is not possible for the condition to be\n\t/// false.\n\tcheckPossiblyFalseInPath(\n\t\tcondition: ir.VariableID,\n\t\treason: FailedVerification,\n\t): uf.UFCounterexample | \"refuted\" {\n\t\tthis.pushPathConstraint(this.negate(this.getValue(condition).value));\n\t\tconst reply = this.checkReachable(reason);\n\t\tthis.popPathConstraint();\n\t\treturn reply;\n\t}\n\n\t/// `checkReachable` checks whether or not the conjunction of current path\n\t/// constraints, combined with all other constraints added to the `smt`\n\t/// solver, is reachable or not.\n\tcheckReachable(reason: FailedVerification): uf.UFCounterexample | \"refuted\" {\n\t\tthis.smt.pushScope();\n\t\tfor (const constraint of this.pathConstraints) {\n\t\t\tthis.smt.addConstraint([constraint]);\n\t\t}\n\t\tconst model = this.smt.attemptRefutation();\n\t\tthis.smt.popScope();\n\t\treturn model;\n\t}\n\n\t/// `markPathUnreachable` ensures that the conjunction of the current path\n\t/// constraints is considered not satisfiable in subsequent invocations of\n\t/// the `smt` solver.\n\tmarkPathUnreachable() {\n\t\tconst pathUnreachable = this.pathConstraints.map(e => this.negate(e));\n\t\tthis.smt.addConstraint(pathUnreachable);\n\t}\n\n\t/// `defineVariable` associates the given symbolic value with the given\n\t/// name for the remainder of the current innermost scope.\n\tdefineVariable(variable: ir.VariableDefinition, value: uf.ValueID) {\n\t\tconst scope = this.varScopes[this.varScopes.length - 1];\n\t\tscope.variables.set(variable.variable, {\n\t\t\ttype: variable.type,\n\t\t\tvalue: value,\n\t\t});\n\t}\n\n\t/// `getValue` retrieves the value associated with the given name from the\n\t/// innermost scope that defines it.\n\tgetValue(variable: ir.VariableID) {\n\t\tfor (let i = this.varScopes.length - 1; i >= 0; i--) {\n\t\t\tconst scope = this.varScopes[i];\n\t\t\tconst value = scope.variables.get(variable);\n\t\t\tif (value !== undefined) {\n\t\t\t\treturn value;\n\t\t\t} else if (scope.variableHiding) {\n\t\t\t\tthrow new Error(\"getValue: variable `\" + variable + \"` is not defined within the containing hiding scope\");\n\t\t\t}\n\t\t}\n\t\tthrow new Error(\"getValue: variable `\" + variable + \"` is not defined\");\n\t}\n}\n\nfunction traverseBlock(\n\tprogram: ir.Program,\n\tlocals: Map<ir.VariableDefinition, uf.ValueID>,\n\tblock: ir.OpBlock,\n\tstate: VerificationState,\n\tcontext: VerificationContext,\n\tthen?: () => unknown,\n) {\n\t// Blocks bound variable scopes, so variables must be cleared after.\n\tconst variableScope = state.pushVariableScope(false);\n\n\tfor (const [k, v] of locals) {\n\t\tstate.defineVariable(k, v);\n\t}\n\n\tfor (let subop of block.ops) {\n\t\ttraverse(program, subop, state, context);\n\t}\n\n\t// Execute the final computation before exiting this scope.\n\tif (then !== undefined) {\n\t\tthen();\n\t}\n\n\t// Clear variables defined within this block.\n\tstate.popVariableScope(variableScope);\n}\n\n// MUTATES the verification state parameter, to add additional clauses that are\n// ensured after the execution (and termination) of this operation.\nfunction traverse(program: ir.Program, op: ir.Op, state: VerificationState, context: VerificationContext): void {\n\tif (op.tag === \"op-branch\") {\n\t\tconst symbolicCondition: uf.ValueID = state.getValue(op.condition).value;\n\n\t\tconst phis: uf.ValueID[] = [];\n\t\tfor (const destination of op.destinations) {\n\t\t\tphis.push(state.smt.createVariable(destination.destination.type));\n\t\t}\n\n\t\tstate.pushPathConstraint(symbolicCondition);\n\t\ttraverseBlock(program, new Map(), op.trueBranch, state, context, () => {\n\t\t\tfor (let i = 0; i < op.destinations.length; i++) {\n\t\t\t\tconst destination = op.destinations[i];\n\t\t\t\tconst source = destination.trueSource;\n\t\t\t\tif (source === \"undef\") continue;\n\t\t\t\tstate.smt.addUnscopedConstraint([\n\t\t\t\t\tstate.negate(symbolicCondition),\n\t\t\t\t\tstate.eq(phis[i], state.getValue(source.variable).value),\n\t\t\t\t]);\n\t\t\t}\n\t\t})\n\t\tstate.popPathConstraint();\n\n\t\tstate.pushPathConstraint(state.negate(symbolicCondition));\n\t\ttraverseBlock(program, new Map(), op.falseBranch, state, context, () => {\n\t\t\tfor (let i = 0; i < op.destinations.length; i++) {\n\t\t\t\tconst destination = op.destinations[i];\n\t\t\t\tconst source = destination.falseSource;\n\t\t\t\tif (source === \"undef\") continue;\n\t\t\t\tstate.smt.addUnscopedConstraint([\n\t\t\t\t\tsymbolicCondition,\n\t\t\t\t\tstate.eq(phis[i], state.getValue(source.variable).value),\n\t\t\t\t]);\n\t\t\t}\n\t\t});\n\t\tstate.popPathConstraint();\n\n\t\tfor (let i = 0; i < op.destinations.length; i++) {\n\t\t\tstate.defineVariable(op.destinations[i].destination, phis[i]);\n\t\t}\n\n\t\treturn;\n\t} else if (op.tag === \"op-const\") {\n\t\t// Like assignment, this requires no manipulation of constraints, only\n\t\t// the state of variables.\n\t\tlet constant: uf.ValueID;\n\t\tif (op.type === \"Int\") {\n\t\t\tconstant = state.smt.createConstant(op.destination.type, BigInt(op.int));\n\t\t} else if (op.type === \"Boolean\") {\n\t\t\tconstant = state.smt.createConstant(op.destination.type, op.boolean);\n\t\t} else if (op.type === \"Bytes\") {\n\t\t\tconstant = state.smt.createConstant(op.destination.type, op.bytes);\n\t\t} else {\n\t\t\tconst _: never = op;\n\t\t\tthrow new Error(\"traverse: unexpected op-const type `\" + op[\"type\"] + \"`\");\n\t\t}\n\t\tstate.defineVariable(op.destination, constant);\n\t\treturn;\n\t} else if (op.tag === \"op-copy\") {\n\t\tfor (const copy of op.copies) {\n\t\t\tstate.defineVariable(copy.destination, state.getValue(copy.source).value);\n\t\t}\n\t\treturn;\n\t} else if (op.tag === \"op-field\") {\n\t\tconst object = state.getValue(op.object);\n\t\tconst baseType = object.type as ir.TypeCompound & { base: ir.RecordID };\n\t\tconst fieldValue = state.recordMap.extractField(baseType.base, op.field, object.value);\n\t\tstate.smt.addUnscopedConstraint([state.isSmallerThan(fieldValue, object.value)]);\n\t\tstate.defineVariable(op.destination, fieldValue);\n\t\treturn;\n\t} else if (op.tag === \"op-is-variant\") {\n\t\tconst object = state.getValue(op.base);\n\t\tconst baseType = object.type as ir.TypeCompound & { base: ir.EnumID };\n\n\t\tconst tagInfo = state.enumMap.hasTag(baseType.base, object.value, op.variant, state);\n\t\tstate.smt.addUnscopedConstraint(tagInfo.finiteAlternativesClause);\n\t\tstate.defineVariable(op.destination, tagInfo.testResult);\n\t\treturn;\n\t} else if (op.tag === \"op-variant\") {\n\t\tconst object = state.getValue(op.object);\n\t\tconst baseType = object.type as ir.TypeCompound & { base: ir.EnumID };\n\n\t\tconst tagInfo = state.enumMap.hasTag(baseType.base, object.value, op.variant, state);\n\t\tstate.smt.addUnscopedConstraint(tagInfo.finiteAlternativesClause);\n\n\t\t// Check that the symbolic tag definitely matches this variant.\n\t\tstate.pushPathConstraint(\n\t\t\tstate.negate(tagInfo.testResult)\n\t\t);\n\t\tconst reason: FailedVariantVerification = {\n\t\t\ttag: \"failed-variant\",\n\t\t\tenumType: baseType.base + \"[???]\",\n\t\t\tvariant: op.variant,\n\t\t\taccessLocation: op.diagnostic_location,\n\t\t};\n\t\tconst refutation = state.checkReachable(reason);\n\t\tif (refutation !== \"refuted\") {\n\t\t\treason.enumType = displayType(baseType);\n\t\t\tstate.failedVerifications.push(reason);\n\t\t}\n\n\t\tstate.markPathUnreachable();\n\t\tstate.popPathConstraint();\n\n\t\t// Extract the field.\n\t\tconst variantValue = state.enumMap.destruct(baseType.base, object.value, op.variant);\n\t\tstate.smt.addUnscopedConstraint([state.isSmallerThan(variantValue, object.value)]);\n\t\tstate.defineVariable(op.destination, variantValue);\n\t\treturn;\n\t} else if (op.tag === \"op-new-record\") {\n\t\tconst fields: Record<string, uf.ValueID> = {}\n\t\tfor (const field in op.fields) {\n\t\t\tfields[field] = state.getValue(op.fields[field]).value;\n\t\t}\n\t\tconst recordType = op.destination.type as ir.TypeCompound & { base: ir.RecordID };\n\t\tconst recordValue = state.recordMap.construct(recordType.base, fields);\n\t\tstate.defineVariable(op.destination, recordValue);\n\t\treturn;\n\t} else if (op.tag === \"op-new-enum\") {\n\t\tconst enumType = op.destination.type as ir.TypeCompound & { base: ir.EnumID };\n\t\tconst variantValue = state.getValue(op.variantValue).value;\n\t\tconst enumValue = state.enumMap.construct(enumType.base, variantValue, op.variant);\n\t\tstate.defineVariable(op.destination, enumValue);\n\n\t\tconst tagInfo = state.enumMap.hasTag(enumType.base, enumValue, op.variant, state);\n\t\tstate.smt.addUnscopedConstraint([tagInfo.testResult]);\n\n\t\tconst destruction = state.enumMap.destruct(enumType.base, enumValue, op.variant);\n\t\tstate.smt.addUnscopedConstraint([state.eq(destruction, variantValue)]);\n\t\treturn;\n\t} else if (op.tag === \"op-proof\") {\n\t\treturn traverseBlock(program, new Map(), op.body, state, context);\n\t} else if (op.tag === \"op-return\") {\n\t\tif (context.verifyAtReturn.length !== 0) {\n\t\t\t// Check that the postconditions from the context are satisfied by\n\t\t\t// this return.\n\t\t\tconst returnedValues = [];\n\t\t\tfor (let i = 0; i < op.sources.length; i++) {\n\t\t\t\treturnedValues.push(state.getValue(op.sources[i]).value);\n\t\t\t}\n\t\t\tcheckVerifyAtReturns(program, state, returnedValues, context.verifyAtReturn, op.diagnostic_return_site);\n\t\t}\n\n\t\t// Subsequently, this path is treated as unreachable, since the function\n\t\t// exited.\n\t\tstate.markPathUnreachable();\n\t\treturn;\n\t} else if (op.tag === \"op-foreign\") {\n\t\tconst signature = program.foreign[op.operation];\n\n\t\tfor (let precondition of signature.preconditions) {\n\t\t\tthrow new Error(\"TODO: Check precondition of op-foreign\");\n\t\t}\n\n\t\tfor (let postcondition of signature.postconditions) {\n\t\t\tthrow new Error(\"TODO: Assume postcondition of op-foreign\");\n\t\t}\n\n\t\tconst args = [];\n\t\tfor (let i = 0; i < op.arguments.length; i++) {\n\t\t\targs.push(state.getValue(op.arguments[i]).value);\n\t\t}\n\n\t\tif (signature.semantics?.eq === true) {\n\t\t\tif (op.arguments.length !== 2) {\n\t\t\t\tthrow new Error(\"Foreign signature with `eq` semantics\"\n\t\t\t\t\t+ \" must take exactly 2 arguments (\" + op.operation + \")\");\n\t\t\t} else if (op.destinations.length !== 1) {\n\t\t\t\tthrow new Error(\"Foreign signature with `eq` semantics\"\n\t\t\t\t\t+ \" must return exactly 1 value\");\n\t\t\t}\n\t\t\tconst destination = op.destinations[0];\n\t\t\tstate.defineVariable(destination, state.eq(args[0], args[1]));\n\t\t} else {\n\t\t\tconst fIDs = state.foreign.get(op.operation);\n\t\t\tfor (let i = 0; i < op.destinations.length; i++) {\n\t\t\t\tstate.defineVariable(op.destinations[i], state.smt.createApplication(fIDs[i], args));\n\t\t\t}\n\t\t}\n\t\treturn;\n\t} else if (op.tag === \"op-static-call\") {\n\t\ttraverseStaticCall(program, op, state);\n\t\treturn;\n\t} else if (op.tag === \"op-dynamic-call\") {\n\t\ttraverseDynamicCall(program, op, state);\n\t\treturn;\n\t} else if (op.tag === \"op-unreachable\") {\n\t\t// TODO: Better classify verification failures.\n\t\tconst reason: FailedVerification = op.diagnostic_kind === \"return\"\n\t\t\t? {\n\t\t\t\ttag: \"failed-return\",\n\t\t\t\tblockEndLocation: op.diagnostic_location,\n\t\t\t}\n\t\t\t: {\n\t\t\t\ttag: \"failed-assert\",\n\t\t\t\tassertLocation: op.diagnostic_location,\n\t\t\t};\n\n\t\tif (state.checkReachable(reason) !== \"refuted\") {\n\t\t\tstate.failedVerifications.push(reason);\n\t\t}\n\n\t\t// Like a return statement, this path is subsequently treated as\n\t\t// unreachable.\n\t\tstate.markPathUnreachable();\n\t\treturn;\n\t} else if (op.tag === \"op-proof-eq\") {\n\t\tconst leftObject = state.getValue(op.left);\n\t\tconst rightObject = state.getValue(op.right);\n\n\t\tstate.defineVariable(op.destination, state.eq(leftObject.value, rightObject.value));\n\t\treturn;\n\t}\n\n\tconst _: never = op;\n\tthrow new Error(`unhandled op ${op[\"tag\"]}`);\n}\n\n/// checkPrecondition inspects the state and ensures that the precondition\n/// invoked with the given scope is satisfied.\nfunction checkPrecondition(\n\tprogram: ir.Program,\n\tvalueArgs: Map<ir.VariableDefinition, uf.ValueID>,\n\ttypeArgs: Map<ir.TypeVariableID, uf.ValueID>,\n\tprecondition: ir.Precondition,\n\tstate: VerificationState,\n\treason: FailedVerification,\n): void {\n\t// When contracts of `fn` refer to a type parameter like `#T`, its symbolic\n\t// type ID will be retrieved from only the `typeArgs` map:\n\tconst hidingTypeScope = state.pushHidingTypeScope();\n\tstate.pushTypeScope(typeArgs);\n\n\ttraverseBlock(program, valueArgs, precondition.block, state, {\n\t\t// Return ops within a precondition do not have their own\n\t\t// postconditions.\n\t\tverifyAtReturn: [],\n\t}, () => {\n\t\tif (state.checkPossiblyFalseInPath(precondition.precondition, reason) !== \"refuted\") {\n\t\t\tstate.failedVerifications.push(reason);\n\t\t}\n\t});\n\n\tstate.popTypeScope();\n\tstate.popHidingTypeScope(hidingTypeScope);\n}\n\n/// assumePostcondition modifies the state so that subsequent inspections can\n/// assume that this postcondition, invoked with the given scope, is satisfied.\nfunction assumePostcondition(\n\tprogram: ir.Program,\n\tvalueArgs: Map<ir.VariableDefinition, uf.ValueID>,\n\ttypeArgs: Map<ir.TypeVariableID, uf.ValueID>,\n\tpostcondition: ir.Postcondition,\n\tstate: VerificationState,\n): void {\n\t// When contracts of `fn` refer to a type parameter like `#T`, its symbolic\n\t// type ID will be retrieved from only the `subscope` map:\n\tconst hidingTypeScope = state.pushHidingTypeScope();\n\tstate.pushTypeScope(typeArgs);\n\tconst postconditionScope = state.pushVariableScope(true);\n\n\ttraverseBlock(program, valueArgs, postcondition.block, state, {\n\t\t// Return ops within a postcondition do not have their own postconditions.\n\t\tverifyAtReturn: [],\n\t}, () => {\n\t\tstate.assumeGuaranteedInPath(postcondition.postcondition);\n\t});\n\n\tstate.popVariableScope(postconditionScope);\n\tstate.popTypeScope();\n\tstate.popHidingTypeScope(hidingTypeScope);\n}\n\n/// checkVerifyAtReturns inspects the current state to determine whether or not\n/// each postcondition is satisfied by the given returned values.\nfunction checkVerifyAtReturns(\n\tprogram: ir.Program,\n\tstate: VerificationState,\n\treturnedValues: uf.ValueID[],\n\tverifyAtReturns: VerifyAtReturn[],\n\tdiagnosticReturnLocation: ir.SourceLocation,\n): void {\n\tfor (const verifyAtReturn of verifyAtReturns) {\n\t\t// Bind the necessary inputs (parameters, returned values) for\n\t\t// the postcondition.\n\t\tconst locals = new Map<ir.VariableDefinition, uf.ValueID>();\n\t\tfor (const [key, spec] of verifyAtReturn.variableScope) {\n\t\t\tif (spec.tag === \"returned\") {\n\t\t\t\tlocals.set(key, returnedValues[spec.returnedIndex]);\n\t\t\t} else {\n\t\t\t\tconst symbolicSource = spec.symbolic;\n\t\t\t\tlocals.set(key, symbolicSource);\n\t\t\t}\n\t\t}\n\n\t\tconst postconditionTypeScope = state.pushHidingTypeScope();\n\t\tstate.pushTypeScope(verifyAtReturn.typeIDScope);\n\t\tconst postconditionVariableScope = state.pushVariableScope(true);\n\n\t\ttraverseBlock(program, locals, verifyAtReturn.postcondition.block, state, {\n\t\t\t// Return ops within a postcondition do not have their own\n\t\t\t// postconditions.\n\t\t\tverifyAtReturn: [],\n\t\t}, () => {\n\t\t\tconst reason: FailedVerification = {\n\t\t\t\ttag: \"failed-postcondition\",\n\t\t\t\treturnLocation: diagnosticReturnLocation,\n\t\t\t\tpostconditionLocation: verifyAtReturn.postcondition.location,\n\t\t\t};\n\n\t\t\t// Check if it's possible for the indicated boolean to be\n\t\t\t// false.\n\t\t\tconst refutation = state.checkPossiblyFalseInPath(verifyAtReturn.postcondition.postcondition, reason);\n\t\t\tif (refutation !== \"refuted\") {\n\t\t\t\tstate.failedVerifications.push(reason);\n\t\t\t}\n\t\t});\n\n\t\tstate.popVariableScope(postconditionVariableScope);\n\t\tstate.popTypeScope();\n\t\tstate.popHidingTypeScope(postconditionTypeScope);\n\t}\n}\n\nfunction traverseStaticCall(\n\tprogram: ir.Program,\n\top: ir.OpStaticCall,\n\tstate: VerificationState,\n): void {\n\tconst fn = op.function;\n\tconst signature = program.functions[fn].signature;\n\tif (state.interfaceSignaturesByImplFn.get(fn).length !== 0) {\n\t\tthrow new Error(\"impl functions cannot be invoked directly by static calls\");\n\t}\n\n\tconst valueArgs = [];\n\tfor (let i = 0; i < op.arguments.length; i++) {\n\t\tvalueArgs.push(state.getValue(op.arguments[i]).value);\n\t}\n\n\tconst typeArgs = [];\n\tconst typeArgsMap = new Map<ir.TypeVariableID, uf.ValueID>();\n\tfor (let i = 0; i < op.type_arguments.length; i++) {\n\t\tconst typeParameter = signature.type_parameters[i];\n\t\tconst typeArgument = op.type_arguments[i];\n\t\ttypeArgsMap.set(typeParameter, state.getTypeID(typeArgument));\n\t\ttypeArgs.push(state.getTypeID(typeArgument));\n\t}\n\n\tif (state.recursivePreconditions.blockedFunctions[fn] !== undefined) {\n\t\tthrow new diagnostics.RecursivePreconditionErr({\n\t\t\tcallsite: op.diagnostic_callsite,\n\t\t\tfn: fn,\n\t\t});\n\t} else {\n\t\tstate.recursivePreconditions.blockedFunctions[fn] = true;\n\n\t\tconst valueArgsMap = new Map<ir.VariableDefinition, uf.ValueID>();\n\t\tfor (let i = 0; i < valueArgs.length; i++) {\n\t\t\tvalueArgsMap.set(signature.parameters[i], valueArgs[i]);\n\t\t}\n\n\t\tfor (const precondition of signature.preconditions) {\n\t\t\tconst reason: FailedVerification = {\n\t\t\t\ttag: \"failed-precondition\",\n\t\t\t\tcallLocation: op.diagnostic_callsite,\n\t\t\t\tpreconditionLocation: precondition.location,\n\t\t\t};\n\n\t\t\tcheckPrecondition(program, valueArgsMap, typeArgsMap, precondition, state, reason);\n\t\t}\n\n\t\tdelete state.recursivePreconditions.blockedFunctions[fn];\n\t}\n\n\tconst smtFns = state.functions.get(fn);\n\tconst results = [];\n\tfor (let i = 0; i < op.destinations.length; i++) {\n\t\tconst result = state.smt.createApplication(smtFns[i], [...valueArgs, ...typeArgs]);\n\t\tresults.push(result);\n\t\tstate.defineVariable(op.destinations[i], result);\n\t}\n\n\tif (state.recursivePostconditions.blockedFunctions[fn] !== true) {\n\t\tstate.recursivePostconditions.blockedFunctions[fn] = true;\n\n\t\tfor (const postcondition of signature.postconditions) {\n\t\t\tconst valueArgsMap = new Map<ir.VariableDefinition, uf.ValueID>();\n\t\t\tfor (let i = 0; i < op.arguments.length; i++) {\n\t\t\t\tconst variable = signature.parameters[i];\n\t\t\t\tvalueArgsMap.set(variable, valueArgs[i]);\n\t\t\t}\n\t\t\tfor (let i = 0; i < op.destinations.length; i++) {\n\t\t\t\tconst variable = postcondition.returnedValues[i];\n\t\t\t\tvalueArgsMap.set(variable, results[i]);\n\t\t\t}\n\n\t\t\tassumePostcondition(program, valueArgsMap, typeArgsMap, postcondition, state);\n\t\t}\n\n\t\tdelete state.recursivePostconditions.blockedFunctions[fn];\n\t}\n}\n\nfunction traverseDynamicCall(\n\tprogram: ir.Program,\n\top: ir.OpDynamicCall,\n\tstate: VerificationState,\n): void {\n\tconst constraint = program.interfaces[op.constraint.interface];\n\tconst signature = constraint.signatures[op.signature_id];\n\n\tconst typeArgsMap = new Map<ir.TypeVariableID, uf.ValueID>();\n\tconst typeArgsList = [];\n\tfor (let i = 0; i < op.constraint.subjects.length; i++) {\n\t\tconst t = op.constraint.subjects[i];\n\t\tconst id = state.getTypeID(t);\n\t\ttypeArgsMap.set(constraint.type_parameters[i], id);\n\t\ttypeArgsList.push(id);\n\t}\n\tfor (let i = 0; i < op.signature_type_arguments.length; i++) {\n\t\tconst t = op.signature_type_arguments[i];\n\t\tconst id = state.getTypeID(t);\n\t\ttypeArgsMap.set(signature.type_parameters[i], id);\n\t\ttypeArgsList.push(id);\n\t}\n\n\tconst valueArgs = op.arguments.map(v => state.getValue(v).value);\n\n\tfor (const precondition of signature.preconditions) {\n\t\tthrow new Error(\"TODO\");\n\t}\n\n\tconst smtFns = state.dynamicFunctions.get(op.constraint.interface, op.signature_id as ir.FunctionID);\n\tconst results = [];\n\tfor (let i = 0; i < op.destinations.length; i++) {\n\t\tconst result = state.smt.createApplication(smtFns[i], [...valueArgs, ...typeArgsList]);\n\t\tresults.push(result);\n\t\tstate.defineVariable(op.destinations[i], result);\n\t}\n\n\tfor (const postcondition of signature.postconditions) {\n\t\tthrow new Error(\"TODO\");\n\t}\n\n\tif (signature.semantics?.eq === true) {\n\t\tthrow new Error(\"TODO\");\n\t}\n}\n","import * as diagnostics from \"./diagnostics\";\nimport * as grammar from \"./grammar\";\nimport * as interpreter from \"./interpreter\";\nimport * as ir from \"./ir\";\nimport * as lexer from \"./lexer\";\nimport * as semantics from \"./semantics\";\nimport * as verify from \"./verify\";\n\nexport interface SourceFile {\n\tpath: string,\n\tcontent: string,\n}\n\nexport type FunctionID = ir.FunctionID;\n\nexport function parseSource(sourceFile: SourceFile): grammar.Source | lexer.LexError | grammar.ParseError {\n\ttry {\n\t\treturn grammar.parseSource(sourceFile.content, sourceFile.path);\n\t} catch (e) {\n\t\tif (e instanceof lexer.LexError || e instanceof grammar.ParseError) {\n\t\t\treturn e;\n\t\t}\n\t\tthrow e;\n\t}\n}\n\nexport function compileASTs(asts: Record<string, grammar.Source>): ir.Program | diagnostics.SemanticError {\n\ttry {\n\t\treturn semantics.compileSources(asts);\n\t} catch (e) {\n\t\tif (e instanceof diagnostics.SemanticError) {\n\t\t\treturn e;\n\t\t}\n\t\tthrow e;\n\t}\n}\n\nexport function verifyProgram(\n\tprogram: ir.Program,\n): diagnostics.SemanticError | verify.FailedVerification[] {\n\ttry {\n\t\treturn verify.verifyProgram(program);\n\t} catch (e) {\n\t\tif (e instanceof diagnostics.SemanticError) {\n\t\t\treturn e;\n\t\t}\n\t\tthrow e;\n\t}\n}\n\nexport function interpret(\n\tprogram: ir.Program,\n\tfn: FunctionID,\n\targs: interpreter.Value[],\n): interpreter.Value[] {\n\treturn interpreter.interpret(fn, args, program, {\n\t\t\"Int+\": ([a, b]: interpreter.Value[]) => {\n\t\t\tif (a.sort !== \"int\") throw new Error(\"bad argument\");\n\t\t\tif (b.sort !== \"int\") throw new Error(\"bad argument\");\n\t\t\treturn [{ sort: \"int\", int: a.int + b.int }];\n\t\t},\n\t\t\"Int-\": ([a, b]: interpreter.Value[]) => {\n\t\t\tif (a.sort !== \"int\") throw new Error(\"bad argument\");\n\t\t\tif (b.sort !== \"int\") throw new Error(\"bad argument\");\n\t\t\treturn [{ sort: \"int\", int: a.int - b.int }];\n\t\t},\n\t\t\"Int==\": ([a, b]: interpreter.Value[]) => {\n\t\t\tif (a.sort !== \"int\") throw new Error(\"bad argument\");\n\t\t\tif (b.sort !== \"int\") throw new Error(\"bad argument\");\n\t\t\treturn [{ sort: \"boolean\", boolean: a.int == b.int }];\n\t\t},\n\t});\n}\n\nexport function formatVerificationFailure(\n\tv: verify.FailedVerification,\n): diagnostics.SemanticError {\n\tif (v.tag === \"failed-assert\") {\n\t\treturn {\n\t\t\tmessage: [\n\t\t\t\t\"An assert has not been shown to hold at\",\n\t\t\t\tv.assertLocation ? v.assertLocation : \" (unknown location)\",\n\t\t\t],\n\t\t};\n\t} else if (v.tag === \"failed-precondition\") {\n\t\treturn {\n\t\t\tmessage: [\n\t\t\t\t\"A precondition has not been shown to hold at\",\n\t\t\t\tv.callLocation,\n\t\t\t\t\"The precondition was defined at\",\n\t\t\t\tv.preconditionLocation,\n\t\t\t],\n\t\t};\n\t} else if (v.tag === \"failed-return\") {\n\t\treturn {\n\t\t\tmessage: [\n\t\t\t\t\"A function has not been shown to always return a value at\",\n\t\t\t\tv.blockEndLocation ? v.blockEndLocation : \" (unknown location)\",\n\t\t\t],\n\t\t};\n\t} else if (v.tag === \"failed-postcondition\") {\n\t\treturn {\n\t\t\tmessage: [\n\t\t\t\t\"A postcondition has not been shown to hold at\",\n\t\t\t\tv.returnLocation,\n\t\t\t\t\"The postcondition was defined at\",\n\t\t\t\tv.postconditionLocation,\n\t\t\t]\n\t\t};\n\t} else if (v.tag === \"failed-variant\") {\n\t\treturn {\n\t\t\tmessage: [\n\t\t\t\t\"An object of enum type `\" + v.enumType + \"` \",\n\t\t\t\t\"has not been shown to have variant tag `\" + v.variant + \"`, \",\n\t\t\t\t\"so the variant access of `.\" + v.variant + \"` is illegal at\",\n\t\t\t\tv.accessLocation,\n\t\t\t],\n\t\t};\n\t} else {\n\t\tconst _: never = v;\n\t\tthrow new Error(\"unhandled `\" + v[\"tag\"] + \"`\");\n\t}\n}\n\nexport class TextDocument {\n\tpublic lines: { content: string, offset: number }[] = [];\n\tconstructor(private path: string, private content: string) {\n\t\tlet offset = 0;\n\t\tfor (let line of content.split(\"\\n\")) {\n\t\t\tthis.lines.push({\n\t\t\t\tcontent: line + \" \",\n\t\t\t\toffset,\n\t\t\t});\n\t\t\toffset += line.length + 1;\n\t\t}\n\t}\n\n\tlocate(query: number): { offset: number, line0: number, char0: number } {\n\t\tif (query <= 0) {\n\t\t\treturn { offset: 0, line0: 0, char0: 0 };\n\t\t}\n\t\tfor (let i = 0; i < this.lines.length; i++) {\n\t\t\tlet next = this.lines[i].offset + this.lines[i].content.length;\n\t\t\tif (query <= next) {\n\t\t\t\treturn { offset: query, line0: i, char0: query - this.lines[i].offset };\n\t\t\t}\n\t\t}\n\t\tconst lastLine = this.lines[this.lines.length - 1];\n\t\treturn {\n\t\t\toffset: lastLine.offset + lastLine.content.length,\n\t\t\tline0: this.lines.length - 1,\n\t\t\tchar0: lastLine.content.length,\n\t\t};\n\t}\n\n\t/// `getLocus` returns a brief \"one word\" description of the given location.\n\tgetLocus(location: ir.SourceLocation): string {\n\t\tconst start = this.locate(location.offset);\n\t\tconst end = this.locate(location.offset + location.length);\n\t\tif (start.line0 === end.line0) {\n\t\t\treturn `${this.path}:${start.line0 + 1}:${start.char0 + 1}-${end.char0 + 1}`;\n\t\t} else {\n\t\t\treturn `${this.path}:${start.line0 + 1}:${start.char0 + 1}-${end.line0 + 1}:${end.line0 + 1}`;\n\t\t}\n\t}\n\n\tgetSnippetLine(\n\t\tline0: number,\n\t\thighlightStart: { offset: number, line0: number, char0: number },\n\t\thighlightEnd: { offset: number, line0: number, char0: number },\n\t\toptions: { tabSize: number },\n\t) {\n\t\tlet offset = this.lines[line0].offset;\n\t\tconst source = this.lines[line0].content;\n\t\tconst beforeHighlighted = source.substring(0, highlightStart.offset - offset);\n\t\tconst highlighted = source.substring(highlightStart.offset - offset, highlightEnd.offset - offset);\n\t\tconst afterHighlighted = source.substring(highlightEnd.offset - offset);\n\t\tconst groups = [beforeHighlighted, highlighted, afterHighlighted];\n\t\tlet carets = \"\";\n\t\tlet formatted = \"\";\n\t\tlet column = 0;\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\tconst group = groups[i];\n\t\t\tconst caret = (i === 1) ? \"^\" : \" \";\n\t\t\tconst TAB_OR_NONTABS = /(?:\\t|[^\\t]+)/g;\n\t\t\tlet match;\n\t\t\twhile ((match = TAB_OR_NONTABS.exec(group)) !== null) {\n\t\t\t\tlet word = match[0];\n\t\t\t\tif (word === \"\\t\") {\n\t\t\t\t\tconst w = options.tabSize - column % options.tabSize;\n\t\t\t\t\tword = \" \".repeat(w);\n\t\t\t\t}\n\n\t\t\t\tformatted += word;\n\t\t\t\tcolumn += word.length;\n\t\t\t\tcarets += caret.repeat(word.length);\n\t\t\t\tcolumn += word.length;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tformatted: formatted,\n\t\t\tcarets: carets,\n\t\t};\n\t}\n\n\tgetSnippet(highlighting: ir.SourceLocation, options: { tabSize: number }) {\n\t\tconst start = this.locate(highlighting.offset);\n\t\tconst end = this.locate(highlighting.offset + highlighting.length);\n\n\t\tconst rows: ({ tag: \"ellipses\" } | { tag: \"content\", line0: number, formatted: string, carets: string | null })[] = [];\n\t\tfor (let y of new Set([start.line0 - 1, start.line0, start.line0 + 1, end.line0 - 1, end.line0, end.line0 + 1])) {\n\t\t\tif (y < 0 || y >= this.lines.length) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rows.length !== 0) {\n\t\t\t\tconst previous = rows[rows.length - 1];\n\t\t\t\tif (previous.tag === \"content\" && previous.line0 < y - 1) {\n\t\t\t\t\trows.push({ tag: \"ellipses\" });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst row = this.getSnippetLine(y, start, end, options);\n\t\t\trows.push({\n\t\t\t\ttag: \"content\",\n\t\t\t\tline0: y,\n\t\t\t\tformatted: row.formatted,\n\t\t\t\tcarets: row.carets.trim() !== \"\" ? row.carets : null,\n\t\t\t});\n\t\t}\n\t\treturn rows;\n\t}\n}\n\nexport function displayError(e: { message: lexer.ErrorElement[] }, sourceList: SourceFile[]) {\n\tconst sources: Record<string, TextDocument> = {};\n\n\tlet s = \"ERROR: \";\n\tfor (let m of e.message) {\n\t\tif (typeof m === \"string\") {\n\t\t\ts += m;\n\t\t} else {\n\t\t\tconst fileID = m.fileID;\n\t\t\tif (!sources[fileID]) {\n\t\t\t\tconst source = sourceList.find(x => x.path === fileID);\n\t\t\t\tif (!source) {\n\t\t\t\t\ts += fileID + \":?\" + \"\\n\";\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsources[fileID] = new TextDocument(fileID, source.content);\n\t\t\t}\n\t\t\tconst source = sources[fileID];\n\t\t\ts += \" \" + source.getLocus(m);\n\t\t\ts += \":\\n\";\n\t\t\tconst mWide: ir.SourceLocation = {\n\t\t\t\tfileID: m.fileID,\n\t\t\t\toffset: m.offset,\n\t\t\t\tlength: Math.max(1, m.length),\n\t\t\t};\n\t\t\tconst rows = source.getSnippet(mWide, { tabSize: 4 });\n\t\t\tconst NUMBER_TRAY = 8;\n\t\t\tfor (let row of rows) {\n\t\t\t\tif (row.tag === \"content\") {\n\t\t\t\t\tconst n = (row.line0 + 1).toFixed(0);\n\t\t\t\t\ts += \"\\t\" + \" \".repeat(NUMBER_TRAY - n.length) + n + \" | \";\n\t\t\t\t\ts += row.formatted;\n\t\t\t\t\tif (row.carets !== null) {\n\t\t\t\t\t\ts += \"\\n\";\n\t\t\t\t\t\ts += \"\\t\" + \" \".repeat(NUMBER_TRAY) + \" | \";\n\t\t\t\t\t\ts += row.carets;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ts += \"\\t\" + \" \".repeat(NUMBER_TRAY - 3) + \"... |\"\n\t\t\t\t}\n\t\t\t\ts += \"\\n\";\n\t\t\t}\n\t\t\ts += \"\\n\";\n\t\t}\n\t}\n\treturn s;\n}\n"]}